<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="排序算法总结        快排首选，它的常数项经过试验是最低的 归并排特点：能保证稳定性 堆排：空间复杂度低 O(1)  为什么 Java 的 Arrays.sort() 会根据：  数组是基础数组，就用快排，因为不需要保证稳定性 数组是引用类型数组，就用归并，因为需要保证稳定性">
<meta property="og:type" content="article">
<meta property="og:title" content="【算法】排序算法">
<meta property="og:url" content="http://yuyun-zhao.github.io/2021/11/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="yuyun zhao&#39;s blog">
<meta property="og:description" content="排序算法总结        快排首选，它的常数项经过试验是最低的 归并排特点：能保证稳定性 堆排：空间复杂度低 O(1)  为什么 Java 的 Arrays.sort() 会根据：  数组是基础数组，就用快排，因为不需要保证稳定性 数组是引用类型数组，就用归并，因为需要保证稳定性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211005221404802-1633921404335.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211002195502529-1633921209453.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211002214054579-1633921248245.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211003121356235-1633921272991.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211003204741869-1633921306506.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211003201744690-1633921333456.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211004174447857-1633921333457.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211004203745738-1633921354763.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211004203713788-1633921354763.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211004204032904-1633921378395.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211005184227223-1633921396069.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211005184133152-1633921396069.png">
<meta property="article:published_time" content="2021-11-10T13:16:18.000Z">
<meta property="article:modified_time" content="2021-12-14T14:06:28.240Z">
<meta property="article:author" content="yuyun zhao">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211005221404802-1633921404335.png"><title>【算法】排序算法 | yuyun zhao's blog</title><link ref="canonical" href="http://yuyun-zhao.github.io/2021/11/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">文章</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">yuyun zhao's blog</div><div class="header-banner-info__subtitle">no code no life</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">【算法】排序算法</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-12-14</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">11.2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">74分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h2 id="排序算法总结"   >
          <a href="#排序算法总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#排序算法总结"></a> 排序算法总结</h2>
      
<p>快排首选，它的常数项经过试验是最低的</p>
<p>归并排特点：能保证稳定性</p>
<p>堆排：空间复杂度低 O(1)</p>
<p><img src="/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211005221404802-1633921404335.png" alt="image-20211005221404802" /></p>
<p>为什么 Java 的 <code>Arrays.sort()</code> 会根据：</p>
<ul>
<li>数组是基础数组，就用快排，因为不需要保证稳定性</li>
<li>数组是引用类型数组，就用归并，因为需要保证稳定性</li>
</ul>
<span id="more"></span>

        <h2 id="选择排序"   >
          <a href="#选择排序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h2>
      
<p>遍历数组的 i ～ N-1 范围内的元素，选出该范围内的最小值与 i 位置进行交换；重复上述过程 N-1 次直到完成排序。</p>
<p>总结：从前往后缩小范围遍历，选择当前范围内最小的数，放在当前范围的队首。队伍前面的数字都是排好序的小数，队伍后面的数字都是待排序的。</p>
<ul>
<li>时间复杂度 O(N^2)</li>
<li>额外空间复杂度O(1)</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> minIndex = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="comment">// 寻找 i ~ N-1 位置上的最小值索引, 全部遍历完找到索引后再进行交换</span></span><br><span class="line">        minIndex = (arr[minIndex] &lt; arr[j]) ? minIndex : j;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<hr />
<p>补充：一种交换数据a和b的方式：连续三次异或。前提是a和b在内存中处于不同的空间，并且 arr[a] 不能等于 arr[b]，否则得到的结果是0。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这种方式的弊端: arr[a] 和 arr[b] 不能相等</span></span><br><span class="line">  arr[i] = arr[i] ^ arr[j]; </span><br><span class="line">  arr[j] = arr[i] ^ arr[j];</span><br><span class="line">  arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<hr />

        <h2 id="冒泡排序"   >
          <a href="#冒泡排序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h2>
      
<p>遍历数组 0～i 范围内的元素，比较当前元素与其后元素的大小，若当前元素较大则与其交换（像冒泡一样不断将比较大的元素向数组队尾移动），从而将该范围内的最大值元素后移放到 i 位置。</p>
<p>总结：从前往后缩小范围遍历，选择当前范围内最大的数，放在当前范围的队尾。队伍前面的数字都是待排序的，队伍后面的数字都是排好序的大数。</p>
<ul>
<li>时间复杂度 O(N^2)</li>
<li>额外空间复杂度O(1)</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">                    swap(arr, j, j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这种方式的弊端: arr[a] 和 arr[b] 不能相等</span></span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="插入排序"   >
          <a href="#插入排序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h2>
      
<p>遍历 0 ～ i 范围内的元素，从后往前判断当前元素是否小于前一个元素，若小于则将二者进行交换，直到前一个元素小于当前元素。类似扑克牌中新来的牌不断判断与上一个牌的大小，直到将牌插入到符合条件的位置。</p>
<p>总结：从前往后遍历，将当前范围内的数字排好序，新来的数据插入到前面排好序的数字的适当位置中。队伍前面的数字都是排好序的小数，队伍后面的数字都是待排序的。</p>
<ul>
<li>时间复杂度 O(N^2)</li>
<li>额外空间复杂度O(1)</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="comment">//            for (int j = i; j &gt; 0; j--) &#123;</span></span><br><span class="line"><span class="comment">//                if (arr[j] &gt; arr[j-1]) &#123;</span></span><br><span class="line"><span class="comment">//                    break;</span></span><br><span class="line"><span class="comment">//                &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                    swap(arr, j, j-1);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更简洁的写法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j-<span class="number">1</span>]; j--) &#123;</span><br><span class="line">                swap(arr, j, j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这种方式的弊端: arr[a] 和 arr[b] 不能相等</span></span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="归并排序"   >
          <a href="#归并排序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2>
      
<p>归并排序 = 递归 + 合并 的排序。</p>
<p>算法大致流程：</p>
<ol>
<li>将整个数组平均划分为两部分</li>
<li>先将左侧的半个数组排序</li>
<li>再将右侧的半个数组排序</li>
<li>开辟一个和目标数组相同大小的数组空间</li>
<li>定义两个指针Left和Right，分别指向左侧数组和右侧数组的第一个元素，再定义一个指针i，指向新数组的第一个元素</li>
<li>不断遍历左右数组移动指针，判断Left和Right指向的元素大小：
<ol>
<li>若Left小于等于Right，则将新数组的当前位置i赋值为Left指向的元素</li>
<li>若Left大于Right，则将新数组的当前位置i赋值为Right指向的元素</li>
</ol>
</li>
<li>不断执行步骤6，每次要么移动Left，要么移动Right，直到某一个指针达到数组末尾；再将另一半数组的后面的所有元素拷贝到新数组的末尾。</li>
</ol>
<p>将整个数组<strong>递归</strong>执行上述 1-7 的过程，从完整的数组不断递归地平均拆分，直到递归到最底层的<strong>前一层</strong>：</p>
<ul>
<li><code>process(arr, Left, Left+1)</code></li>
<li><code>process(arr, Left+1, Right)</code></li>
<li><code>merge(arr, Left, Right)</code></li>
</ul>
<p>其中，Left = Right -2，<code>process(arr, Left, Left+1)</code> 里会将 [Left, Left+1] 范围内的两个数字进行排序, 再调用 <code>process(arr, Left+1, Right)</code>里会将 [Left+1, Right] 范围内的两个排序（此时 Left+1 位置上的数组已经经过了前一步的排序），因此归并排序最底层的合并排序只有两个数字进行比大小。（该过程可参考下文代码）</p>
<p>经过上述步骤后，即将 [Left, Left+1, Right] 范围内的三个数字进行了排序，递归开始返回，不断的将更大范围内的数组进行归并排序，直到递归返回到第二层时数组被分为了两半，左侧数组和右侧数组都进行了排序，再对二者进行一次 merge，即完成了整个数组的归并排序。</p>
<blockquote>
<p>例如：第一条递归分支一直从 process(arr, 0, 2) --&gt; process(arr, 0, 1) --&gt; process(arr, 0, 0) + process(arr, 1, 1) + merge(arr, 0, 1, 0)。此时递归到了底部，process(arr, 0, 0) 和 process(arr, 1, 1) 都直接 return ，剩余 merge(arr, 0, 1, 0) 将合并左右数组 arr[0] 与 arr[1] 这两个数字，将二者合并到一个新的数组中。</p>
</blockquote>
<hr />
<p>递归行为的时间复杂度估算公式：</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?p=3" >https://www.bilibili.com/video/BV13g41157hK?p=3</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p><img src="/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211002195502529-1633921209453.png" alt="image-20211002195502529" /></p>
<p>其中，b为数组被平均分的份数（二分归并排序算法里等于2），a为每次拆分时调用几个递归分支（二分归并排序算法里等于2），O(N^d) 为递归到底部时进行的操作的时间复杂度，根据不同的应用场景有不同的复杂度，例如在求数组最大值时，d=0；在归并排序里，d=1</p>
<p>举例：</p>
<ul>
<li>在二分递归求数组最大值问题时，T(N) = 0.5 * T(N / 2) + O(1)</li>
<li>在数组二分归并排序问题时，T(N) = 0.5 * T(N / 2) + O(N)</li>
</ul>
<p>根据上图中的计算公式，归并排序算法的时间复杂度为 O(N*log(N))</p>
<hr />
<p>总结：归并排序就是不断递归地将数组拆分成更小的数组，直到最底层时拆分成的两个数组中<strong>每个数组只有一个数字</strong>，对这两个数字进行<strong>排序并合并</strong>后返回，不断返回后合并出的数组就越来越长，直到整个数组被合并排序。</p>
<p>归并排序的时间复杂度：</p>
<ul>
<li>时间复杂度 O(N*log(N))</li>
<li>额外空间复杂度O(N)</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        process(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算中点, 能避免范围溢出</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两条递归分支</span></span><br><span class="line">        process(arr, left, mid);</span><br><span class="line">        process(arr, mid+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两条递归分支会一直递归到: 划分的两个数组各有一个元素, 将这两个元素进行排序并合并</span></span><br><span class="line">        merge(arr, left, right, mid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 指向左数组的第一个</span></span><br><span class="line">        <span class="keyword">int</span> p1 = left;</span><br><span class="line">        <span class="comment">// 指向右数组的第一个</span></span><br><span class="line">        <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 递归到最底部时，left == mid == right - 1。此时左数组为[left]；右数组为[right]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针一起向右移动,将当前较小的元素拷贝到tmp中,只会有其中的某一个数组的指针先到数组尾部</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">            tmp[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将另一个数组的剩下所有元素拷贝到tmp中,只会有一个满足条件</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">            tmp[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= right) &#123;</span><br><span class="line">            tmp[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tmp中的元素拷贝回原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; tmp.length; n++) &#123;</span><br><span class="line">            arr[left + n] = tmp[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>补充：使用递归的方法计算数组中最大值时，只需要将合并操作 merge 替换成求两个数字最大值的操作 <code>Math.max(left, right)</code></p>
</blockquote>

        <h3 id="归并排序的扩展小和问题和逆序对问题"   >
          <a href="#归并排序的扩展小和问题和逆序对问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#归并排序的扩展小和问题和逆序对问题"></a> 归并排序的扩展：小和问题和逆序对问题</h3>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?p=3" >https://www.bilibili.com/video/BV13g41157hK?p=3</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p><img src="/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211002214054579-1633921248245.png" alt="image-20211002214054579" /></p>
<p>小和问题和逆序对问题本质上都是归并排序，二者是等价的。求每一个数左边比当前数小的数字的累积等价于求每一个数右边比当前数大的个数 * 自身大小。</p>
<ul>
<li>不断递归拆分数组，直到递归返回、数组开始合并时：</li>
<li>在合并排序前使用双指针判断左侧数组当前元素是否小于右侧数组当前元素：
<ul>
<li>若小于，说明左侧当前元素比右侧数组当前元素之后的所有元素都要小（因为右侧数组都是排好序的，所以可以直接用索引数量计算出小和，不用再遍历判断大小了），那么就把<strong>左侧当前元素大小 * 右侧当前元素之后的元素数量</strong>，即可得到左侧当前元素相对右侧数组而言的的小和数</li>
<li>若等于，则此时不计算小和，把<strong>右侧</strong>数组的当前元素拷贝到临时数组中（之所以优先拷贝右侧是因为这样在排序后，之后的循环再比较大小时就不会把右侧数组中等于该元素大小的数字计算在内，因为相等的数字不在小和范围内）</li>
<li>若大于，则不计算小和，将右侧数组的当前元素拷贝到临时数组中，右侧指针移动，进入下一次循环</li>
</ul>
</li>
<li>左右数组中的某一个遍历完毕后，即可将另一个数组的剩余元素拷贝到临时数组中，这之后的步骤就同归并排序一样了。</li>
</ul>
<p>这种思想既不会漏算小和，又不会重算小和，因为某个元素只有在和右侧的数组 merge 时才会计算右侧数组内有几个数比其大，然后一旦 merge 后，其在合并后的组内就不会再去重复计算组内有没有比他大的。因此不会漏算，也不会重算。</p>
<p>小和问题的代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 返回三者的和</span></span><br><span class="line">        <span class="keyword">return</span> process(arr, left, mid) + process(arr, mid+<span class="number">1</span>, right) + merge(arr, left, right, mid);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = left;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 若当前元素arr[p1]小于右侧数组的当前元素arr[p2]</span></span><br><span class="line">            <span class="comment">// 计算小和 = 当前元素的大小 * 右侧数组当前所有往右的数字的个数</span></span><br><span class="line">            <span class="comment">// 因为右侧数组已经排好序了, 所以可以直接用索引个数计算小和,而不用再遍历判断了</span></span><br><span class="line">            result += arr[p1] &lt; arr[p2] ? arr[p1] * (right - p2 + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算完小和后进行合并排序,将p1和p2中较小的那一个拷贝到tmp中</span></span><br><span class="line">            <span class="comment">// 相等的情况下优先把右侧数组的数字拷贝,这样就能避免重复算的情况</span></span><br><span class="line">            tmp[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后面就和归并排序一样了</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">            tmp[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= right) &#123;</span><br><span class="line">            tmp[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; tmp.length; n++) &#123;</span><br><span class="line">            arr[n + left] = tmp[n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>逆序对问题的代码：</p>
<p>未来补充</p>

        <h2 id="快速排序"   >
          <a href="#快速排序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2>
      

        <h3 id="快速排序前奏一荷兰国旗问题"   >
          <a href="#快速排序前奏一荷兰国旗问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#快速排序前奏一荷兰国旗问题"></a> 快速排序前奏一：荷兰国旗问题</h3>
      
<blockquote>
<p>类似问题：将一个数组中奇数数字放到数组左边，偶数数字放到数组右边。</p>
</blockquote>
<p><img src="/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211003121356235-1633921272991.png" alt="image-20211003121356235" /></p>
<p>问题二：小于等于 num 的数放在数组的左边，等于 num 的数放在数组的中间，大于 num 的数放在数组的右边。</p>
<p>排序效果：像荷兰国旗一样，将数组分为三个区域，左侧区域为小于 num 的数字；中间区域为等于 num 的数字；右侧区域为等于 num 的数字。</p>
<p>本质是一种<strong>分区思想</strong>，将数组分为三个区域。</p>
<p>思路：</p>
<ul>
<li>定义一个<strong>小于区域</strong>，在其内存储小于 num 的数字，定义一个<strong>大于区域</strong>，在其内存储大于 num 的数字，定义一个<strong>等于区域</strong>，在其内存储等于 num 的数字。</li>
<li>定义三个指针，一个指针 i 不断向右移动，另一个指针 left 指向<strong>小于区域</strong>右侧的下一个数字（该数字不在小于区域内），最后一个指针指向<strong>大于区域</strong>内最左侧的数字（该数字在大于区域内）。</li>
<li>遍历数组，判断当前元素 arr[i] 和 num 的大小关系：
<ul>
<li>如果 arr[i] 等于 num，则指针 i 右移一位，不做其他操作</li>
<li>如果 arr[i] 小于 num，则先将 i 位置的元素和 left 位置的元素（小于区域的右侧下一个元素）进行交换，然后指针 i 和 left 右移一位</li>
<li>如果 arr[i] 大于 num，则将 i 位置的元素和 right 位置的元素（大于区域内左侧的元素）进行交换，然后指针 right 左移一位，<strong>指针 i 不移动</strong>（因为右侧交换之后并不能确定右侧换过来的这个数是不是比 num 小，还需要再进下一次循环判断交换后的 i 位置的数字是否小于 num）</li>
</ul>
</li>
<li>遍历的终止条件：<code>i == right</code></li>
</ul>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hollandFlag</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; num) &#123;</span><br><span class="line">            <span class="comment">// 令小于区域的右边下一个元素和当前元素交换, 两个指针都右移一位</span></span><br><span class="line">            <span class="comment">// 如果不交换, 则和 num 相等的区域中就会混杂着小于区域的数字</span></span><br><span class="line">            <span class="comment">// 因此为了区分小于区域和等于区域,必须要交换</span></span><br><span class="line">            swap(arr, i++, ++left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; num) &#123;</span><br><span class="line">            <span class="comment">// 右侧只交换, i先不进行--, 因为右侧交换之后并不能确定右侧换过来的这个数是不是比num小</span></span><br><span class="line">            <span class="comment">// 还需要再进下一次循环判断交换后的i位置的数字是否小于num</span></span><br><span class="line">            swap(arr, i, right--);</span><br><span class="line">            System.out.println(<span class="string">&quot;right = &quot;</span> + right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// arr[i] == num 时, i++, 不做其他操作</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前的 i 是否已经等于了 right, 如果已经等于了, 说明双向奔赴结束</span></span><br><span class="line">        <span class="keyword">if</span> (i == right) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换 a 和 b 位置上的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这种方式的弊端: arr[a] 和 arr[b] 不能相等</span></span><br><span class="line">    arr[a] = arr[a] ^ arr[b];</span><br><span class="line">    arr[b] = arr[a] ^ arr[b];</span><br><span class="line">    arr[a] = arr[a] ^ arr[b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>快速排序中同样使用这种分区的思想，并将该思想和递归操作合并。</p>

        <h3 id="快速排序前奏二数组奇偶分离"   >
          <a href="#快速排序前奏二数组奇偶分离" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#快速排序前奏二数组奇偶分离"></a> 快速排序前奏二：数组奇偶分离</h3>
      
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<p>借助这道题总结出分区类型题目的解决模板套路。注意下面 left 和 right 的设置方式：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左边界内的 [... left] 都是奇数，left + 1 是交换的下一个</span></span><br><span class="line">    <span class="keyword">int</span> left = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右边界内的 [ right ...] 都是偶数， right - 1 是要交换的下一个</span></span><br><span class="line">    <span class="keyword">int</span> right = nums.length;</span><br><span class="line">    <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当curr==right时，代表左分区和右分区都计算完毕，结束循环</span></span><br><span class="line">    <span class="keyword">while</span> (curr &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 如果是奇数，和左分区的下一个 left + 1 交换</span></span><br><span class="line">        <span class="keyword">if</span> (nums[curr] &amp; <span class="number">1</span> == <span class="number">1</span>) &#123; <span class="comment">// 等价于 nums[curr] % 2 == 1</span></span><br><span class="line">            swap(nums, left + <span class="number">1</span>, curr);</span><br><span class="line">            <span class="comment">// 交换后开始下一个位置判断</span></span><br><span class="line">            curr++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是偶数，和右分区的下一个 right - 1 交换</span></span><br><span class="line">            swap(nums, right - <span class="number">1</span>, curr);</span><br><span class="line">            right--;</span><br><span class="line">            <span class="comment">// 右分区交换后不能curr++，还要进行下一轮的判断交换后的数字满不满足奇数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[a];</span><br><span class="line">    nums[a] = nums[b];</span><br><span class="line">    nums[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="快速排序思想"   >
          <a href="#快速排序思想" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#快速排序思想"></a> 快速排序思想</h3>
      
<p><img src="/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211003204741869-1633921306506.png" alt="image-20211003204741869" /></p>
<p>快速.排序共有三个版本，版本一二分别对应了荷兰国旗中的问题一、问题二；版本三对应了问题二的<strong>随机取数字</strong>版本。</p>
<p>快速排序的思想是：<strong>递归</strong> + <strong>分区</strong>。即在递归过程中，首先将当前子数组进行分区，然后再在分好的小于区域内进行递归、接着在分好的大于区域内进行递归。这样最后递归完成时，整个数组就排好了序。</p>

        <h3 id="三个版本分区方式"   >
          <a href="#三个版本分区方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#三个版本分区方式"></a> 三个版本分区方式</h3>
      
<ul>
<li>版本一没有等于区域，小于等于 num 的数字都在小于区域，并且小于区域最右边的是等于的数</li>
<li>版本二加入了等于区域，将整个数组划分为了小于区域、等于区域和大于区域</li>
<li>版本三的分区方式与版本二相同，区别在于取 num 的方式变为了随机取。</li>
</ul>
<p>在快速排序的某个分区中，每次比较的数字 num 为该分区中数组的某一个数字（版本一二中 num 为数组的最后一个元素，版本三中数字改为随机选取）</p>

        <h3 id="算法流程"   >
          <a href="#算法流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#算法流程"></a> 算法流程</h3>
      
<ul>
<li>选取一个数字作为 num 和其他数字比较。在版本一二中，该数字选取数组中的最后一个元素；版本三种该数字随机选取数组中的某一个元素</li>
<li>随机选取数字的具体实现方式为：在当前 [left, right] 范围内生成一个随机数索引值，并将该元素与当前范围内的 right 位置的元素进行交换，这样后续的分区方法内只用统一的用 arr[right] 进行比较即可</li>
<li>先将整个数组进行分区，得到小于区域、等于区域、大于区域。此时等于区域后续就不需要再排序了</li>
<li>接着<strong>递归</strong>地将小于区域和大于区域进行分区，同样分为小于区域、等于区域、大于区域</li>
<li>相当于小于区域内再继续划分，此时划分出来的数字肯定都比原数组里的等于区域小了，所以不会重复排序</li>
<li>递归完成后，每个划分好的子数组都完成了分区，这样整个数组就完成了排序</li>
</ul>
<p>细节：其中，在分区后需要记录<strong>等于区域</strong>的<strong>左右边界</strong>，后续小于区域和大于区域内的递归划分需要用到这两个边界值，只在左右边界之外的区域内进行递归分区</p>

        <h3 id="关于取数字-num-的方式"   >
          <a href="#关于取数字-num-的方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关于取数字-num-的方式"></a> 关于取数字 num 的方式</h3>
      
<p>版本二的快排本身已经足够优秀，但是因为可能人为制造糟糕数据（故意让最后一个元素最大，造成每次都要遍历所有元素），因此最坏情况的时间复杂度为 O(N^2)。</p>
<p>为了应付这种最坏情况，版本三的快排采用了<strong>随机取数字</strong>的方式：随机方式消除了极端情况，使得算法整体的时间复杂度为 O(N*logN)。</p>
<p>版本三的快速排序代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 在当前区间内随机取一个索引, 令其与 arr[right] 交换</span></span><br><span class="line">            <span class="comment">// 这样分区方法内就可以统一用 arr[right] 进行比较了</span></span><br><span class="line">            swap(arr, left + (<span class="keyword">int</span>) (Math.random() * (right - left + <span class="number">1</span>)), right);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;after swap: &quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先分区</span></span><br><span class="line">            <span class="keyword">int</span>[] bound = partition(arr, left, right);</span><br><span class="line">            <span class="comment">// 需要一个变量存储当前等于区域的数字位置</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;after partition: &quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">            quickSort(arr, left, bound[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, bound[<span class="number">1</span>] + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分区: 就是荷兰国旗问题</span></span><br><span class="line">    <span class="comment">// 默认以 arr[right] 作为 num 进行比较</span></span><br><span class="line">    <span class="comment">// 返回等于区域的左右边界 bound[0] bound[1]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="comment">// i不断遍历, less指向小于区域的右边界, more指向大于区域的左边界</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> less = left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存 num 的值以免交换后被替换掉</span></span><br><span class="line">        <span class="keyword">int</span> num = arr[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里要 &lt;= more, 边界条件有=</span></span><br><span class="line">        <span class="comment">// 因为 more 在上一次减一后指向的的元素不包含在大于区域内</span></span><br><span class="line">        <span class="comment">// 所以这个元素需要加入到循环中判断</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; num) &#123;</span><br><span class="line">                <span class="comment">// less 最后指向的是小于区域的右边界(在小于区域范围内)</span></span><br><span class="line">                swap(arr, ++less, i++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; num) &#123;</span><br><span class="line">                <span class="comment">// more 最后指向的是大于区域的左边界(在大于区域范围外)</span></span><br><span class="line">                swap(arr, i, more--);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回 等于区域 的左\右边界</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less + <span class="number">1</span>, more&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="快速排序的空间复杂度"   >
          <a href="#快速排序的空间复杂度" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#快速排序的空间复杂度"></a> 快速排序的空间复杂度</h3>
      
<ul>
<li>最差情况是 O(N)，每一层递归都选在了最差的位置，占用了一个空间保存数据</li>
<li>最好的情况是 O(logN)，每一层递归都选在了比较好的中点位置，就会以一个二叉树的形式向下递归，同时每一层的空间都可以复用（左侧的数组分好区后，方法栈向上弹出，那个中点位置的空间就可以释放，让给右侧的数组压栈使用）</li>
</ul>
<p>这个中点的位置即是上文代码中保存的每一次分区后<strong>等于区域的左右边界位置</strong>，其必须要记录，用于记录哪里是小于区域，哪里是大于区域，只在其内进行递归分区，这样就能保证不重复排序。</p>
<blockquote>
<p>其作用是在递归调用结束后，方法栈弹出返回到当时调用它的母方法时，能够知道右侧哪个区域将要继续开始向下递归分区。因此这个中点数据的空间是不能省略的，必须要存在用来记录分区的边界</p>
</blockquote>
<p><strong>当采用随机取 num 的策略时，整体的空间复杂度就是 O(logN)</strong></p>

        <h3 id="快速排序的扩展问题"   >
          <a href="#快速排序的扩展问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#快速排序的扩展问题"></a> 快速排序的扩展问题</h3>
      
<p>只要有分区特性（数字按照某种0/1规则分成两/三个区）的题目都可以用快排来做</p>
<ol>
<li>将一个数组中奇数数字放到数组左边，偶数数字放到数组右边。这就可以用快排来做，只不过在分区时，快排中是设置小于等于某个数字的放到左边，这道题是奇数放到左边。（本质还是一个荷兰国旗问题）</li>
</ol>

        <h3 id="快速排序的常见题目"   >
          <a href="#快速排序的常见题目" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#快速排序的常见题目"></a> 快速排序的常见题目</h3>
      

        <h4 id="最小的-k-个数"   >
          <a href="#最小的-k-个数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#最小的-k-个数"></a> 最小的 K 个数</h4>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/" >https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" >剑指 Offer 40. 最小的k个数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>：输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p><strong>方法一：堆</strong></p>
<p>我们用一个大根堆<strong>实时维护数组的前 k 小值</strong>。首先将前 k 个数插入大根堆中，随后从第 k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 大根堆不断维护当前小的k个数字，当来新的数字，如果比堆顶大</span></span><br><span class="line"><span class="comment">//（比当前k个小数里的最大的小，说明这个最大的堆顶肯定不在答案里了），弹出堆顶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers01(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 注意！！将系统默认的小根堆改成大根堆</span></span><br><span class="line">    Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">            maxHeap.offer(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxHeap.peek() &gt; arr[i]) &#123;</span><br><span class="line">                maxHeap.poll();</span><br><span class="line">                maxHeap.offer(arr[i]);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 弹出前k个元素</span></span><br><span class="line">    <span class="keyword">while</span> (!maxHeap.isEmpty()) &#123;</span><br><span class="line">        res[i++] = maxHeap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>方法二：快排思想</strong></p>
<p>快排的划分函数每次执行完后都能将数组分成两个部分，小于等于分界值 <code>pivot</code> 的元素的都会被放到数组的左边，大于的都会被放到数组的右边，然后返回分界值的下标。与快速排序不同的是，快速排序会根据分界值的下标递归处理划分的两侧，而这里我们只处理划分的一边。</p>
<p>我们定义函数 <code>randomized_selected(arr, l, r, k)</code> 表示划分数组 <code>arr</code> 的 <code>[l,r]</code> 部分，使前 <code>k</code> 小的数在数组的左侧，在函数里我们调用快排的划分函数，假设划分函数返回的下标是 <code>pos</code>（表示分界值 <code>pivot</code> 最终在数组中的位置），即 <code>pivot</code> 是数组中第 <code>pos - l + 1</code> 小的数，那么一共会有三种情况：</p>
<ul>
<li>如果 <code>pos - l + 1 == k</code>，表示 <code>pivot</code> 就是第 k<em>k</em> 小的数，直接返回即可；</li>
<li>如果 <code>pos - l + 1 &lt; k</code>，表示第 k<em>k</em> 小的数在 <code>pivot</code> 的右侧，因此递归调用 <code>randomized_selected(arr, pos + 1, r, k - (pos - l + 1))</code>；</li>
<li>如果 <code>pos - l + 1 &gt; k</code>，表示第 k<em>k</em> 小的数在 <code>pivot</code> 的左侧，递归调用 <code>randomized_selected(arr, l, pos - 1, k)</code>。</li>
</ul>
<p>函数递归入口为 <code>randomized_selected(arr, 0, arr.length - 1, k)</code>。在函数返回后，将前 k 个数放入答案数组返回即可。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 改进版快排</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以pos为分界线，左侧都小于等于该值，右侧都大于该值</span></span><br><span class="line">    <span class="keyword">int</span> pos = randomPartition(arr, left, right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前number个元素正好是前k个，则完成了排序，返回</span></span><br><span class="line">    <span class="comment">// 此时前面有 pos + 1 个元素</span></span><br><span class="line">    <span class="keyword">if</span> (pos == k - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果k在number左边，则只需要对左侧进行分区</span></span><br><span class="line">        quickSearch(arr, left, pos - <span class="number">1</span>, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果k在number右边，则number左边的都是答案，只需要对右侧进行分区</span></span><br><span class="line">        quickSearch(arr, pos + <span class="number">1</span>, right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    swap(arr, left + (<span class="keyword">int</span>)(Math.random() * (right - left + <span class="number">1</span>)), right);</span><br><span class="line">    <span class="keyword">return</span> partition(arr, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// l：左侧区域的最右元素</span></span><br><span class="line">    <span class="keyword">int</span> l = left - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// r：右侧区域的最左元素</span></span><br><span class="line">    <span class="keyword">int</span> r = right + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 二者一开始都为空，所以在数组范围之外</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curr = left;</span><br><span class="line">    <span class="keyword">int</span> num = arr[right];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// curr == r 时，curr就已经在右侧区域内了</span></span><br><span class="line">    <span class="keyword">while</span> (curr &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[curr] &lt; num) &#123;</span><br><span class="line">            swap(arr, ++l, curr++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[curr] &gt; num) &#123;</span><br><span class="line">            swap(arr, --r, curr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="堆排序"   >
          <a href="#堆排序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h2>
      

        <h3 id="堆结构"   >
          <a href="#堆结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#堆结构"></a> 堆结构</h3>
      
<p><img src="/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211003201744690-1633921333456.png" alt="image-20211003201744690" /></p>
<blockquote>
<p>堆结构本身比堆排序要重要</p>
</blockquote>
<p>堆结构就是用数组实现的<strong>完全二叉树</strong>结构。</p>
<img src="/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211004174447857-1633921333457.png" alt="image-20211004174447857" style="zoom:50%;" />
<p>堆结构的节点公式：</p>
<ul>
<li>节点 i 的父节点为 (i - 1) / 2（左右节点都可以统一用这个公式）</li>
<li>节点 i 的左子节点为 2 * i + 1</li>
<li>节点 i 的右子节点为 2 * i + 2</li>
</ul>
<p>使用上述公式即直接定位到某个节点的父/子节点</p>

        <h3 id="大小根堆"   >
          <a href="#大小根堆" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#大小根堆"></a> 大/小根堆</h3>
      
<ul>
<li><strong>大根堆</strong>：堆中的每一个父节点都要比其子节点上的数字大（不考虑其对称的另一侧分支里的节点数字大小）。</li>
<li><strong>小根堆</strong>：堆中的每一个父节点都要比其子节点上的数字小（不考虑其对称的另一侧分支里的节点数字大小）。</li>
</ul>
<p>堆结构最重要的两个操作：</p>
<ul>
<li><strong>heapInsert</strong>：add 操作，<strong>新增</strong>一个数据到已知堆中。具体做法是新增的数据不断向上遍历堆结构，将数字插入到合适的父节点位置</li>
<li><strong>heapify</strong>：poll 操作，<strong>弹出</strong>堆里第一个元素（根节点）的值，并重新调整堆结构，令其余部分的元素继续保持大/小根堆结构。具体做法是新的根结点的元素不断向下遍历堆结构，交换其到合适的子节点位置</li>
</ul>
<hr />
<p><strong>heapInsert</strong>：add 操作。用于新增一个数据到堆中，当新来一个数字时，将其添加到堆结构中，并且满足大根堆（或小根堆）：向上遍历他的每一个父节点，判断其是否大于它的父节点，若大于则和父节点交换，若小于则停止遍历。直到当前数字放到合适的父节点位置，使得当前堆满足大根。</p>
<p><strong>heapify</strong>：poll 操作。用于弹出堆中第一个元素，并令其余部分继续保持大/小根堆结构，若用户要求返回并删除当前大根堆的最大元素，并且要求删除后的其他元素依旧符合大根堆：返回当前堆的第一个节点（其肯定是最大元素），然后将当前堆的最后一个元素放到第一个元素的位置。之后开始向下遍历第一个元素的子节点，选出其子节点中最大的数字，并且判断该数字和自身的大小，若子节点数字更大，则交换自身和子节点，若子节点数字更小，则停止遍历；直到该元素被放到合适的子节点位置。</p>
<hr />
<p>这两个操作的空间复杂度都是 O(logN)，因为 N 个节点的完全二叉树的高度为 O(logN)，上述两个操作都只需要遍历二叉树中的某一条分支即可，因此时间只有 O(logN)</p>
<p>heapInsert 的代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 向上遍历当前节点的父节点,直到满足条件: 父节点的值 &gt; 当前节点的值</span></span><br><span class="line">  <span class="keyword">while</span> (arr[(index - <span class="number">1</span>) / <span class="number">2</span>] &lt; arr[index]) &#123;</span><br><span class="line">    swap(arr, (index - <span class="number">1</span>) / <span class="number">2</span>, index);</span><br><span class="line">    index = (index - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// index 记得变为父节点的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>heapify 的代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heapSize 用于表示逻辑上的堆的大小, 其和数组的大小没关系</span></span><br><span class="line"><span class="comment">// 该方法的作用是, 在给定堆结构中, 当某个位置的元素被弹出,替换成了其他数字后</span></span><br><span class="line"><span class="comment">// 要保证新的数组仍然保持堆结构, 那么就需要从这个位置开始向下遍历</span></span><br><span class="line"><span class="comment">// 交换其子节点中最大的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heapSize &gt; arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>*index+<span class="number">1</span> &lt; heapSize) &#123;</span><br><span class="line">        <span class="comment">// 两个孩子中, 判断谁的值更大</span></span><br><span class="line">        <span class="keyword">int</span> largest = (<span class="number">2</span>*index+<span class="number">2</span> &lt; heapSize) &amp;&amp; arr[<span class="number">2</span>*index+<span class="number">1</span>] &lt; arr[<span class="number">2</span>*index+<span class="number">2</span>]</span><br><span class="line">            ? <span class="number">2</span>*index+<span class="number">2</span> : <span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点和子孩子中, 判断谁的值更大</span></span><br><span class="line">        largest = arr[index] &lt; arr[largest] ? largest : index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果相等, 说明此时已经满足了大根堆的条件, 可以跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (largest == index) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        swap(arr, index, largest);</span><br><span class="line">        index = largest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="具体应用"   >
          <a href="#具体应用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#具体应用"></a> 具体应用</h3>
      
<p>若用户要求修改堆结构中<strong>任意一个位置</strong>的元素的值，并要求修改后的数字仍然满足大根堆，则只需要判断修改后的元素是比原先大还是小：</p>
<ul>
<li>若修改后的元素比原先大，则进行 <strong>heapInsert</strong> 操作，将当前元素向上交换到合适的父节点位置</li>
<li>若修改后的元素比原先小，则进行 <strong>heapify</strong> 操作，将当前元素向下交换到合适的子节点位置</li>
</ul>
<hr />
<p>小根堆在 Java 中就是<strong>优先级队列</strong>默认的实现方式： <code>PriorityQueue&lt;Interger&gt;</code>，其两个方法：</p>
<ul>
<li><code>add()</code> ：本质上就是 heapInsert 操作，将一个数字添加到已存在的小根堆中</li>
<li><code>poll()</code>：本质上就是 heapify 操作，首先弹出当前小根堆的根结点元素，并令剩余数字依旧保持小根堆结构。</li>
</ul>
<p>但是其不能支持“修改堆中某个结构后以很轻的代价重新调整堆的结构”，只支持“弹出堆的根结点元素后重新调整堆的结构”，若想实现这些个性化的功能还需要自己定义堆结构。</p>
<blockquote>
<p>其扩容机制是当 heapSize 快满时，将 heapSize * 2。这个操作的时间复杂度在每个元素平摊下来后其实很低</p>
</blockquote>
<hr />

        <h3 id="堆排序思想"   >
          <a href="#堆排序思想" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#堆排序思想"></a> 堆排序思想</h3>
      
<p>堆排序的思想是：利用大根堆第一个元素最大的特性，令数组不断地组成大根堆，从而每次形成的大根堆里的第一个元素都是当前的最大值。</p>
<p>算法流程：</p>
<ul>
<li>首先令当前数组的所有数字符合大根堆顺序（令一个数组变成大根堆的方式见后文，本质上就是不断做 heapInsert）</li>
<li>当前大根堆的根节点就是最大的元素，将其与数组的最后一个元素交换位置，此时即得到了整个数组最大的元素</li>
<li>接着将 heapSize–（因为已经有一个数字排好了序，heapSize 将减小），并对交换后的元素进行一次 heapify 操作：不断向下遍历子节点，直到与合适的位置数字进行交换。heapify 后，新的堆就又符合了大根堆结构</li>
<li>再取当前大根堆的根节点上的元素，它就是原数组第二大的数字，将其与大根堆结构中最后一个节点的元素进行交换。此时原数组中最后两个位置的元素就是最大和第二大的元素</li>
<li>再次 heapSize-- ，并对交换后的元素再进行一次 heapify 操作，新的大根堆的根结点的元素就是第三大的元素，将其与大根堆结构中最后一个节点的元素进行交换。</li>
<li>重复上述过程，直到大根堆的 heapSize == 0，此时即完成了排序</li>
</ul>
<p>堆排序的复杂度：</p>
<ul>
<li>时间复杂度是 O(N * logN)</li>
<li>额外空间复杂度 O(1)，只需要 swap 交换操作，不用开辟额外空间</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 先将数组变为大根堆</span></span><br><span class="line">    <span class="comment">// 1.1 方式一: 依次将每个数字添加到堆结构中, 堆大小从0开始, 依次将新数字 heapInsert 进堆中</span></span><br><span class="line">    <span class="comment">// 编码思路是, 从前往后将每个节点进行 heapInsert</span></span><br><span class="line">    <span class="comment">// 其时间复杂度为 O(N*logN)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;  <span class="comment">// O(N)</span></span><br><span class="line">        heapInsert(arr, i);                   <span class="comment">// O(logN)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 方式二: 从下向上, 先将每个子堆变为大根堆, 然后再将其父节点纳入再进行 heapify</span></span><br><span class="line">    <span class="comment">// 编码思路是, 从后往前将每个节点进行 heapify</span></span><br><span class="line">    <span class="comment">// 该方法速度更快, 其时间复杂度为 O(N)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 每次将大根堆的根结点元素与最后一个元素交换</span></span><br><span class="line">    <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123;                  <span class="comment">// O(N)</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, heapSize-<span class="number">1</span>);             <span class="comment">// O(1)</span></span><br><span class="line">        <span class="comment">// 注意 heapSize 先减一再进入 heapify</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, --heapSize);          <span class="comment">// O(logN)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整体时间复杂度为 O(N*logN)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向上遍历当前节点的父节点,直到满足条件: 父节点的值 &gt; 当前节点的值</span></span><br><span class="line">    <span class="keyword">while</span> (arr[(index - <span class="number">1</span>) / <span class="number">2</span>] &lt; arr[index]) &#123;</span><br><span class="line">        swap(arr, (index - <span class="number">1</span>) / <span class="number">2</span>, index);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// index 记得变为父节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heapSize 用于表示逻辑上的堆的大小, 其和数组的大小没关系</span></span><br><span class="line"><span class="comment">// 该方法的作用是, 在给定堆结构中, 当某个位置的元素被弹出,替换成了其他数字后</span></span><br><span class="line"><span class="comment">// 要保证新的数组仍然保持堆结构, 那么就需要从这个位置开始向下遍历</span></span><br><span class="line"><span class="comment">// 交换其子节点中最大的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heapSize &gt; arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>*index+<span class="number">1</span> &lt; heapSize) &#123;</span><br><span class="line">        <span class="comment">// 两个孩子中, 判断谁的值更大</span></span><br><span class="line">        <span class="keyword">int</span> largest = (<span class="number">2</span>*index+<span class="number">2</span> &lt; heapSize) &amp;&amp; arr[<span class="number">2</span>*index+<span class="number">1</span>] &lt; arr[<span class="number">2</span>*index+<span class="number">2</span>]</span><br><span class="line">            ? <span class="number">2</span>*index+<span class="number">2</span> : <span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点和子孩子中, 判断谁的值更大</span></span><br><span class="line">        largest = arr[index] &lt; arr[largest] ? largest : index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果相等, 说明此时已经满足了大根堆的条件, 可以跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (largest == index) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        swap(arr, index, largest);</span><br><span class="line">        index = largest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[a] = arr[a] ^ arr[b];</span><br><span class="line">    arr[b] = arr[a] ^ arr[b];</span><br><span class="line">    arr[a] = arr[a] ^ arr[b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<hr />
<p>补充：想让一组数字变成一个大根堆/小根堆结构，上文中的编码方式时间复杂度是 O(N * logN)。然后还有一种更快的方式令一个数组变为大根堆/小根堆结构，其时间复杂度为 O(N)</p>
<ul>
<li>方式一：依次将每个数字添加到堆结构中，堆大小从0开始，依次将新数字 heapInsert 进堆中。当遍历完成后，即得到了大根堆，但这种方法的时间复杂度为 O(N * logN)</li>
<li>方式二：从下向上，先将每个子堆变为大根堆，然后再将其父节点纳入再进行 heapify。其时间复杂度为 O(N)（其时间复杂度的估计方法使用了错位相减法）</li>
</ul>
<p>方式二就是一种逆向思维，反过来从后往前遍历数组，令其往后的子树符合大根堆，然后再向前遍历，不断扩大子树的大小，令新的子树也符合大根堆。这样的操作时间复杂度更低，因为整个树上一半的节点都是叶子节点，根本不需要做交换：</p>
<p><img src="/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211004203745738-1633921354763.png" alt="image-20211004203745738" /></p>
<p><img src="/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211004203713788-1633921354763.png" alt="image-20211004203713788" /></p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 先将数组变为大根堆</span></span><br><span class="line"><span class="comment">// 1.1 方式一: 依次将每个数字添加到堆结构中, 堆大小从0开始, 依次将新数字 heapInsert 进堆中</span></span><br><span class="line"><span class="comment">// 编码思路是, 从前往后将每个节点进行 heapInsert</span></span><br><span class="line"><span class="comment">// 其时间复杂度为 O(N*logN)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;  <span class="comment">// O(N)</span></span><br><span class="line">    heapInsert(arr, i);                   <span class="comment">// O(logN)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2 方式二: 从下向上, 先将每个子堆变为大根堆, 然后再将其父节点纳入再进行 heapify</span></span><br><span class="line"><span class="comment">// 编码思路是, 从后往前将每个节点进行 heapify</span></span><br><span class="line"><span class="comment">// 该方法速度更快, 其时间复杂度为 O(N)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    heapify(arr, i, arr.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<hr />

        <h3 id="堆排序的扩展几乎有序的数组"   >
          <a href="#堆排序的扩展几乎有序的数组" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#堆排序的扩展几乎有序的数组"></a> 堆排序的扩展：几乎有序的数组</h3>
      
<p><img src="/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211004204032904-1633921378395.png" alt="image-20211004204032904" /></p>
<p><strong>解题思路</strong>：这个移动距离不超过 k 非常重要，这意味着我们可以在 k 范围内组成一个小根堆，这个小根堆的第一个元素就是这个范围内的最小值，依次移动指针，将每个子 k 区域内的数组组成小根堆，即可不断得到当前范围内的最小值，从而完成排序。</p>
<p>具体流程：</p>
<ul>
<li>首先取数组的前 k 个数字，组成小根堆（复杂度为 O(k * logk)，或用更快的方式可以达到 O(k)），然后将小根堆第一个位置的元素弹出，放到原数组的0位置，这个数就是整个数组的最小值（因为这道题限制了每个数字的移动距离不会超过 k）</li>
<li>接着向后移动1个位置，再取 k+1 位置上的数 arr[k+1] 与上一步剩下的 k-1 个元素一起再组成新的小根堆后，再取出最新小根堆里的第一个元素（此元素就是整个数组第二小的数）</li>
</ul>
<p>重复上述过程，直到整个数组被遍历完，即可得到排序后的数组。此过程的时间复杂度为 O(N * logk)，如果这个k很小，那么这个算法的时间复杂度就比较接近 O(N)</p>
<p>具体实现既可以通过自己定义堆结构，又可以直接使用 Java 提供的优先级队列：<code>PriorityQueue&lt;Interger&gt;</code>，其底层就是一个小根堆结构。</p>
<hr />
<p>小根堆在 Java 中就是<strong>优先级队列</strong>默认的实现方式： <code>PriorityQueue&lt;Interger&gt;</code>，其两个方法：</p>
<ul>
<li><code>add()</code> ：本质上就是 heapInsert 操作，将一个数字添加到已存在的小根堆中</li>
<li><code>poll()</code>：本质上就是 heapify 操作，首先弹出当前小根堆的根结点元素，并令剩余数字依旧保持小根堆结构。</li>
</ul>
<p>但是其不能支持“修改堆中某个结构后以很轻的代价重新调整堆的结构”，只支持“弹出堆的根结点元素后重新调整堆的结构”，若想实现这些个性化的功能还需要自己定义堆结构。</p>
<blockquote>
<p>其扩容机制是当 heapSize 快满时，将 heapSize * 2。这个操作的时间复杂度在每个元素平摊下来后其实很低</p>
</blockquote>
<hr />
<p>使用 <code>PriorityQueue&lt;Interger&gt;</code> 解该题：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortArrayDistanceLessK</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortArrayDistanceLessK</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认为小根堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0 ~ k-1 位置上的数组成小根堆(这里要取k和arr.length的最小值)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(k, arr.length); i++) &#123;</span><br><span class="line">            heap.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; arr.length - k; i++) &#123;</span><br><span class="line">            arr[i] = heap.poll();</span><br><span class="line">            <span class="comment">// 注意索引值不是 i+k+1</span></span><br><span class="line">            <span class="comment">// 因为整个小根堆的heapSize==k, 所以 &quot;当前根节点索引+k&quot; 就是小根堆的下一个索引值</span></span><br><span class="line">            heap.add(arr[i + k]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上述遍历完毕后, 将大根堆里剩余的数挨个弹出放到数组的最后k个位置</span></span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            arr[i++] = heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        SortArrayDistanceLessK.sortArrayDistanceLessK(arr, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="桶排序"   >
          <a href="#桶排序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#桶排序"></a> 桶排序</h2>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?p=4" >https://www.bilibili.com/video/BV13g41157hK?p=4</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>词频表 count[10] 中统计某一位小于等于当前数字的个数有多少个，例如下图中，count 数组中 count[2] = 4，代表原数组中个位数小于等于2的数字有4个（21，11，52，62）</p>
<p><img src="/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211005184227223-1633921396069.png" alt="image-20211005184227223" /></p>
<p>这个数组存在的意义是，可以通过其索引上的数字为原数组某一位进行<strong>分片</strong>，例如按照个位数字的大小按顺序排列，例如下图中的辅助数组 help[] 就是使用 count 数组将原数组按照个位数字的大小进行分片排序，让个位数字为1的在一起，为2的在一起……：</p>
<p><img src="/images/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211005184133152-1633921396069.png" alt="image-20211005184133152" /></p>
<p>遍历流程：</p>
<p><strong>从右往左</strong>遍历原数组，将遇到的每一个数字放到辅助数组的 <code>help[count[i]-1]</code>  位置，并且将 <code>count[i]--</code> 。</p>
<hr />
<p>结合上面两幅图，举例说明这样做的原因：</p>
<p>例如先按照<strong>个位</strong>进行分片排序：<strong>从右往左</strong>遍历到62时，当前数字62肯定是“某一位（个位）上数值相同的数字”中排序最靠后的，因此就将其放到 help 数组中“这一位（个位）所处的分片区域”的最靠后位置  <code>help[count[i]-1]</code> ，即 <code>help[3]</code>。</p>
<p>因为根据 count 数组可知，个位数字小于等于2的数字一共有4个，那么当前从右往左遍历到的数字62就应该是这四个数里的最后一个，即 <code>help[count[2]-1]</code>。</p>
<p>记得接下来要将  <code>count[2]--</code> ，这样再往左遍历到下一个元素52时，这个排序更靠前一些的数字52就会放到62的前面  <code>help[count[2]-1] = help[2]</code>。</p>
<hr />
<p>这样做的目的是，让先入桶的先出桶，达到队列的效果</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://yuyun-zhao.github.io">yuyun zhao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://yuyun-zhao.github.io/2021/11/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">http://yuyun-zhao.github.io/2021/11/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.github.io/tags/%E7%AE%97%E6%B3%95/">算法</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/11/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">【算法】二分查找法</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/11/09/%E3%80%90Docker%E3%80%91Docker%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/"><span class="paginator-prev__text">【Docker】Docker 配置实战案例</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">
           排序算法总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">
           选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">
           冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">
           插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">
           归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%89%A9%E5%B1%95%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98%E5%92%8C%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98"><span class="toc-text">
           归并排序的扩展：小和问题和逆序对问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">
           快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%89%8D%E5%A5%8F%E4%B8%80%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98"><span class="toc-text">
           快速排序前奏一：荷兰国旗问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%89%8D%E5%A5%8F%E4%BA%8C%E6%95%B0%E7%BB%84%E5%A5%87%E5%81%B6%E5%88%86%E7%A6%BB"><span class="toc-text">
           快速排序前奏二：数组奇偶分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="toc-text">
           快速排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%89%88%E6%9C%AC%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F"><span class="toc-text">
           三个版本分区方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-text">
           算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%8F%96%E6%95%B0%E5%AD%97-num-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">
           关于取数字 num 的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">
           快速排序的空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98"><span class="toc-text">
           快速排序的扩展问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE"><span class="toc-text">
           快速排序的常见题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0"><span class="toc-text">
           最小的 K 个数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">
           堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%BB%93%E6%9E%84"><span class="toc-text">
           堆结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E6%A0%B9%E5%A0%86"><span class="toc-text">
           大&#x2F;小根堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8"><span class="toc-text">
           具体应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="toc-text">
           堆排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%A0%E4%B9%8E%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-text">
           堆排序的扩展：几乎有序的数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">
           桶排序</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/author.png" alt="avatar"></div><p class="sidebar-ov-author__text">no code no life</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YUYUN-ZHAO" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="zyy1024462136" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1024462136" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:im.yuyunzhao@gmail.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gmail</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">123</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">36</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">36</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>yuyun zhao</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.xml"></script></body></html>