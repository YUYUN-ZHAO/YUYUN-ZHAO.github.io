<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="Tomcat 简介        Tomcat 是由 Apache 软件基金会属下Jakarta项目开发的Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全局管理和Tomcat阀等。由于Tomcat本身也内含">
<meta property="og:type" content="article">
<meta property="og:title" content="【Tomcat】Tomcat">
<meta property="og:url" content="http://yuyun-zhao.github.io/2021/04/29/%E3%80%90Tomcat%E3%80%91Tomcat/index.html">
<meta property="og:site_name" content="yuyun zhao&#39;s blog">
<meta property="og:description" content="Tomcat 简介        Tomcat 是由 Apache 软件基金会属下Jakarta项目开发的Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全局管理和Tomcat阀等。由于Tomcat本身也内含">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130103856954.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130104501350.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130105249865.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130111057831.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/20180108204347710">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/20180108194817763">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130140058239.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130141231762.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130142639010.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/20180108205854139">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130185854077.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130190809580.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130190849670.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/20180108201901382">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130194623089.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/74a1291e954d388235d758067b274429.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130194711901.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220202212159083.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220202212240707.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220202212331950.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/20180116093931129">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130202122132.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130203247456.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130203426222.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130204002258.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130204451489.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130232015897.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130232455469.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130103737751.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130231727802.png">
<meta property="article:published_time" content="2021-04-29T02:35:00.000Z">
<meta property="article:modified_time" content="2022-02-22T12:56:12.830Z">
<meta property="article:author" content="yuyun zhao">
<meta property="article:tag" content="Tomcat">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130103856954.png"><title>【Tomcat】Tomcat | yuyun zhao's blog</title><link ref="canonical" href="http://yuyun-zhao.github.io/2021/04/29/%E3%80%90Tomcat%E3%80%91Tomcat/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">文章</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">yuyun zhao's blog</div><div class="header-banner-info__subtitle">no code no life</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">【Tomcat】Tomcat</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-04-29</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-02-22</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">10k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">65分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h2 id="tomcat-简介"   >
          <a href="#tomcat-简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tomcat-简介"></a> Tomcat 简介</h2>
      
<p>Tomcat 是由 Apache 软件基金会属下<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Jakarta%E9%A1%B9%E7%9B%AE" >Jakarta项目</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>开发的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Servlet" >Servlet</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>容器，按照<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Sun_Microsystems" >Sun Microsystems</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>提供的技术规范，实现了对<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Servlet" >Servlet</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>和<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JavaServer_Page" >JavaServer Page</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JSP" >JSP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全局管理和Tomcat阀等。由于Tomcat本身也内含了<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTP" >HTTP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8" >服务器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，因此也可以视作单独的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8" >Web服务器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。Tomcat提供了一个Jasper<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E5%99%A8" >编译器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>用以将JSP编译成对应的Servlet。</p>
<p><strong>Servlet接口和Servlet容器这一整套规范叫作Servlet规范</strong>。Tomcat按照Servlet规范的要求<strong>实现了Servlet容器</strong>，同时它们也具有HTTP服务器的功能。</p>
<p><strong>Tomcat 本质上是一个 Servlet 容器</strong>。开发人员只需要实现 Servlet 接口并注入到 Servlet 容器中，剩下的跳转响应都交给 Tomcat 实现。*</p>

        <h3 id="历史"   >
          <a href="#历史" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#历史"></a> 历史</h3>
      
<p>Tomcat 最初由Sun公司的软件架构师 James Duncan Davidson 开发，名称为 JavaWebServer</p>
<ul>
<li>1999年 ，在 Davidson 的帮助下，该项目于1999年于 apache 软件基金会旗下的 JServ 项目合并，并发布第一个版本（3.x），即是现在的Tomcat，该版本实现了 Servlet2.2 和 JSP 1.1 规范</li>
<li>2001年，Tomcat 发布了4.0版本，作为里程碑式的版本，Tomcat 完全重新设计了 其架构，并实现了 Servlet 2.3 和 JSP1.2规范</li>
<li>目前 Tomcat 已经更新到 9.0.x 版本，但是目前企业中的Tomcat服务器， 主流版本还是 7.x 和 8.x 版本</li>
</ul>

        <h3 id="常见-web-服务器软件"   >
          <a href="#常见-web-服务器软件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#常见-web-服务器软件"></a> 常见 web 服务器软件</h3>
      
<ul>
<li>webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li>
<li>webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li>
<li>JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li>
<li>Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范 servlet/jsp。开源的，免费的</li>
</ul>
<span id="more"></span>

        <h2 id="tomcat-架构"   >
          <a href="#tomcat-架构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tomcat-架构"></a> Tomcat 架构</h2>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1dJ411N7Um?p=1" >https://www.bilibili.com/video/BV1dJ411N7Um?p=1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h3 id="http-工作原理"   >
          <a href="#http-工作原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#http-工作原理"></a> HTTP 工作原理</h3>
      
<p>HTTP 协议是浏览器与服务器之间的数据传送协议。作为<strong>应用层协议</strong>，HTTP 是基于 TCP/IP 协议来传递数据的（HTML文件、图片、查询结果等），HTTP 协议<strong>不涉及数据包（Packet）传输</strong>，主要规定了客户端和服务器之间的<strong>通信格式</strong>。</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130103856954.png" alt="image-20220130103856954" /></p>
<p>具体流程：</p>
<ul>
<li>用户通过浏览器进行了一个操作，比如输入网址并回车，或者是点击链接，接着浏览器获取了这个事件。</li>
<li>浏览器向服务端发出TCP连接请求。</li>
<li>服务程序接受浏览器的连接请求，并经过TCP三次握手建立连接。</li>
<li>浏览器将请求数据打包成一个HTTP协议格式的数据包。</li>
<li>浏览器将该数据包推入网络，数据包经过网络传输，最终达到端服务程序。</li>
<li>服务端程序拿到这个数据包后，同样以HTTP协议格式解包，获取到客户端的意图。</li>
<li>得知客户端意图后进行处理，比如提供静态文件或者调用服务端程序获得动态结果。</li>
<li>服务器将响应结果（可能是HTML或者图片等）按照HTTP协议格式打包。</li>
<li>服务器将响应数据包推入网络，数据包经过网络传输最终达到到浏览器。</li>
<li>浏览器拿到数据包后，以HTTP协议的格式解包，然后解析数据，假设这里的数据是 HTML。</li>
<li>浏览器将HTML文件展示在页面上。</li>
</ul>
<p>那我们想要探究的Tomcat作为一个HTTP服务器，在这个过程中都做了些什么事情呢？主要是<strong>接收连接</strong>、<strong>解析请求数据</strong>、<strong>处理请求</strong>和<strong>发送响应</strong>这几个步骤。</p>

        <h3 id="http-服务器请求处理"   >
          <a href="#http-服务器请求处理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#http-服务器请求处理"></a> HTTP 服务器请求处理</h3>
      
<p>浏览器发给服务端的是一个HTTP格式的请求，HTTP服务器收到这个请求后，需要调用服务端程序来处理，所谓的服务端程序就是你写的Java类，一般来说不同的请求需要由不同的Java类来处理。</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130104501350.png" alt="image-20220130104501350" /></p>
<ul>
<li>图1，表示HTTP服务器直接调用具体业务类，它们是紧耦合的。</li>
<li>图2，HTTP服务器不直接调用业务类，而是把请求交给<strong>Servlet 容器</strong>来处理，容器通过 Servlet 接口调用业务类。因此Servlet接口和Servlet容器的出现，达到了HTTP服务器与业务类解耦的目的。</li>
</ul>
<p><strong>Servlet接口和Servlet容器这一整套规范叫作Servlet规范</strong>。 <strong>Tomcat按照Servlet规范的要求实现了Servlet容器，同时它们也具有HTTP服务器的功能</strong>。作为Java程序员，如果我们要实现新的业务功能，只需要实现一个Servlet，并把它注册到Tomcat（Servlet容器）中，剩下的事情就由Tomcat帮我们处理了。</p>

        <h3 id="servlet-容器工作流程"   >
          <a href="#servlet-容器工作流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#servlet-容器工作流程"></a> Servlet 容器工作流程</h3>
      
<p>为了解耦，<strong>HTTP服务器不直接调用Servlet，而是把请求交给Servlet容器来处理</strong>，那Servlet容器又是怎么工作的呢？</p>
<ul>
<li>当客户请求某个资源时，<strong>HTTP服务器</strong>会<strong>用一个<code>ServletRequest</code>对象把客户的请求信息封装起来</strong>，然后调用<strong>Servlet容器</strong>的<code>service</code>方法</li>
<li><strong>Servlet容器</strong>拿到请求后，根据请求的URL和Servlet的映射关系，找到相应的Servlet</li>
<li>如果Servlet还没有被加载，就用<strong>反射机制</strong>创建这个Servlet，并调用Servlet的<code>init</code>方法来完成初始化</li>
<li>接着调用Servlet的<code>service</code>方法来处理请求，把<code>ServletResponse</code>对象返回给HTTP服务器，HTTP服务器会把响应发送给客户端。</li>
</ul>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130105249865.png" alt="image-20220130105249865" /></p>
<blockquote>
<p>HTTP 服务器具体实现就是下面要介绍的 Connector，其负责将客户端发来的 HTTP 请求进行解析转换成 <code>ServletRequest</code> 对象。</p>
</blockquote>

        <h3 id="tomcat-整体架构"   >
          <a href="#tomcat-整体架构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tomcat-整体架构"></a> Tomcat 整体架构</h3>
      
<p>Tomcat 要实现两个核心功能：</p>
<ul>
<li>处理客户端发来的Socket连接，负责<strong>网络字节流</strong>与<strong>Request/Response对象</strong>之间的转化。</li>
<li>加载和管理Servlet，以及具体处理Request请求。</li>
</ul>
<p>因此Tomcat设计了两个核心组件<strong>连接器</strong>（Connector）和<strong>容器</strong>（Container）来分别做这两件事情。<strong>连接器负责对外交流</strong>，<strong>容器负责内部处理</strong>。</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130111057831.png" alt="image-20220130111057831" /></p>
<p>从图中可以看出，<strong>一个 Tomcat 服务器可以配置多个服务 Service</strong>（默认配置了一个名为 <code>&quot;Catalina&quot;</code> 的 Service）。每个 Service 中又包含了<strong>多个连接器 Connector</strong>和<strong>一个Servlet容器</strong>。</p>
<ul>
<li>多个连接器是为了实现支持<strong>多种 I/O 模型</strong>和<strong>应用层协议</strong>。</li>
<li>Servlet容器管理着所有Servlet实例对象。其内有一个引擎 Engine，且包含多个主机 Host 与多个 Context。每个 Context 代表一个 Web 应用，其内有许多的 Servlet 实例对象。</li>
</ul>
<p>其中，Tomcat 的 Connector 连接器框架为 <strong>Coyote</strong>。Servlet 容器为 <strong>Catalina 容器</strong>。</p>
<blockquote>
<p>Servlet 容器又可被称为 Catalina 容器、Container 容器</p>
</blockquote>
<p>单独的连接器或者容器都不能对外提供服务，需要把它们组装起来才能工作，组装后这个整体叫作Service组件。注意，Service本身没有做什么重要的事情，只是在连接器和容器外面多包了一层，把它们组装在一起。Tomcat内可能有多个Service，这样的设计也是出于灵活性的考虑。通过在Tomcat中配置多个Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。</p>
<p>Tomcat 的 Connector 连接器采用NIO中的<strong>多路复用模型</strong>。一个<code>Acceptor</code>负责监听所有Socket请求，然后每收到一个新的请求，就从线程池中占用一个线程执行后续代码（传递给 Adapter，再发送给 Container 容器）。<code>Acceptor</code> 继续监听其他请求，不会浪费时间执行响应代码（响应代码新开辟线程执行）</p>

        <h3 id="示例"   >
          <a href="#示例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/hancoder/article/details/118466983" >https://blog.csdn.net/hancoder/article/details/118466983</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>示例 1：多协议访问</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/20180108204347710" alt="img" /></p>
<p>示例 2：</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/20180108194817763" alt="img" /></p>
<p>其中，Server标签设置的端口号为8005，<code>shutdown=&quot;SHUTDOWN&quot;</code>，表示在8005端口监听 <code>SHUTDOWN</code> 命令，如果接收到了就会关闭Tomcat。一个Server有多个Service，Service左边的内容（Engine）都属于Container的，Service下边是Connector，负责监听TCP请求。</p>

        <h2 id="连接器框架-coyote"   >
          <a href="#连接器框架-coyote" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#连接器框架-coyote"></a> 连接器框架 Coyote</h2>
      

        <h3 id="coyote-简介"   >
          <a href="#coyote-简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#coyote-简介"></a> Coyote 简介</h3>
      
<p>Coyote是Tomcat的Connector连接器框架的名称，是Tomcat服务器提供的<strong>供客户端访问的外部接口</strong>。客户端通过Coyote与服务器建立连接、发送请求并接受响应。</p>
<p>Coyote封装了底层的网络通信（Socket 请求及响应处理），为Catalina容器（Servlet容器/Cotainer容器）提供了统一的接口，<strong>使Catalina容器与具体的请求协议及IO操作方式完全解耦</strong>。</p>
<ul>
<li>Coyote将Socket输入转换封装为<code>Request</code>对象，交由Catalina容器进行处理，处理请求完成后，Catalina容器通过Coyote提供的<code>Response</code>对象将结果写入输出流</li>
<li>Catalina容器只负责接收Coyote包装处理后的<code>Request</code>对象，对其进行业务处理后再将响应结果<code>Response</code>对象传给Coyote，Coyote在进行解析后再返回HTTP请求给客户端</li>
</ul>
<blockquote>
<p>Servlet 容器又可被称为 Catalina 容器、Container 容器</p>
</blockquote>
<p>Coyote作为独立的模块，<strong>只负责具体协议和IO的相关操作</strong>，与Servlet规范实现没有直接关系，因此即便是<code>Request</code>和<code>Response</code>对象也并未实现Servlet规范对应的接口，而是在Catalina容器中将他们进一步封装为<code>ServletRequest</code>和<code>ServletResponse</code>。</p>
<p>示意图：</p>
<blockquote>
<p>图中的 Catalina 就是 Container 容器</p>
</blockquote>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130140058239.png" alt="image-20220130140058239" /></p>
<blockquote>
<p>Request -&gt; ServletRequest 的转换是由 Coyote 框架的适配器组件 Adapter 完成的（适配器模式）。</p>
</blockquote>

        <h3 id="io-模型与协议"   >
          <a href="#io-模型与协议" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#io-模型与协议"></a> IO 模型与协议</h3>
      
<p>在Coyote中，Tomcat支持多种I/O模型和应用层协议，具体包含了以下IO模型和应用层协议：</p>
<blockquote>
<p>自 8.5/9.0 版本起，Tomcat 移除了对BIO的支持改为使用NIO</p>
</blockquote>
<p>IO 模型（传输层）：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>IO 模型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NIO</td>
<td>非阻塞IO，采用JAVA NIO实现</td>
</tr>
<tr>
<td>NIO2</td>
<td><strong>异步</strong>IO，采用JDK7最新的NIO2类库实现</td>
</tr>
<tr>
<td>APR</td>
<td>采用Apache可移植运行库实现，是C/C++编写的本地库，如果选择此方案需要单独安装APR库</td>
</tr>
</tbody>
</table></div>
<p>Tomcat 支持的<strong>应用层协议</strong>：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>应用层协议</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP1.1</td>
<td>大部分web应用采用的协议</td>
</tr>
<tr>
<td>HTTP2</td>
<td>HTTP2大幅度提升了web性能，自tomcat 9版本以后支持</td>
</tr>
<tr>
<td>AJP</td>
<td>用于和Web服务器(Apache)集成，以实现对静态资源的优化和集群部署，当前支持AJP/1.3</td>
</tr>
</tbody>
</table></div>
<p>两种协议分层：</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130141231762.png" alt="image-20220130141231762" /></p>
<p>在 8.0 之前，Tomcat 默认采用的I/O方式为BIO，之后改为NIO。无论 NIO、NIO2 还是 APR， 在性能方面均优于以往的BIO。如果采用APR，甚至可以达到 Apache HTTP Server 的影响性能。</p>

        <h3 id="连接器组件"   >
          <a href="#连接器组件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#连接器组件"></a> 连接器组件</h3>
      
<p>Coyote中的连接组件分为四部分：</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130142639010.png" alt="image-20220130142639010" /></p>

        <h4 id="endpoint"   >
          <a href="#endpoint" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#endpoint"></a> EndPoint</h4>
      
<p><code>EndPoint</code>是Coyote的<strong>通信端点</strong>，即<strong>通信监听的接口</strong>，是具体Socket接收和发送处理器，是对传输层的抽象，因此<code>EndPoint</code>是用来实现TCP/IP协议的。</p>
<p>Tomcat 并没有<code>EndPoint</code>接口，而是提供了一个抽象类<code>AbstractEndpoint</code> ，里面定义了两个内部类：<code>Acceptor</code>和<code>SocketProcessor</code>。</p>
<ul>
<li><code>Acceptor</code>用于监听Socket连接请求。</li>
<li><code>SocketProcessor</code>用于处理接收到的Socket请求，它实现<code>Runnable</code>接口，在<code>run()</code>方法里调用协议处理组件<code>Processor</code>进行处理。为了提高处理能力，<code>SocketProcessor</code>被提交到线程池来执行。而这个线程池叫作执行器（<code>Executor</code>)。</li>
</ul>
<p>该模式就类似于NIO中的多路复用模型。一个<code>Acceptor</code>负责监听所有Socket请求，然后每收到一个新的请求，就从线程池中占用一个线程执行后续代码（传递给 Adapter，再发送给 Container 容器）。<code>Acceptor</code> 继续监听其他请求，不会浪费时间执行响应代码（响应代码新开辟线程执行）</p>

        <h4 id="processor"   >
          <a href="#processor" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#processor"></a> Processor</h4>
      
<p><code>Processor</code>是HTTP协议的<strong>处理接口</strong> ，<strong>如果说<code>EndPoint</code>是用来实现TCP/IP协议的，那么<code>Processor</code>用来实现HTTP协议</strong>，<code>Processor</code>接收来自<code>EndPoint</code>的Socket，读取字节流解析成Tomcat <code>Request</code>和<code>Response</code>对象，并通过<code>Adapter</code>将其提交到容器处理，<code>Processor</code>是对<strong>应用层</strong>协议的抽象。</p>

        <h4 id="protocolhandler"   >
          <a href="#protocolhandler" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#protocolhandler"></a> ProtocolHandler</h4>
      
<p><code>ProtocolHandler</code>是Coyote协议接口， 通过<code>Endpoint</code>和<code>Processor</code>，实现针对具体协议的处理能力。Tomcat 按照协议和I/O 提供了6个实现类 ： <code>AjpNioProtocol</code>，<code>AjpAprProtocol</code>， <code>AjpNio2Protocol</code>，<code>Http11NioProtocol</code>，<code>Http11Nio2Protocol</code>，<code>Http11AprProtocol</code>。我们在配置<code>tomcat/conf/server.xml</code> 时，至少要指定具体的<code>ProtocolHandler</code>，当然也可以指定协议名称。例如： HTTP/1.1。如果安装了APR，那么将使用<code>Http11AprProtocol</code>，否则使用<code>Http11NioProtocol</code>。</p>

        <h4 id="adapter"   >
          <a href="#adapter" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#adapter"></a> Adapter</h4>
      
<p>由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat定义了自己的<code>Request</code>类来“存放”这些请求信息。<code>ProtocolHandler</code>接口负责解析请求并生成Tomcat <code>Request</code>类。但是这个<code>Request</code>对象不是标准的<code>ServletRequest</code>，也就意味着，不能用Tomcat Request作为参数来调用容器。</p>
<p>Tomcat设计者的解决方案是引入<code>Adapter</code>，这是<strong>适配器模式</strong>的经典运用，连接器调用<code>Adapter</code>的<code>Sevice()</code>方法，传入的是Tomcat <code>Request</code>对象，<code>Adapter</code>负责将Tomcat <code>Request</code>转成<code>ServletRequest</code>，再调用容器的<code>Service</code>方法。</p>

        <h4 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
      
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/20180108205854139" alt="img" /></p>
<p>Connector就是使用<code>ProtocolHandler</code>（协议处理器）来处理请求的，不同的<code>ProtocolHandler</code>代表不同的连接类型，比如：<code>Http11Protocol</code>使用的是普通<code>Socket</code>来连接的，<code>Http11NioProtocol</code>使用的是<code>NioSocket</code>来连接的。</p>
<p>其中<code>ProtocolHandler</code>由包含了三个部件：<code>Endpoint</code>、<code>Processor</code>、<code>Adapter</code>。</p>
<ul>
<li><code>Endpoint</code> 用来处理底层Socket的网络连接，因此<code>Endpoint</code>是用来实现<code>TCP/IP</code>协议的</li>
<li><code>Processor</code> 用于将<code>Endpoint</code>接收到的Socket封装成<code>Request</code>。<code>Processor</code>是用来实现<code>HTTP</code>协议的</li>
<li><code>Adapter</code> 用于将<code>Request</code>交给Container进行具体的处理（将请求适配到Servlet容器）。</li>
</ul>
<p>此外<code>Endpoint</code>的抽象实现<code>AbstractEndpoint</code>里面定义的<code>Acceptor</code>和<code>AsyncTimeout</code>两个内部类和一个<code>Handler</code>接口：</p>
<ul>
<li><code>Acceptor</code>用于监听请求</li>
<li><code>AsyncTimeout</code>用于检查异步Request的超时</li>
<li><code>Handler</code>用于处理接收到的Socket，在内部调用<code>Processor</code>进行处理。</li>
</ul>

        <h2 id="catalina-容器"   >
          <a href="#catalina-容器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#catalina-容器"></a> Catalina 容器</h2>
      
<blockquote>
<p>Catalina 容器即为 Container 容器、Servlet 容器。Tomcat 的配置文件中，默认 <code>Service</code> 的名称为 <code>&quot;Catalina&quot;</code>；默认 <code>Engine</code> 的名称也为 <code>&quot;Catalina&quot;</code>。说明 Catalina 只是对 Service 和 Container 容器起的一个别名罢了，不要弄混 Service 和 Container 容器的区别。</p>
</blockquote>
<p>Tomcat 本质上就是一款 Servlet 容器（Servlet 可以理解为一种规范）， 因此 Catalina 才是 Tomcat 的核心，其他模块都是为Catalina提供支撑的。 比如：通过Coyote模块提供通信连接，Jasper模块提供JSP引擎，Naming提供JNDI 服务，Juli提供日志服务。</p>
<img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130185854077.png" alt="image-20220130185854077" style="zoom:67%;" />
<p>Tomcat的主要组件结构如下：Server表示着整个服务器，Server下面有多个服务Service，每个服务都包含着多个连接器组件Connector（Coyote 实现）和一个容器组件Container。</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130190809580.png" alt="image-20220130190809580" /></p>
<p>Tomcat的Container中设计了4种容器，分别是<code>Engine</code>、<code>Host</code>、<code>Context</code>和<code>Wrapper</code>。这4种容器不是平行关系，而是父子关系。Tomcat通过一种分层的架构，使得Servlet容器具有很好的灵活性。</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130190849670.png" alt="image-20220130190849670" /></p>
<p>其中，</p>
<ul>
<li>一个Container中只有一个<code>Engine</code>，<code>Engine</code>是整个Container容器的引擎，<strong>用来管理多个站点</strong></li>
<li>一个<code>Engine</code>中可以有多个<code>Host</code>，<strong>一个<code>Host</code>代表一个站点</strong>（虚拟主机），<strong>一个<code>Host</code>里有可以包含多个<code>Context</code></strong></li>
<li><strong><code>Context</code>就是一个Web应用</strong>，对应着平时开发的一套程序，或者一个<code>WEB-INF</code>目录以及下面的<code>web.xml</code>文件；</li>
<li>一个Web应用中可以包含多个<code>Wrapper</code>，<code>Wrapper</code>就是Servlet。</li>
</ul>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/20180108201901382" alt="img" /></p>
<p>我们也可以再通过Tomcat的<code>server.xml</code>配置文件来加深对Tomcat容器的理解：</p>
<img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130194623089.png" alt="image-20220130194623089" style="zoom:67%;" />
<p>Tomcat采用了<strong>组件化</strong>的设计，它的构成组件都是可配置的，其中最外层的是Server，其他组件按照一定的格式要求配置在这个顶层容器中。</p>
<p>示例：</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/74a1291e954d388235d758067b274429.png" alt="img" /></p>
<p>Tomcat的容器是具有父子关系的，形成一个树形结构，Tomcat就是用<strong>组合模式</strong>来管理这些容器的。具体实现方法是，所有容器组件都实现了<code>Container</code>接口，因此<strong>组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性</strong>。这里单容器对象指的是最底层的<code>Wrapper</code>，组合容器对象指的是上面的<code>Context</code>、<code>Host</code>或者<code>Engine</code>。<code>Container</code>接口扩展了<code>LifeCycle</code>接口，<code>LifeCycle</code>接口用来统一管理各组件的<strong>生命周期</strong>。</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130194711901.png" alt="image-20220130194711901" /></p>
<hr />
<blockquote>
<p><strong>模板方法</strong>：将共有的方法抽取到父类当中。在子类里实现自己独特的方法内容。</p>
</blockquote>
<p>Tomcat 源码中使用了<strong>模板方法</strong>的设计模式。上图这些 <code>StandardXxx</code> 类都继承自 <code>LifecycleBase</code> 类。在调用该类的 <code>init()</code> 方法时将调用其定义的 <code>initInternals()</code> 方法（是 <code>abstract</code> 的）， 其子类都各自重写了自己的 <code>initInternals()</code>方法。</p>
<p><code>LifecycleBase</code> 类中：</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220202212159083.png" alt="image-20220202212159083" /></p>
<img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220202212240707.png" alt="image-20220202212240707" style="zoom: 67%;" />
<p>其子类都重写了该方法：</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220202212331950.png" alt="image-20220202212331950" /></p>
<hr />

        <h3 id="container-如何处理请求的"   >
          <a href="#container-如何处理请求的" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#container-如何处理请求的"></a> Container 如何处理请求的</h3>
      
<p>Container处理请求是使用<code>Pipeline-Valve管道</code>来处理的（Valve是阀门之意）</p>
<p>Pipeline-Valve是<strong>责任链模式</strong>，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。</p>
<p>但是，Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p>
<ul>
<li>每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做<code>BaseValve</code>，BaseValve是不可删除的；</li>
<li>在上层容器的管道的<code>BaseValve</code>中会调用下层容器的管道。</li>
</ul>
<p>我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：<code>StandardEngineValve</code>、<code>StandardHostValve</code>、<code>StandardContextValve</code>、<code>StandardWrapperValve</code>。</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/20180116093931129" alt="img" /></p>
<ul>
<li>Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的<code>最顶层容器</code>的Pipeline就是<code>EnginePipeline</code>（Engine的管道）</li>
<li>在<code>Engine</code>的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行<code>StandardEngineValve</code>，在StandardEngineValve中会调用Host管道，然后再依次执行<code>Host</code>的HostValve1、HostValve2等，最后在执行<code>StandardHostValve</code>，然后再依次调用<code>Context</code>的管道和<code>Wrapper</code>的管道，最后执行到<code>StandardWrapperValve</code></li>
<li>当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建<code>FilterChain</code>，并调用其<code>doFilter()</code>方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的<code>Filter</code>的<code>doFilter()</code>方法和<code>Servlet</code>的<code>service()</code>方法，这样请求就得到了处理</li>
<li>当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端</li>
</ul>

        <h2 id="tomcat-启动流程"   >
          <a href="#tomcat-启动流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tomcat-启动流程"></a> Tomcat 启动流程</h2>
      
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130202122132.png" alt="image-20220130202122132" /></p>
<ul>
<li>调用 bin/startup.bat（在linux 目录下 , 需要调用 bin/startup.sh）</li>
<li>在startup.bat 脚本中，调用了catalina.bat。</li>
<li>在catalina.bat 脚本文件中，调用了<code>BootStrap</code>中的<code>main</code>方法。</li>
<li>在<code>BootStrap</code>的<code>main</code>方法中调用了 <code>init</code> 方法 ，来创建<code>Catalina</code>及初始化类加载器。</li>
<li>在<code>BootStrap</code>的<code>main</code>方法中调用了 <code>load</code> 方法 ，在其中又调用了<code>Catalina</code>的<code>load</code>方法。</li>
<li>在<code>Catalina</code>的<code>load</code>方法中 , 需要进行一些初始化的工作, 并需要构造<code>Digester</code>对象，用于解析 XML。</li>
<li>然后在调用后续组件的初始化操作 。加载Tomcat的配置文件，初始化容器组件 ，监听对应的端口号， 准备接受客户端请求</li>
</ul>

        <h3 id="源码解析"   >
          <a href="#源码解析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#源码解析"></a> 源码解析</h3>
      
<p>由于所有的组件均存在初始化、启动、停止等生命周期方法，拥有生命周期管理的特性，所以Tomcat在设计的时候， 基于生命周期管理抽象成了一个接口 <code>Lifecycle</code> ，而组件 <code>Server</code>、<code>Service</code>、<code>Container</code>、<code>Executor</code>、<code>Connector</code> 组件， 都实现了一个生命周期的接口，从而具有了以下生命周期中核心方法：</p>
<ul>
<li><code>init()</code>：初始化组件</li>
<li><code>start()</code>：开始组件</li>
<li><code>stop()</code>：停止组件</li>
<li><code>destroy()</code>：销毁组件</li>
</ul>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130203247456.png" alt="image-20220130203247456" /></p>

        <h3 id="各组件实现"   >
          <a href="#各组件实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#各组件实现"></a> 各组件实现</h3>
      
<p>上面我们提到的<code>Server</code>、<code>Service</code>、<code>Engine</code>、<code>Host</code>、<code>Context</code>都是接口， 下图中罗列了这些接口的默认实现类。当前对于 <code>Endpoint</code>组件来说，在Tomcat中没有对应的<code>Endpoint</code>接口， 但是有一个抽象类 <code>AbstractEndpoint</code> ，其下有三个实现类： <code>NioEndpoint</code>、<code>Nio2Endpoint</code>、<code>AprEndpoint</code>，这三个实现类，分别对应于前面讲解连接器Coyote时， 提到的链接器支持的三种IO模型：NIO，NIO2，APR ，Tomcat8.5版本中，默认采用的是 <code>NioEndpoint</code>。</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130203426222.png" alt="image-20220130203426222" /></p>

        <h3 id="总结-2"   >
          <a href="#总结-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3>
      
<p>从启动流程图中以及源码中，我们可以看出Tomcat的启动过程非常准化，统一按照生命周期管理接口<code>Lifecycle</code>的定义进行启动。首先调<code>init()</code>方法进行组件的逐级初始化操作，然后再调用<code>start()</code>方法进行启动。</p>
<p>每一级的组件除了完成自身的处理外，还要负责调用子组件响应的生命周期管理方法，组件与组件之间是松耦合的，因为我们可以很容易的通过配置文件进行修改和替换</p>

        <h2 id="tomcat-请求处理流程"   >
          <a href="#tomcat-请求处理流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tomcat-请求处理流程"></a> Tomcat 请求处理流程</h2>
      
<p>Tomcat中维护了一个<code>Mapper</code>组件<strong>将用户请求的URL定位到一个Servlet</strong>，它的工作原理是：<code>Mapper</code>组件里保存了Web应用的配置信息，其实就是<strong>容器组件与访问路径的映射关系</strong>，比如<code>Host</code>容器里配置的域名、<code>Context</code>容器里的Web应用路径，以及<code>Wrapper</code>容器里Servlet映射的路径，这些配置信息就像是一个多层次的Map。</p>
<p>当一个请求到来时，<strong><code>Mapper</code>组件通过解析请求URL里的域名和路径，再到自己保存的Map里去查找，就能定位到一个Servlet</strong>。一个请求URL最后只会定位到一个<code>Wrapper</code>容器，也就是一个Servlet。下面的示意图中，就描述了当用户请求链接 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.itcast.cn/bbs/findAll" >http://www.itcast.cn/bbs/findAll</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 之后，是如何找到最终处理业务逻辑的Servlet：</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130204002258.png" alt="image-20220130204002258" /></p>
<p>上面这幅图只是描述了根据请求的URL如何查找到需要执行的Servlet，下面从Tomcat的设计架构层面来分析Tomcat了请求处理的过程：</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130204451489.png" alt="image-20220130204451489" /></p>
<ul>
<li><code>Connector</code>组件<code>Endpoint</code>中的<code>Acceptor</code>监听客户端套接字连接并接收Socket。将连接交给线程池<code>Executor</code>处理，开始执行请求响应任务。</li>
<li><code>Processor</code>组件读取消息报文，解析请求行、请求体、请求头，封装成<code>Request</code>对象。</li>
<li><code>CoyoteAdaptor</code>组件负责将<code>Connector</code>组件和<code>Engine</code>容器关联起来，把生成的<code>Request</code>对象转换成<code>ServletRequest</code>，后面还会把<code>ServletResponse</code>转成<code>HttpResponse</code>对象返回回去。</li>
<li><code>Mapper</code>组件根据请求行的URL值和请求头的Host值匹配由哪个Host容器、Context容器、Wrapper容器处理请求。</li>
<li><code>Engine</code>容器的管道开始处理，管道中包含若干个<code>Valve</code>、每个<code>Valve</code>负责部分处理逻辑。执行完<code>Valve</code>后会执行基础的<code>StandardEngineValve</code>，负责调用<code>Host</code>容器的Pipeline。</li>
<li><code>Host</code>容器的管道开始处理，流程类似，最后执行<code>Context</code>容器的Pipeline。</li>
<li><code>Context</code>容器的管道开始处理，流程类似，最后执行<code>Wrapper</code>容器的Pipeline。</li>
<li><code>Wrapper</code>容器的管道开始处理，流程类似，最后执行<code>Wrapper</code>容器对应的<code>Servlet</code>对象的处理方法。</li>
</ul>
<p>Tomcat中的各个组件各司其职，组件之间松耦合，确保了整体架构的可伸缩性和可拓展性, 在Tomcat中，每个Container组件采用<strong>责任链模式</strong>来完成具体的请求处理。<strong>在Tomcat中定义了Pipeline和 Valve两个接口，Pipeline用于构建责任链，后者代表责任链上的每个处理器</strong>。Pipeline中维护了一个基础的Valve，它始终位于Pipeline的末端（最后执行），封装了具体的请求处理和输出响应的过程。当然，我们也可以调用<code>addValve()</code>方法，为Pipeline添加其他的<code>Valve</code>，后添加的<code>Valve</code>位于基础的<code>Valve</code>之前，并按照添加顺序执行。Pipiline通过获得首个<code>Valve</code>来启动整合链条的执行。其实就是代码的同步执行。</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130232015897.png" alt="image-20220130232015897" /></p>

        <h3 id="总结-3"   >
          <a href="#总结-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h3>
      
<p><code>Mapper</code> 组件负责根据 <code>Connector</code> 传来的 URL 找到对应的 Servlet，然后由 <code>Container</code> 逐步传给对应的 <code>Wrapper</code>，在经过所有的过滤器 <code>Filter</code> 后再执行对应 Servlet 的 <code>service()</code> 方法（每个请求处理都交给一个新线程执行）。</p>

        <h2 id="jasper"   >
          <a href="#jasper" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jasper"></a> Jasper</h2>
      

        <h3 id="jasper-简介"   >
          <a href="#jasper-简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jasper-简介"></a> Jasper 简介</h3>
      
<p>对于基于JSP 的web应用来说，我们可以直接在JSP页面中编写 Java代码，添加第三方的 标签库，以及使用EL表达式。但是无论经过何种形式的处理，最终输出到客户端的都是 标准的HTML页面（包含js ，css…），并不包含任何的java相关的语法。也就是说，我们可以把jsp看做是一种运行在服务端的脚本。那么服务器是如何将 JSP页面转换为 HTML页面的呢？</p>
<p>Jasper模块是Tomcat的JSP<strong>核心引擎</strong>，我们知道<strong>JSP本质上是一个Servlet</strong>。Tomcat使用Jasper对JSP语法进行解析，生成Servlet并生成Class字节码，用户在进行访问jsp时，会访问Servlet，最终将访问的结果直接响应在浏览器端 。另外，在运行的时候，Jasper还会检测JSP文件是否被修改，如果修改，则会重新编译JSP文件。</p>
<blockquote>
<p>Tomcat 并不会在启动Web应用的时候自动编译JSP文件， 而是在客户端第一次请求时， 才编译需要访问的JSP文件。</p>
</blockquote>

        <h3 id="jsp-编译过程"   >
          <a href="#jsp-编译过程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jsp-编译过程"></a> JSP 编译过程</h3>
      
<p>Tomcat 在默认的<code>web.xml</code>中配置了一个<code>org.apache.jasper.servlet.JspServlet</code>，用于处理所有的<code>.jsp</code>或 <code>.jspx</code>结尾的请求，该Servlet实现即是运行时编译的入口。</p>
<p><code>JspServlet</code> 处理流程图：</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130232455469.png" alt="image-20220130232455469" /></p>
<p>JSP文件生成的对应Servlet对象：</p>
<ul>
<li>对于每一行的静态内容（HTML），调用 <code>out.write</code> 输出在浏览器上。</li>
<li>对于 <code>&lt;% ... %&gt;</code> 中的 Java 代码 ，将直接转换为 Servlet 类中的代码。 如果在 Java 代码中嵌入了静态文件， 则同样调用 <code>out.write</code> 输出。</li>
</ul>

        <h2 id="tomcat-配置文件"   >
          <a href="#tomcat-配置文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tomcat-配置文件"></a> Tomcat 配置文件</h2>
      

        <h3 id="tomcat-目录结构"   >
          <a href="#tomcat-目录结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tomcat-目录结构"></a> Tomcat 目录结构</h3>
      
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130103737751.png" alt="image-20220130103737751" /></p>
<p>Tomcat 服务器的配置主要集中于 <code>tomcat/conf</code> 下的 <code>catalina.policy</code>、<code>catalina.properties</code>、<code>context.xml</code>、<code>server.xml</code>、<code>tomcat-users.xml</code>、<code>web.xml</code> 文件。</p>
<p><code>server.xml</code>是Tomcat的核心配置，<code>tomcat-user.xml</code>主要是配置一些访问manager页面、域安全用户角色的信息，<code>web.xml</code>和webapp中的<code>web.xml</code>功能是一致的，控制一些访问Servlet的参数等等，但是全局的。</p>
<blockquote>
<p>更多详细介绍见博客 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_15758463/article/details/120287536?spm=1001.2014.3001.5501%E4%B8%8E%E6%96%87%E6%A1%A3" >https://blog.csdn.net/qq_15758463/article/details/120287536?spm=1001.2014.3001.5501与文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.yuyunzhao.cn/document/Tomcat.pdf" >https://blog.yuyunzhao.cn/document/Tomcat.pdf</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h3 id="serverxml"   >
          <a href="#serverxml" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#serverxml"></a> server.xml</h3>
      
<blockquote>
<p><code>server.xml</code>中，默认<code>Service</code>的名称为<code>&quot;Catalina&quot;</code>；默认<code>Engine</code>的名称也为<code>&quot;Catalina&quot;</code>s</p>
</blockquote>
<p><code>server.xml</code>是Tomcat的核心配置，包含了Tomcat的Servlet容器（Catalina）的所有配置。由于配置的属性特别多，我们在这里主要讲解其中的一部分重要配置。</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Listener</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">GlobaNamingResources</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">GlobaNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Executor</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Logger</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Realm</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Host</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Logger</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Context</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
<p>Server是<code>server.xml</code>的根元素，用于创建一个Server实例，默认使用的实现类是<code>org.apache.catalina.core.StandardServer。</code></p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&quot;8005&quot;</span> <span class="attr">shutdown</span>=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Listener</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">GlobaNamingResources</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">GlobaNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
<ul>
<li><code>port</code> : Tomcat监听的关闭服务器的端口。</li>
<li><code>shutdown</code>： 关闭服务器的指令字符串。</li>
</ul>
<p>Server内嵌的子元素为<code>Listener</code>、<code>GlobalNamingResources</code>、<code>Service</code>。</p>

        <h4 id="listener-标签"   >
          <a href="#listener-标签" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#listener-标签"></a> Listener 标签</h4>
      
<p>默认配置的5个<code>Listener</code>的含义：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!‐‐ 用于以日志形式输出服务器 、操作系统、JVM的版本信息 ‐‐&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.startup.VersionLoggerListener&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!‐‐ 用于加载（服务器启动） 和 销毁 （服务器停止） APR。 如果找不到APR库， 则会</span><br><span class="line">输出日志， 并不影响Tomcat启动 ‐‐&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.AprLifecycleListener&quot;</span> <span class="attr">SSLEngine</span>=<span class="string">&quot;on&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!‐‐ 用于避免JRE内存泄漏问题 ‐‐&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!‐‐ 用户加载（服务器启动） 和 销毁（服务器停止）全局命名服务 ‐‐&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!‐‐ 用于在Context停止时重建Executor池中的线程，以避免ThreadLocal 相关的内存泄漏 ‐‐&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot;</span> /&gt;</span></span><br></pre></td></tr></table></div></figure>

        <h4 id="globalnamingresources-标签"   >
          <a href="#globalnamingresources-标签" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#globalnamingresources-标签"></a> GlobalNamingResources 标签</h4>
      
<p><code>GlobalNamingResources</code> 中定义了全局命名服务：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Editable user database that can also be used by</span></span><br><span class="line"><span class="comment">UserDatabaseRealm to authenticate users</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">&quot;UserDatabase&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">&quot;org.apache.catalina.UserDatabase&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">&quot;User database that can be updated and saved&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">&quot;conf/tomcat-users.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

        <h4 id="service-标签"   >
          <a href="#service-标签" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#service-标签"></a> Service 标签</h4>
      
<p>Service元素用于创建 Service 实例，默认使用 <code>org.apache.catalina.core.StandardService</code>。默认情况下，Tomcat 仅指定了Service的名称，值为<code>&quot;Catalina&quot;</code>。Service可以内嵌的元素为： <code>Listener</code>、<code>Executor</code>、<code>Connector</code>、<code>Engine</code>。其中：</p>
<ul>
<li><code>Listener</code> 用于为Service添加<strong>生命周期</strong>监听器</li>
<li><code>Executor</code> 用于配置Service<strong>共享线程池</strong></li>
<li><code>Connector</code> 用于配置Service包含的连接器</li>
<li><code>Engine</code> 用于配置Service中连接器对应的Servlet容器<strong>引擎</strong>。</li>
</ul>
<p>一个Server服务器，可以包含多个Service服务。</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

        <h4 id="executor-标签"   >
          <a href="#executor-标签" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#executor-标签"></a> Executor 标签</h4>
      
<p>默认情况下，Service并未添加共享线程池配置，如果不配置共享线程池，那么Catalina各组件在用到线程池时会<strong>独立创建</strong>。 如果我们想添加一个共享的线程池，可以在下添加如下配置：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">&quot;tomcatThreadPool&quot;</span> 线程池名称，用于 <span class="attr">Connector</span>中指定。</span></span><br><span class="line"><span class="tag">          <span class="attr">namePrefix</span>=<span class="string">&quot;catalina‐exec‐&quot;</span> 所创建的每个线程的名称前缀，一个单独的线程名称为 <span class="attr">namePrefix</span>+<span class="attr">threadNumber</span>。</span></span><br><span class="line"><span class="tag">          <span class="attr">maxThreads</span>=<span class="string">&quot;200&quot;</span> 池中最大线程数。</span></span><br><span class="line"><span class="tag">          <span class="attr">minSpareThreads</span>=<span class="string">&quot;100&quot;</span> 核心线程数</span></span><br><span class="line"><span class="tag">          <span class="attr">maxIdleTime</span>=<span class="string">&quot;60000&quot;</span> 线程空闲时间，超过该时间后，空闲线程会被销毁，默认值为<span class="attr">6000</span>（<span class="attr">1</span>分钟），单位毫秒。</span></span><br><span class="line"><span class="tag">          <span class="attr">maxQueueSize</span>=<span class="string">&quot;Integer.MAX_VALUE&quot;</span> 在被执行前最大线程排队数目 需要根据硬件实际调整 如果太大可能内存溢出</span></span><br><span class="line"><span class="tag">          <span class="attr">prestartminSpareThreads</span>=<span class="string">&quot;false&quot;</span> 启动线程池时是否启动 <span class="attr">minSpareThreads</span>部分线程。默认值为<span class="attr">false</span>，即不启动。 </span></span><br><span class="line"><span class="tag">          <span class="attr">threadPriority</span>=<span class="string">&quot;5&quot;</span> 线程池中线程优先级，默认值为<span class="attr">5</span>，值从<span class="attr">1</span>到<span class="attr">10</span>。</span></span><br><span class="line"><span class="tag">          线程池实现类，未指定情况下，默认实现类为<span class="attr">org.apache.catalina.core.StandardThreadExecutor</span>。</span></span><br><span class="line"><span class="tag">          如果想使用自定义线程池首先需要实现<span class="attr">org.apache.catalina.Executor</span>接口。</span></span><br><span class="line"><span class="tag">          <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.StandardThreadExecutor&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></div></figure>

        <h4 id="connector-标签"   >
          <a href="#connector-标签" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#connector-标签"></a> Connector 标签</h4>
      
<p>Connector 用于创建连接器实例。默认情况下，<code>server.xml</code> 配置了<strong>两个</strong>连接器，<strong>一个支持HTTP协议</strong>，<strong>一个支持AJP协议</strong>。因此大多数情况下，我们并不需要新增连接器配置，只是根据需要对已有连接器进行优化。</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8009&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></div></figure>
<ul>
<li><code>port</code>：端口号，<code>Connector</code>用于创建服务端Socket并进行监听， 以等待客户端请求链接。如果该属性设置为0，Tomcat将会随机选择一个可用的端口号给当前<code>Connector</code>使用。</li>
<li><code>protocol</code> ：当前Connector支持的<strong>访问协议</strong>。 <strong>默认为 HTTP/1.1</strong> ，并采用自动切换机制选择一个基于 Java NIO 的连接器或者基于本地APR的连接器（根据本地是否含有Tomcat的本地库判定）。如果不希望采用上述自动切换的机制， 而是明确指定协议，可以使用以下值：</li>
</ul>
<hr />
<p>Http协议：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.coyote.http11.Http11NioProtocol  非阻塞式 Java NIO 链接器</span><br><span class="line">org.apache.coyote.http11.Http11Nio2Protocol 非阻塞式 JAVA NIO2 链接器</span><br><span class="line">org.apache.coyote.http11.Http11AprProtocol  APR 链接器</span><br></pre></td></tr></table></div></figure>
<p>AJP协议 ：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.coyote.ajp.AjpNioProtocol  非阻塞式 Java NIO 链接器</span><br><span class="line">org.apache.coyote.ajp.AjpNio2Protocol 非阻塞式 JAVA NIO2 链接器</span><br><span class="line">org.apache.coyote.ajp.AjpAprProtocol  APR 链接器</span><br></pre></td></tr></table></div></figure>
<hr />
<ul>
<li><code>connectionTimeOut</code>：<code>Connector</code> 接收连接后的等待超时时间， 单位为毫秒。 -1 表示不超时。</li>
<li><code>redirectPort</code>：当前Connector 不支持SSL（https）请求， 接收到了一个请求， 并且也符合 <code>security-constraint</code>：安全约束， 需要SSL传输，Catalina自动将请求重定向到指定的端口。</li>
<li><code>executor</code>： 如果有使用共享线程池可以指定上面讲的共享线程池的名称</li>
<li><code>URIEncoding</code> : 用于指定编码URI的字符编码，Tomcat8.x版本默认的编码为 UTF-8 ，Tomcat7.x版本默认为ISO-8859-1。</li>
</ul>
<p>完整的协议：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">executor</span>=<span class="string">&quot;tomcatThreadPool&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxThreads</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">minSpareThreads</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">acceptCount</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxConnections</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compression</span>=<span class="string">&quot;on&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compressionMinSize</span>=<span class="string">&quot;2048&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">disableUploadTimeout</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">URIEncoding</span>=<span class="string">&quot;UTF‐8&quot;</span> /&gt;</span></span><br></pre></td></tr></table></div></figure>

        <h4 id="engine-标签"   >
          <a href="#engine-标签" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#engine-标签"></a> Engine 标签</h4>
      
<p><code>Engine</code> 作为Servlet引擎的顶级元素，内部可以嵌入： <code>Cluster</code>、<code>Listener</code>、<code>Realm</code>、<code>Valve</code>和<code>Host</code>。</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
<ul>
<li><code>name</code>： 用于指定Engine的名称， 默认为Catalina 。该名称会影响一部分Tomcat的存储路径（如临时文件）。</li>
<li><code>defaultHost</code> ： 默认使用的<strong>虚拟主机名称</strong>， 当客户端请求指向的主机无效时，将交由默认的虚拟主机处理，默认为localhost。</li>
</ul>

        <h4 id="host-标签"   >
          <a href="#host-标签" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#host-标签"></a> Host 标签</h4>
      
<p>Host 元素用于配置一个<strong>虚拟主机</strong>， 它支持以下嵌入元素：<code>Alias</code>、<code>Cluster</code>、<code>Listener</code>、<code>Valve</code>、<code>Realm</code>、<code>Context</code>。如果在<code>Engine</code>下配置<code>Realm</code>， 那么此配置将在当前<code>Engine</code>下的所有<code>Host</code>中共享。 同样，如果在<code>Host</code>中配置<code>Realm</code>， 则在当前<code>Host</code>下的所有<code>Context</code>中共享。</p>
<p>Context中的Realm优先级 &gt; Host 的Realm优先级 &gt; Engine中的Realm优先级。说的简单点就是Realm类似于Unix里面的group。在Unix中，一个group对应着系统的一组资源，某个group不能访问不属于它的资源。Tomcat用Realm来将不同的应用（类似系统资源）赋给不同的用户（类似group），没有权限的用户则不能访问相关的应用。用于配置安全管理角色，通常读取<code>tomcat-uesrs.xml</code>进行验证。</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span> <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;www.web1.com&quot;</span> <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span> <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Alias</span>&gt;</span>www.web2.com<span class="tag">&lt;/<span class="name">Alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
<ul>
<li><code>name</code>：当前Host通用的网络名称，必须与DNS服务器上的注册信息一致。Engine中包含的Host必须存在一个名称与Engine的defaultHost设置一致。</li>
<li><code>appBase</code>：当前Host的应用基础目录，当前Host上部署的Web应用均在该目录下（可以是绝对目录，相对路径）。默认为webapps。</li>
<li><code>unpackWARs</code>：设置为true，Host在启动时会将appBase目录下war包解压为目录。设置为false， Host将直接从war文件启动。</li>
<li><code>autoDeploy</code>：控制tomcat是否在运行时定期检测并自动部署新增或变更的web应用。</li>
</ul>
<p><strong>通过给<code>Host</code>添加别名，我们可以实现同一个<code>Host</code>拥有多个网络名称，然后就可以通过两个域名访问当前Host下的应用</strong>（需要确保DNS或hosts中添加了域名的映射配置）。</p>

        <h4 id="context"   >
          <a href="#context" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#context"></a> Context</h4>
      
<p><code>Context</code>元素用于配置一个Web应用，默认的配置如下：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">&quot;myApp&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/myApp&quot;</span>&gt;</span></span><br><span class="line">    ....</span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
<ul>
<li><code>docBase</code>：Web应用目录或者War包的部署路径。可以是绝对路径，也可以是相对于 Host appBase的相对路径。</li>
<li><code>path</code>：Web应用的Context 路径。如果我们Host名为localhost， 则该web应用访问的根路径为： <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://localhost:8080/myApp%E3%80%82" >http://localhost:8080/myApp。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
<p>它支持的内嵌元素为：<code>CookieProcessor</code>，<code>Loader</code>，<code>Manager</code>，<code>Realm</code>，<code>Resources</code>，<code>WatchedResource</code>，<code>JarScanner</code>，<code>Valve</code>。</p>

        <h3 id="tomcat-userxml"   >
          <a href="#tomcat-userxml" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tomcat-userxml"></a> tomcat-user.xml</h3>
      
<p>该配置文件中，主要配置的是Tomcat的用户，角色等信息，用来控制Tomcat中manager， host-manager的访问权限,还可以配合上面讲的Realm控制用户组的访问权限。Realm的相关内容可以参考<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/xing901022/p/4552843.html" >这篇文章</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，写的已经很详细了。</p>

        <h3 id="webxml"   >
          <a href="#webxml" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#webxml"></a> web.xml</h3>
      
<p><code>web.xml</code> 是web应用的描述文件，它支持的元素及属性来自于Servlet规范定义 。在Tomcat中， Web 应用的描述信息包括 <code>tomcat/conf/web.xml</code> 中默认配置以及Web应用 <code>WEB-INF/web.xml</code> 下的定制配置。在Tomcat中的<code>web.xml</code>进行的配置是对webappp下所有的应用都有影响（全局配置）。</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&lt;context‐param&gt;</span><br><span class="line">    &lt;param‐name&gt;contextConfigLocation&lt;/param‐name&gt;</span><br><span class="line">    &lt;param‐value&gt;classpath:applicationContext‐*.xml&lt;/param‐value&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring Config File Location<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    &lt;/context‐param&gt;</span><br><span class="line"></span><br><span class="line">&lt;session‐config&gt;</span><br><span class="line">    &lt;session‐timeout&gt;30&lt;/session‐timeout&gt; 会话超时时间，单位 分钟</span><br><span class="line">    &lt;cookie‐config&gt; 用于配置会话追踪Cookie</span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>JESSIONID<span class="tag">&lt;/<span class="name">name</span>&gt;</span> Cookie的名称</span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span>&gt;</span>www.itcast.cn<span class="tag">&lt;/<span class="name">domain</span>&gt;</span> Cookie的域名</span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span> Cookie的路径</span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>Session Cookie<span class="tag">&lt;/<span class="name">comment</span>&gt;</span> 注释</span><br><span class="line">        &lt;http‐only&gt;true&lt;/http‐only&gt; cookie只能通过HTTP方式进行访问，JS无法读取或修改，此项可以增加网站访问的安全性。</span><br><span class="line">        <span class="tag">&lt;<span class="name">secure</span>&gt;</span>false<span class="tag">&lt;/<span class="name">secure</span>&gt;</span> 此cookie只能通过HTTPS连接传递到服务器，而HTTP 连接则不会传递该信息。注意是从浏览器传递到服务器，服务器端的Cookie对象不受此项影响。</span><br><span class="line">        &lt;max‐age&gt;3600&lt;/max‐age&gt; 以秒为单位表示cookie的生存期，默认为‐1表示是会话Cookie，浏览器关闭时就会消失。</span><br><span class="line">        &lt;/cookie‐config&gt; </span><br><span class="line">    &lt;tracking‐mode&gt;COOKIE&lt;/tracking‐mode&gt; 用于配置会话追踪模式，Servlet3.0版本中支持的追踪模式：COOKIE、URL、SSL</span><br><span class="line">    &lt;/session‐config&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    &lt;servlet‐name&gt;myServlet&lt;/servlet‐name&gt; 指定servlet的名称， 该属性在web.xml中唯一。</span><br><span class="line">    &lt;servlet‐class&gt;cn.itcast.web.MyServlet&lt;/servlet‐class&gt; 用于指定servlet类名</span><br><span class="line">    &lt;init‐param&gt; 用于指定servlet的初始化参数， 在应用中可以通HttpServlet.getInitParameter 获取。</span><br><span class="line">        &lt;param‐name&gt;fileName&lt;/param‐name&gt;</span><br><span class="line">        &lt;param‐value&gt;init.conf&lt;/param‐value&gt;</span><br><span class="line">        &lt;/init‐param&gt;</span><br><span class="line">    &lt;load‐on‐startup&gt;1&lt;/load‐on‐startup&gt; 用于控制在Web应用启动时，Servlet的加载顺序。 值小于0，web应用启动时，不加载该servlet, 第一次访问时加载。</span><br><span class="line">    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span> 若为false ，表示Servlet不处理任何请求。</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;servlet‐mapping&gt;</span><br><span class="line">    &lt;servlet‐name&gt;myServlet&lt;/servlet‐name&gt;</span><br><span class="line">    &lt;url‐pattern&gt;*.do&lt;/url‐pattern&gt;</span><br><span class="line">    &lt;url‐pattern&gt;/myservet/*&lt;/url‐pattern&gt; 用于指定URL表达式，一个 servlet‐mapping可以同时配置多个 url‐pattern</span><br><span class="line">    &lt;/servlet‐mapping&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    &lt;servlet‐name&gt;uploadServlet&lt;/servlet‐name&gt;</span><br><span class="line">    &lt;servlet‐class&gt;cn.itcast.web.UploadServlet&lt;/servlet‐class&gt;</span><br><span class="line">    &lt;multipart‐config&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>C://path<span class="tag">&lt;/<span class="name">location</span>&gt;</span> 存放生成的文件地址。</span><br><span class="line">        &lt;max‐file‐size&gt;10485760&lt;/max‐file‐size&gt; 允许上传的文件最大值。 默认值为‐1， 表示没有限制。</span><br><span class="line">        &lt;max‐request‐size&gt;10485760&lt;/max‐request‐size&gt;针对该 multi/form‐data 请求的最大数量，默认值为‐1， 表示无限制。</span><br><span class="line">        &lt;file‐size‐threshold&gt;0&lt;/file‐size‐threshold&gt; 当数量量大于该值时， 内容会被写入文件。</span><br><span class="line">        &lt;/multipart‐config&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    &lt;listener‐class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener‐class&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    &lt;filter‐name&gt;myFilter&lt;/filter‐name&gt; 用于指定过滤器名称，在web.xml中，过滤器名称必须唯一。</span><br><span class="line">    &lt;filter‐class&gt;cn.itcast.web.MyFilter&lt;/filter‐class&gt; 过滤器的全限定类名， 该类必须实现Filter接口。</span><br><span class="line">    &lt;async‐supported&gt;true&lt;/async‐supported&gt; 该过滤器是否支持异步</span><br><span class="line">    &lt;init‐param&gt; 用于配置Filter的初始化参数， 可以配置多个， 可以通过FilterConfig.getInitParameter获取</span><br><span class="line">        &lt;param‐name&gt;language&lt;/param‐name&gt;</span><br><span class="line">        &lt;param‐value&gt;CN&lt;/param‐value&gt;</span><br><span class="line">    &lt;/init‐param&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;filter‐mapping&gt;</span><br><span class="line">    &lt;filter‐name&gt;myFilter&lt;/filter‐name&gt;</span><br><span class="line">    &lt;url‐pattern&gt;/*&lt;/url‐pattern&gt; 指定该过滤器需要拦截的URL。</span><br><span class="line">&lt;/filter‐mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;welcome‐file‐list&gt;</span><br><span class="line">    &lt;welcome‐file&gt;index.html&lt;/welcome‐file&gt;</span><br><span class="line">    &lt;welcome‐file&gt;index.htm&lt;/welcome‐file&gt;</span><br><span class="line">    &lt;welcome‐file&gt;index.jsp&lt;/welcome‐file&gt;</span><br><span class="line">&lt;/welcome‐file‐list&gt;</span><br><span class="line"></span><br><span class="line">&lt;error‐page&gt;</span><br><span class="line">    &lt;error‐code&gt;404&lt;/error‐code&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">&lt;/error‐page&gt;</span><br><span class="line">&lt;error‐page&gt;</span><br><span class="line">    &lt;error‐code&gt;500&lt;/error‐code&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/500.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">&lt;/error‐page&gt;</span><br><span class="line">&lt;error‐page&gt;</span><br><span class="line">    &lt;exception‐type&gt;java.lang.Exception&lt;/exception‐type&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">&lt;/error‐page&gt;</span><br></pre></td></tr></table></div></figure>
<p>更多详细配置见博客 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_15758463/article/details/120287536?spm=1001.2014.3001.5501%E4%B8%8E%E6%96%87%E6%A1%A3" >https://blog.csdn.net/qq_15758463/article/details/120287536?spm=1001.2014.3001.5501与文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.yuyunzhao.cn/document/Tomcat.pdf" >https://blog.yuyunzhao.cn/document/Tomcat.pdf</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="websocket"   >
          <a href="#websocket" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#websocket"></a> WebSocket</h2>
      
<p>WebSocket 是一种全双工应用层协议，用于建立客户端与服务器端的双向连接，使得服务端可以主动向客户端发出请求。常用于聊天软件等需要双方保持互相能够通讯且保持长链接的场景：</p>
<p><img src="/images/%E3%80%90Tomcat%E3%80%91Tomcat/image-20220130231727802.png" alt="image-20220130231727802" /></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://yuyun-zhao.github.io">yuyun zhao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://yuyun-zhao.github.io/2021/04/29/%E3%80%90Tomcat%E3%80%91Tomcat/">http://yuyun-zhao.github.io/2021/04/29/%E3%80%90Tomcat%E3%80%91Tomcat/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.github.io/tags/Tomcat/">Tomcat</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/05/01/%E3%80%90JavaWeb%E3%80%91Session%E5%92%8CCookie/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">【JavaWeb】Session 和 Cookie</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/04/28/%E3%80%90JavaWeb%E3%80%91%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"><span class="paginator-prev__text">【JavaWeb】文件上传</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#tomcat-%E7%AE%80%E4%BB%8B"><span class="toc-text">
           Tomcat 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-text">
           历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81-web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AF%E4%BB%B6"><span class="toc-text">
           常见 web 服务器软件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tomcat-%E6%9E%B6%E6%9E%84"><span class="toc-text">
           Tomcat 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">
           HTTP 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-text">
           HTTP 服务器请求处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#servlet-%E5%AE%B9%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">
           Servlet 容器工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tomcat-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-text">
           Tomcat 整体架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">
           示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%99%A8%E6%A1%86%E6%9E%B6-coyote"><span class="toc-text">
           连接器框架 Coyote</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#coyote-%E7%AE%80%E4%BB%8B"><span class="toc-text">
           Coyote 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE"><span class="toc-text">
           IO 模型与协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%99%A8%E7%BB%84%E4%BB%B6"><span class="toc-text">
           连接器组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#endpoint"><span class="toc-text">
           EndPoint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#processor"><span class="toc-text">
           Processor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#protocolhandler"><span class="toc-text">
           ProtocolHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#adapter"><span class="toc-text">
           Adapter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">
           总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#catalina-%E5%AE%B9%E5%99%A8"><span class="toc-text">
           Catalina 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#container-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84"><span class="toc-text">
           Container 如何处理请求的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tomcat-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">
           Tomcat 启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">
           源码解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-text">
           各组件实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">
           总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tomcat-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">
           Tomcat 请求处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">
           总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jasper"><span class="toc-text">
           Jasper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jasper-%E7%AE%80%E4%BB%8B"><span class="toc-text">
           Jasper 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsp-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-text">
           JSP 编译过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tomcat-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">
           Tomcat 配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tomcat-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">
           Tomcat 目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serverxml"><span class="toc-text">
           server.xml</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#listener-%E6%A0%87%E7%AD%BE"><span class="toc-text">
           Listener 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#globalnamingresources-%E6%A0%87%E7%AD%BE"><span class="toc-text">
           GlobalNamingResources 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#service-%E6%A0%87%E7%AD%BE"><span class="toc-text">
           Service 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#executor-%E6%A0%87%E7%AD%BE"><span class="toc-text">
           Executor 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connector-%E6%A0%87%E7%AD%BE"><span class="toc-text">
           Connector 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#engine-%E6%A0%87%E7%AD%BE"><span class="toc-text">
           Engine 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#host-%E6%A0%87%E7%AD%BE"><span class="toc-text">
           Host 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#context"><span class="toc-text">
           Context</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tomcat-userxml"><span class="toc-text">
           tomcat-user.xml</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webxml"><span class="toc-text">
           web.xml</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket"><span class="toc-text">
           WebSocket</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/author.png" alt="avatar"></div><p class="sidebar-ov-author__text">no code no life</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YUYUN-ZHAO" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="zyy18749810683" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1024462136" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:im.yuyunzhao@gmail.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gmail</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">153</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">40</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">40</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>yuyun zhao</span><span class="footer__devider">|</span><span>沪ICP备2022000458号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>