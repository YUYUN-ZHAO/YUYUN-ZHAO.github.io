<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="Java 基础                             谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？        Java 本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“书写一次，到处运行”（Write once, run anywhere），能够非常容易地获得跨平台能力；另外就是垃圾收集（GC, Garbage">
<meta property="og:type" content="article">
<meta property="og:title" content="【Java】Java 常见问题">
<meta property="og:url" content="http://yuyun-zhao.github.io/2021/04/25/%E3%80%90Java%E3%80%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="yuyun zhao&#39;s blog">
<meta property="og:description" content="Java 基础                             谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？        Java 本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“书写一次，到处运行”（Write once, run anywhere），能够非常容易地获得跨平台能力；另外就是垃圾收集（GC, Garbage">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Java%E3%80%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image-20220307110325063.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/2021/04/25/images/%E3%80%90Java%E3%80%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/3a51f06f56b905b8fbf1661359e1727e.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/2021/04/25/images/%E3%80%90Java%E3%80%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/ffd41494a39ef737b3c1151929c3c4ad.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Java%E3%80%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/0012.png">
<meta property="article:published_time" content="2021-04-25T02:06:14.000Z">
<meta property="article:modified_time" content="2022-03-07T04:17:19.991Z">
<meta property="article:author" content="yuyun zhao">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Java%E3%80%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image-20220307110325063.png"><title>【Java】Java 常见问题 | yuyun zhao's blog</title><link ref="canonical" href="http://yuyun-zhao.github.io/2021/04/25/%E3%80%90Java%E3%80%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">文章</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">yuyun zhao's blog</div><div class="header-banner-info__subtitle">no code no life</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">【Java】Java 常见问题</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-04-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-07</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">17.9k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">100分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h2 id="java-基础"   >
          <a href="#java-基础" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java-基础"></a> Java 基础</h2>
      

        <h3 id="谈谈你对-java-平台的理解java-是解释执行这句话正确吗"   >
          <a href="#谈谈你对-java-平台的理解java-是解释执行这句话正确吗" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#谈谈你对-java-平台的理解java-是解释执行这句话正确吗"></a> 谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？</h3>
      
<p>Java 本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“书写一次，到处运行”（Write once, run anywhere），能够非常容易地获得跨平台能力；另外就是垃圾收集（GC, Garbage Collection），Java 通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。</p>
<p>我们日常会接触到 JRE（Java Runtime Environment）或者 JDK（Java Development Kit）。 JRE，也就是 Java 运行环境，包含了 JVM 和 Java 类库，以及一些模块等。而 JDK 可以看作是 JRE 的一个超集，提供了更多工具，比如编译器、各种诊断工具等。</p>
<p>对于“Java 是解释执行”这句话，这个说法不太准确。我们开发的 Java 的源代码，首先通过 Javac 编译成为字节码（bytecode），然后，在运行时，通过 Java 虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的 JVM，比如我们大多数情况使用的 Oracle JDK 提供的 Hotspot JVM，都提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了。</p>
<p><img src="/images/%E3%80%90Java%E3%80%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image-20220307110325063.png" alt="image-20220307110325063" /></p>

        <h3 id="请对比-exception-和-error另外运行时异常与一般异常有什么区别"   >
          <a href="#请对比-exception-和-error另外运行时异常与一般异常有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#请对比-exception-和-error另外运行时异常与一般异常有什么区别"></a> 请对比 Exception 和 Error，另外，运行时异常与一般异常有什么区别？</h3>
      
<p>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>
<p>Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p>
<p>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。</p>
<p>Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面我介绍的不可查的 Error，是 Throwable 不是 Exception。</p>
<p>不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p>

        <h3 id="谈谈final-finally-finalize有什么不同"   >
          <a href="#谈谈final-finally-finalize有什么不同" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#谈谈final-finally-finalize有什么不同"></a> 谈谈final、finally、 finalize有什么不同？</h3>
      
<p>final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。</p>
<p>finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。</p>
<p>finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。</p>

        <h3 id="强引用-软引用-弱引用-幻象引用有什么区别"   >
          <a href="#强引用-软引用-弱引用-幻象引用有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#强引用-软引用-弱引用-幻象引用有什么区别"></a> 强引用、软引用、弱引用、幻象引用有什么区别？</h3>
      
<p>不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。所谓强引用（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>软引用（SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p>弱引用（WeakReference）并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。</p>
<p>对于幻象引用，有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制，我在专栏上一讲中介绍的 Java 平台自身 Cleaner 机制等，也有人利用幻象引用监控对象的创建和销毁。</p>
<span id="more"></span>

        <h3 id="string-stringbuffer-stringbuilder有什么区别"   >
          <a href="#string-stringbuffer-stringbuilder有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#string-stringbuffer-stringbuilder有什么区别"></a> String、StringBuffer、StringBuilder有什么区别？</h3>
      
<p>String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p>
<p>StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。</p>
<p>StringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。</p>

        <h3 id="谈谈-java-反射机制动态代理是基于什么原理"   >
          <a href="#谈谈-java-反射机制动态代理是基于什么原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#谈谈-java-反射机制动态代理是基于什么原理"></a> 谈谈 Java 反射机制，动态代理是基于什么原理？</h3>
      
<p>反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p>
<p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p>
<p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p>

        <h3 id="int-和-integer-有什么区别谈谈-integer-的值缓存范围"   >
          <a href="#int-和-integer-有什么区别谈谈-integer-的值缓存范围" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#int-和-integer-有什么区别谈谈-integer-的值缓存范围"></a> int 和 Integer 有什么区别？谈谈 Integer 的值缓存范围。</h3>
      
<p>int 是我们常说的整形数字，是 Java 的 8 个原始数据类型（Primitive Types，boolean、byte 、short、char、int、float、double、long）之一。Java 语言虽然号称一切都是对象，但原始数据类型是例外。</p>
<p>Integer 是 int 对应的包装类，它有一个 int 类型的字段存储数据，并且提供了基本操作，比如数学运算、int 和字符串之间转换等。在 Java 5 中，引入了自动装箱和自动拆箱功能（boxing/unboxing），Java 可以根据上下文，自动进行转换，极大地简化了相关编程。</p>
<p>关于 Integer 的值缓存，这涉及 Java 5 中另一个改进。构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在 Java 5 中新增了静态工厂方法 valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，这个值默认缓存是 -128 到 127 之间。</p>
<blockquote>
<p>Integer 的缓存机制必须使用自动装箱机制时才可以体现。如果还是使用 new Integer() 的方式，是不会使用到缓存机制的</p>
</blockquote>

        <h3 id="对比-vector-arraylist-linkedlist-有何区别"   >
          <a href="#对比-vector-arraylist-linkedlist-有何区别" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对比-vector-arraylist-linkedlist-有何区别"></a> 对比 Vector、ArrayList、LinkedList 有何区别？</h3>
      
<p>这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p>
<p>Vector 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据</p>
<p>ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。</p>
<p>LinkedList 顾名思义是 Java 提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的。</p>

        <h3 id="对比-hashtable-hashmap-treemap-有什么不同谈谈你对-hashmap-的掌握"   >
          <a href="#对比-hashtable-hashmap-treemap-有什么不同谈谈你对-hashmap-的掌握" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对比-hashtable-hashmap-treemap-有什么不同谈谈你对-hashmap-的掌握"></a> 对比 Hashtable、HashMap、TreeMap 有什么不同？谈谈你对 HashMap 的掌握</h3>
      
<p>Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。</p>
<p>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</p>
<p>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。</p>
<p>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</p>

        <h3 id="如何保证容器是线程安全的concurrenthashmap-如何实现高效地线程安全"   >
          <a href="#如何保证容器是线程安全的concurrenthashmap-如何实现高效地线程安全" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#如何保证容器是线程安全的concurrenthashmap-如何实现高效地线程安全"></a> 如何保证容器是线程安全的？ConcurrentHashMap 如何实现高效地线程安全？</h3>
      
<p>Java 提供了不同层面的线程安全支持。在传统集合框架内部，除了 Hashtable 等同步容器，还提供了所谓的同步包装器（Synchronized Wrapper），我们可以调用 Collections 工具类提供的包装方法，来获取一个同步的包装容器（如 Collections.synchronizedMap），但是它们都是利用非常粗粒度的同步方式，在高并发情况下，性能比较低下。</p>
<p>另外，更加普遍的选择是利用并发包提供的线程安全容器类，它提供了：</p>
<ul>
<li>各种并发容器，比如 ConcurrentHashMap、CopyOnWriteArrayList。各种线程安全队列（Queue/Deque），如 ArrayBlockingQueue、SynchronousQueue。</li>
<li>各种有序容器的线程安全版本等。具体保证线程安全的方式，包括有从简单的 synchronize 方式，到基于更加精细化的，比如基于分离锁实现的 ConcurrentHashMap 等并发实现等。</li>
</ul>
<p>具体选择要看开发的场景需求，总体来说，并发包内提供的容器通用场景，远优于早期的简单同步实现。</p>

        <h3 id="java-提供了哪些-io-方式-nio-如何实现多路复用"   >
          <a href="#java-提供了哪些-io-方式-nio-如何实现多路复用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java-提供了哪些-io-方式-nio-如何实现多路复用"></a> Java 提供了哪些 IO 方式？ NIO 如何实现多路复用？</h3>
      
<p>Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。</p>
<p>第一，传统的 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://java.io" >java.io</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://java.io" >java.io</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。很多时候，人们也把 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://java.net" >java.net</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。</p>
<p>第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p>
<p>第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p>

        <h3 id="java有几种文件拷贝方式哪一种最高效"   >
          <a href="#java有几种文件拷贝方式哪一种最高效" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java有几种文件拷贝方式哪一种最高效"></a> Java有几种文件拷贝方式？哪一种最高效？</h3>
      
<p>Java 有多种比较典型的文件拷贝实现方式，比如：</p>
<ul>
<li>利用 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://java.io" >java.io</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 类库，直接为源文件构建一个 FileInputStream 读取，然后再为目标文件构建一个 FileOutputStream，完成写入工作。</li>
<li>利用 java.nio 类库提供的 transferTo 或 transferFrom 方法实现（零拷贝）。</li>
</ul>
<p>当然，Java 标准类库本身已经提供了几种 Files.copy 的实现。对于 Copy 的效率，这个其实与操作系统和配置等情况相关，总体上来说，NIO transferTo/From 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</p>

        <h3 id="谈谈接口和抽象类有什么区别"   >
          <a href="#谈谈接口和抽象类有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#谈谈接口和抽象类有什么区别"></a> 谈谈接口和抽象类有什么区别？</h3>
      
<p>接口和抽象类是 Java 面向对象设计的两个基础机制。</p>
<ul>
<li>接口是对行为的活能力的抽象</li>
<li>抽象类是抽取公共的部分，比如模板方法，增加代码的复用性</li>
</ul>
<p>接口是对<strong>行为</strong>的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。接口，不能实例化；不能包含任何非常量成员，任何 field 都是隐含着 public static final 的意义；同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。Java 标准类库中，定义了非常多的接口，比如 java.util.List。</p>
<p>抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是<strong>代码重用</strong>。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。</p>
<p>抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。Java 标准库中，比如 collection 框架，很多通用部分就被抽取成为抽象类，例如 java.util.AbstractList。Java 类实现 interface 使用 implements 关键词，继承 abstract class 则是使用 extends 关键词，我们可以参考 Java 标准库中的 ArrayList。</p>

        <h3 id="谈谈你知道的设计模式请手动实现单例模式spring-等框架中使用了哪些模式"   >
          <a href="#谈谈你知道的设计模式请手动实现单例模式spring-等框架中使用了哪些模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#谈谈你知道的设计模式请手动实现单例模式spring-等框架中使用了哪些模式"></a> 谈谈你知道的设计模式？请手动实现单例模式，Spring 等框架中使用了哪些模式？</h3>
      
<p>大致按照模式的应用目标分类，设计模式可以分为创建型模式、结构型模式和行为型模式。</p>
<ul>
<li>创建型模式，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。</li>
<li>结构型模式，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。</li>
<li>行为型模式，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。</li>
</ul>

        <h3 id="synchronized-和-reentrantlock-有什么区别有人说-synchronized-最慢这话靠谱吗"   >
          <a href="#synchronized-和-reentrantlock-有什么区别有人说-synchronized-最慢这话靠谱吗" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#synchronized-和-reentrantlock-有什么区别有人说-synchronized-最慢这话靠谱吗"></a> synchronized 和 ReentrantLock 有什么区别？有人说 synchronized 最慢，这话靠谱吗？</h3>
      
<p>synchronized 是 Java 内建的同步机制，所以也有人称其为 Intrinsic Locking，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。</p>
<p>在 Java 5 以前，synchronized 是仅有的同步手段，在代码中， synchronized 可以用来修饰方法，也可以使用在特定的代码块儿上，本质上 synchronized 方法等同于把方法全部语句用 synchronized 块包起来。</p>
<p>ReentrantLock，通常翻译为再入锁，是 Java 5 提供的锁实现，它的语义和 synchronized 基本相同。再入锁通过代码直接调用 lock() 方法获取，代码书写也更加灵活。与此同时，ReentrantLock 提供了很多实用的方法，能够实现很多 synchronized 无法做到的细节控制，比如可以控制 fairness，也就是公平性，或者利用定义条件等。但是，编码中也需要注意，必须要明确调用 unlock() 方法释放，不然就会一直持有该锁。</p>
<p>synchronized 和 ReentrantLock 的性能不能一概而论，早期版本 synchronized 在很多场景下性能相差较大，在后续版本进行了较多改进，在低竞争场景中表现可能优于 ReentrantLock。</p>

        <h3 id="synchronized-底层如何实现什么是锁的升级-降级"   >
          <a href="#synchronized-底层如何实现什么是锁的升级-降级" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#synchronized-底层如何实现什么是锁的升级-降级"></a> synchronized 底层如何实现？什么是锁的升级、降级？</h3>
      
<p>synchronized 代码块是由一对儿 monitorenter/monitorexit 指令实现的，Monitor 对象是同步的基本实现单元。</p>
<p>在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。</p>
<p>现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>
<p>所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p>
<p>当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</p>
<p>如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</p>
<p>我注意到有的观点认为 Java 不会进行锁降级。实际上据我所知，锁降级确实是会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</p>

        <h3 id="一个线程两次调用-start-方法会出现什么情况谈谈线程的生命周期和状态转移"   >
          <a href="#一个线程两次调用-start-方法会出现什么情况谈谈线程的生命周期和状态转移" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#一个线程两次调用-start-方法会出现什么情况谈谈线程的生命周期和状态转移"></a> 一个线程两次调用 start() 方法会出现什么情况？谈谈线程的生命周期和状态转移。</h3>
      
<p>Java 的线程是不允许启动两次的，第二次调用必然会抛出 IllegalThreadStateException，这是一种运行时异常，多次调用 start 被认为是编程错误。</p>
<p>关于线程生命周期的不同状态，在 Java 5 以后，线程状态被明确定义在其公共内部枚举类型 java.lang.Thread.State 中，分别是：</p>
<ul>
<li>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个 Java 内部状态。</li>
<li>就绪（RUNNABLE），表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它 CPU 片段，在就绪队列里面排队。在其他一些分析中，会额外区分一种状态 RUNNING，但是从 Java API 的角度，并不能表示出来。</li>
<li>阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待 Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</li>
<li>等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似 notify 等动作，通知消费线程可以继续工作了。Thread.join() 也会令线程进入等待状态。</li>
<li>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 wait 或 join 等方法的指定超时版本。</li>
<li>终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。</li>
</ul>
<p>在第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都是不可以再次启动的。</p>

        <h3 id="什么情况下java程序会产生死锁如何定位-修复"   >
          <a href="#什么情况下java程序会产生死锁如何定位-修复" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#什么情况下java程序会产生死锁如何定位-修复"></a> 什么情况下Java程序会产生死锁？如何定位、修复？</h3>
      
<p>死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。</p>
<p>定位死锁最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测。</p>
<p>如果程序运行时发生了死锁，绝大多数情况下都是无法在线解决的，只能重启、修正程序本身问题。所以，代码开发阶段互相审查，或者利用工具进行预防性排查，往往也是很重要的。</p>

        <h3 id="java-并发包提供了哪些并发工具类"   >
          <a href="#java-并发包提供了哪些并发工具类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java-并发包提供了哪些并发工具类"></a> Java 并发包提供了哪些并发工具类？</h3>
      
<p>我们通常所说的并发包也就是 java.util.concurrent 及其子包，集中了 Java 并发的各种基础工具类，具体主要包括几个方面：</p>
<ul>
<li>提供了比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Semaphore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。</li>
<li>各种线程安全的容器，比如最常见的 ConcurrentHashMap、有序的 ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组 CopyOnWriteArrayList 等。</li>
<li>各种并发队列实现，如各种 BlockingQueue 实现，比较典型的 ArrayBlockingQueue、 SynchronousQueue 或针对特定场景的 PriorityBlockingQueue 等。</li>
<li>强大的 Executor 框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</li>
</ul>

        <h3 id="并发包中的-concurrentlinkedqueue-和-linkedblockingqueue-有什么区别"   >
          <a href="#并发包中的-concurrentlinkedqueue-和-linkedblockingqueue-有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#并发包中的-concurrentlinkedqueue-和-linkedblockingqueue-有什么区别"></a> 并发包中的 ConcurrentLinkedQueue 和 LinkedBlockingQueue 有什么区别？</h3>
      
<p>有时候我们把并发包下面的所有容器都习惯叫作并发容器，但是严格来讲，类似 ConcurrentLinkedQueue 这种“Concurrent*”容器，才是真正代表并发。</p>
<ul>
<li>Concurrent 类型基于 lock-free，在常见的多线程访问场景，一般可以提供较高吞吐量。</li>
<li>LinkedBlockingQueue 内部则是基于锁，并提供了 BlockingQueue 的等待性方法。</li>
</ul>
<p>不知道你有没有注意到，java.util.concurrent 包提供的容器（Queue、List、Set）、Map，从命名上可以大概区分为 Concurrent*、CopyOnWrite和 Blocking等三类，同样是线程安全容器，可以简单认为：</p>
<p>Concurrent 类型没有类似 CopyOnWrite 之类容器相对较重的修改开销。但是，凡事都是有代价的，Concurrent 往往提供了较低的遍历一致性。你可以这样理解所谓的弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历。与弱一致性对应的，就是我介绍过的同步容器常见的行为“fail-fast”，也就是检测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException，不再继续遍历。弱一致性的另外一个体现是，size 等操作准确性是有限的，未必是 100% 准确。与此同时，读取的性能具有一定的不确定性。</p>

        <h3 id="java-并发类库提供的线程池有哪几种-分别有什么特点"   >
          <a href="#java-并发类库提供的线程池有哪几种-分别有什么特点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java-并发类库提供的线程池有哪几种-分别有什么特点"></a> Java 并发类库提供的线程池有哪几种？ 分别有什么特点？</h3>
      
<p>通常开发者都是利用 Executors 提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的 ExecutorService 类型或者不同的初始参数。</p>
<p>Executors 目前提供了 5 种不同的线程池创建配置：</p>
<ul>
<li>newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。</li>
<li>newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。</li>
<li>newSingleThreadExecutor()，它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</li>
<li>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</li>
<li>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。</li>
</ul>

        <h3 id="atomicinteger底层实现原理是什么如何在自己的产品代码中应用cas操作"   >
          <a href="#atomicinteger底层实现原理是什么如何在自己的产品代码中应用cas操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#atomicinteger底层实现原理是什么如何在自己的产品代码中应用cas操作"></a> AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</h3>
      
<p>AtomicIntger 是对 int 类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于 CAS（compare-and-swap）技术。</p>
<p>所谓 CAS，表征的是一系列操作的集合，获取当前数值，进行一些运算，利用 CAS 指令试图进行更新。如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。</p>
<p>从 AtomicInteger 的内部属性可以看出，它依赖于 Unsafe 提供的一些底层能力，进行底层操作；以 volatile 的 value 字段，记录数值，以保证可见性。</p>
<p>具体的原子操作细节，可以参考任意一个原子更新方法，比如下面的 getAndIncrement。Unsafe 会利用 value 字段的内存地址偏移，直接完成操作。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>因为 getAndIncrement 需要返归数值，所以需要添加失败重试逻辑。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>而类似 compareAndSet 这种返回 boolean 类型的函数，因为其返回值表现的就是成功与否，所以不需要重试。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span></span></span><br></pre></td></tr></table></div></figure>
<p>CAS 是 Java 并发中所谓 lock-free 机制的基础。</p>

        <h3 id="请介绍类加载过程什么是双亲委派模型"   >
          <a href="#请介绍类加载过程什么是双亲委派模型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#请介绍类加载过程什么是双亲委派模型"></a> 请介绍类加载过程，什么是双亲委派模型？</h3>
      
<p>一般来说，我们把 Java 的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在Java 虚拟机规范里有非常详细的定义。</p>
<p>首先是加载阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。</p>
<p>第二阶段是链接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：</p>
<ul>
<li>验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。</li>
<li>准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。</li>
<li>解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在Java 虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析。</li>
</ul>
<p>最后是初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p>
<p>再来谈谈双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p>

        <h3 id="有哪些方法可以在运行时动态生成一个-java-类"   >
          <a href="#有哪些方法可以在运行时动态生成一个-java-类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#有哪些方法可以在运行时动态生成一个-java-类"></a> 有哪些方法可以在运行时动态生成一个 Java 类？</h3>
      
<p>我们可以从常见的 Java 类来源分析，通常的开发过程是，开发者编写 Java 代码，调用 javac 编译成 class 文件，然后通过类加载机制载入 JVM，就成为应用运行时可以使用的 Java 类了。</p>
<p>从上面过程得到启发，其中一个直接的方式是从源码入手，可以利用 Java 程序生成一段源码，然后保存到文件等，下面就只需要解决编译问题了。有一种笨办法，直接用 ProcessBuilder 之类启动 javac 进程，并指定上面生成的文件作为输入，进行编译。最后，再利用类加载器，在运行时加载即可。</p>
<p>前面的方法，本质上还是在当前程序进程之外编译的，那么还有没有不这么 low 的办法呢？</p>
<p>你可以考虑使用 Java Compiler API，这是 JDK 提供的标准 API，里面提供了与 javac 对等的编译器功能，具体请参考java.compiler相关文档。进一步思考，我们一直围绕 Java 源码编译成为 JVM 可以理解的字节码，换句话说，只要是符合 JVM 规范的字节码，不管它是如何生成的，是不是都可以被 JVM 加载呢？我们能不能直接生成相应的字节码，然后交给类加载器去加载呢？当然也可以，不过直接去写字节码难度太大，通常我们可以利用 Java 字节码操纵工具和类库来实现，比如在专栏第 6 讲中提到的ASM、Javassist、cglib 等。</p>

        <h3 id="谈谈-jvm-内存区域的划分哪些区域可能发生-outofmemoryerror"   >
          <a href="#谈谈-jvm-内存区域的划分哪些区域可能发生-outofmemoryerror" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#谈谈-jvm-内存区域的划分哪些区域可能发生-outofmemoryerror"></a> 谈谈 JVM 内存区域的划分，哪些区域可能发生 OutOfMemoryError？</h3>
      
<p>通常可以把 JVM 内存区域分为下面几个方面，其中，有的区域是以线程为单位，而有的区域则是整个 JVM 进程唯一的。</p>
<p>首先，程序计数器（PC，Program Counter Register）。在 JVM 规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。</p>
<p>第二，Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。</p>
<p>前面谈程序计数器时，提到了当前方法；同理，在一个时间点，对应的只会有一个活动的栈帧，通常叫作当前帧，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈。栈帧中存储着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等。</p>
<p>第三，堆（Heap），它是 Java 内存管理的核心区域，用来放置 Java 对象实例，几乎所有创建的 Java 对象实例都是被直接分配在堆上。堆被所有的线程共享，在虚拟机启动时，我们指定的“Xmx”之类参数就是用来指定最大堆空间等指标。理所当然，堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。</p>
<p>第四，方法区（Method Area）。这也是所有线程共享的一块内存区域，用于存储所谓的元（Meta）数据，例如类结构信息，以及对应的运行时常量池、字段、方法代码等。由于早期的 Hotspot JVM 实现，很多人习惯于将方法区称为永久代（Permanent Generation）。Oracle JDK 8 中将永久代移除，同时增加了元数据区（Metaspace）。</p>
<p>第五，运行时常量池（Run-Time Constant Pool），这是方法区的一部分。如果仔细分析过反编译的类文件结构，你能看到版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池。Java 的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。</p>
<p>第六，本地方法栈（Native Method Stack）。它和 Java 虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个。在 Oracle Hotspot JVM 中，本地方法栈和 Java 虚拟机栈是在同一块儿区域，这完全取决于技术实现的决定，并未在规范中强制。</p>

        <h3 id="如何监控和诊断jvm堆内和堆外内存使用"   >
          <a href="#如何监控和诊断jvm堆内和堆外内存使用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#如何监控和诊断jvm堆内和堆外内存使用"></a> 如何监控和诊断JVM堆内和堆外内存使用？</h3>
      
<p>可以使用综合性的图形化工具，如 JConsole、VisualVM（注意，从 Oracle JDK 9 开始，VisualVM 已经不再包含在 JDK 安装包中）等。这些工具具体使用起来相对比较直观，直接连接到 Java 进程，然后就可以在图形化界面里掌握内存使用情况。</p>
<p>以 JConsole 为例，其内存页面可以显示常见的堆内存和各种堆外部分使用状态。也可以使用命令行工具进行运行时查询，如 jstat 和 jmap 等工具都提供了一些选项，可以查看堆、方法区等使用数据。或者，也可以使用 jmap 等提供的命令，生成堆转储（Heap Dump）文件，然后利用 jhat 或 Eclipse MAT 等堆转储分析工具进行详细分析。如果你使用的是 Tomcat、Weblogic 等 Java EE 服务器，这些服务器同样提供了内存管理相关的功能。另外，从某种程度上来说，GC 日志等输出，同样包含着丰富的信息。</p>
<p>这里有一个相对特殊的部分，就是是堆外内存中的直接内存，前面的工具基本不适用，可以使用 JDK 自带的 Native Memory Tracking（NMT）特性，它会从 JVM 本地内存分配的角度进行解读。</p>

        <h3 id="java-常见的垃圾收集器有哪些"   >
          <a href="#java-常见的垃圾收集器有哪些" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java-常见的垃圾收集器有哪些"></a> Java 常见的垃圾收集器有哪些？</h3>
      
<p>实际上，垃圾收集器（GC，Garbage Collector）是和具体 JVM 实现紧密相关的，不同厂商（IBM、Oracle），不同版本的 JVM，提供的选择也不同。接下来，我来谈谈最主流的 Oracle JDK。</p>
<p>Serial GC，它是最古老的垃圾收集器，“Serial”体现在其收集工作是单线程的，并且在进行垃圾收集过程中，会进入臭名昭著的“Stop-The-World”状态。当然，其单线程设计也意味着精简的 GC 实现，无需维护复杂的数据结构，初始化也简单，所以一直是 Client 模式下 JVM 的默认选项。从年代的角度，通常将其老年代实现单独称作 Serial Old，它采用了标记 - 整理（Mark-Compact）算法，区别于新生代的复制算法。</p>
<p>ParNew GC，很明显是个新生代 GC 实现，它实际是 Serial GC 的多线程版本，最常见的应用场景是配合老年代的 CMS GC 工作，下面是对应参数</p>
<p>CMS（Concurrent Mark Sweep） GC，基于标记 - 清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于 Web 等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用 CMS GC。但是，CMS 采用的标记 - 清除算法，存在着内存碎片化问题，所以难以避免在长时间运行等情况下发生 full GC，导致恶劣的停顿。另外，既然强调了并发（Concurrent），CMS 会占用更多 CPU 资源，并和用户线程争抢。</p>
<p>Parallel GC，在早期 JDK 8 等版本中，它是 server 模式 JVM 的默认 GC 选择，也被称作是吞吐量优先的 GC。它的算法和 Serial GC 比较相似，尽管实现要复杂的多，其特点是新生代和老年代 GC 都是并行进行的，在常见的服务器环境中更加高效。</p>
<p>G1 GC 这是一种兼顾吞吐量和停顿时间的 GC 实现，是 Oracle JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。G1 吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时 CMS 已经在 JDK 9 中被标记为废弃（deprecated），所以 G1 GC 值得你深入掌握。</p>

        <h3 id="谈谈你的-gc-调优思路"   >
          <a href="#谈谈你的-gc-调优思路" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#谈谈你的-gc-调优思路"></a> 谈谈你的 GC 调优思路？</h3>
      
<p>谈到调优，这一定是针对特定场景、特定目的的事情， 对于 GC 调优来说，首先就需要清楚调优的目标是什么？从性能的角度看，通常关注三个方面，内存占用（footprint）、延时（latency）和吞吐量（throughput），大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。当然，除了上面通常的三个方面，也可能需要考虑其他 GC 相关的场景，例如，OOM 也可能与不合理的 GC 相关参数有关；或者，应用启动速度方面的需求，GC 也会是个考虑的方面。</p>
<p>基本的调优思路可以总结为：</p>
<ul>
<li>理解应用需求和问题，确定调优目标。假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。</li>
<li>掌握 JVM 和 GC 的状态，定位具体的问题，确定真的有 GC 调优的必要。具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。</li>
<li>这里需要思考，选择的 GC 类型是否符合我们的应用特征，如果是，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。</li>
<li>通过分析确定具体调整的参数或者软硬件配置。</li>
<li>验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。</li>
</ul>

        <h3 id="java-内存模型中的-happen-before-是什么"   >
          <a href="#java-内存模型中的-happen-before-是什么" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java-内存模型中的-happen-before-是什么"></a> Java 内存模型中的 happen-before 是什么？</h3>
      
<p>Happen-before 关系，是 Java 内存模型中保证多线程操作可见性的机制，也是对早期语言规范中含糊的可见性概念的一个精确定义。它的具体表现形式，包括但远不止是我们直觉中的 synchronized、volatile、lock 操作顺序等方面，例如：</p>
<ul>
<li>线程内执行的每个操作，都保证 happen-before 后面的操作，这就保证了基本的程序顺序规则，这是开发者在书写程序时的基本约定。</li>
<li>对于 volatile 变量，对它的写操作，保证 happen-before 在随后对该变量的读取操作。</li>
<li>对于一个锁的解锁操作，保证 happen-before 加锁操作。</li>
<li>对象构建完成，保证 happen-before 于 finalizer 的开始动作。</li>
<li>甚至是类似线程内部操作的完成，保证 happen-before 其他 Thread.join() 的线程等。</li>
</ul>
<p>这些 happen-before 关系是存在着传递性的，如果满足 a happen-before b 和 b happen-before c，那么 a happen-before c 也成立。前面我一直用 happen-before，而不是简单说前后，是因为它不仅仅是对执行时间的保证，也包括对内存读、写操作顺序的保证。仅仅是时钟顺序上的先后，并不能保证线程交互的可见性。</p>

        <h3 id="java-程序运行在-docker-等容器环境有哪些新问题"   >
          <a href="#java-程序运行在-docker-等容器环境有哪些新问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java-程序运行在-docker-等容器环境有哪些新问题"></a> Java 程序运行在 Docker 等容器环境有哪些新问题？</h3>
      
<p>对于 Java 来说，Docker 毕竟是一个较新的环境，例如，其内存、CPU 等资源限制是通过 CGroup（Control Group）实现的，早期的 JDK 版本（8u131 之前）并不能识别这些限制，进而会导致一些基础问题：</p>
<ul>
<li>如果未配置合适的 JVM 堆和元数据区、直接内存等参数，Java 就有可能试图使用超过容器限制的内存，最终被容器 OOM kill，或者自身发生 OOM。</li>
<li>错误判断了可获取的 CPU 资源，例如，Docker 限制了 CPU 的核数，JVM 就可能设置不合适的 GC 并行线程数等。</li>
</ul>
<p>从应用打包、发布等角度出发，JDK 自身就比较大，生成的镜像就更为臃肿，当我们的镜像非常多的时候，镜像的存储等开销就比较明显了。</p>
<p>如果考虑到微服务、Serverless 等新的架构和场景，Java 自身的大小、内存占用、启动速度，都存在一定局限性，因为 Java 早期的优化大多是针对长时间运行的大型服务器端应用。</p>

        <h2 id="java-性能基础"   >
          <a href="#java-性能基础" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java-性能基础"></a> Java 性能基础</h2>
      

        <h3 id="后台服务出现明显变慢谈谈你的诊断思路"   >
          <a href="#后台服务出现明显变慢谈谈你的诊断思路" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#后台服务出现明显变慢谈谈你的诊断思路"></a> 后台服务出现明显“变慢”，谈谈你的诊断思路？</h3>
      
<p>首先，需要对这个问题进行更加清晰的定义：</p>
<ul>
<li>服务是突然变慢还是长时间运行后观察到变慢？类似问题是否重复出现？</li>
<li>“慢”的定义是什么，我能够理解是系统对其他方面的请求的反应延时变长吗?</li>
</ul>
<p>第二，理清问题的症状，这更便于定位具体的原因，有以下一些思路：</p>
<ul>
<li>问题可能来自于 Java 服务自身，也可能仅仅是受系统里其他服务的影响。初始判断可以先确认是否出现了意外的程序错误，例如检查应用本身的错误日志。对于分布式系统，很多公司都会实现更加系统的日志、性能等监控系统。一些 Java 诊断工具也可以用于这个诊断，例如通过 JFR（Java Flight Recorder），监控应用是否大量出现了某种类型的异常。
<ul>
<li>如果有，那么异常可能就是个突破点。</li>
<li>如果没有，可以先检查系统级别的资源等情况，监控 CPU、内存等资源是否被其他进程大量占用，并且这种占用是否不符合系统正常运行状况。</li>
</ul>
</li>
<li>监控 Java 服务自身，例如 GC 日志里面是否观察到 Full GC 等恶劣情况出现，或者是否 Minor GC 在变长等；利用 jstat 等工具，获取内存使用的统计信息也是个常用手段；利用 jstack 等工具检查是否出现死锁等。</li>
</ul>
<p>如果还不能确定具体问题，对应用进行 Profiling 也是个办法，但因为它会对系统产生侵入性，如果不是非常必要，大多数情况下并不建议在生产系统进行。</p>
<p>定位了程序错误或者 JVM 配置的问题后，就可以采取相应的补救措施，然后验证是否解决，否则还需要重复上面部分过程。</p>

        <h3 id="有人说lambda-能让-java-程序慢-30-倍你怎么看"   >
          <a href="#有人说lambda-能让-java-程序慢-30-倍你怎么看" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#有人说lambda-能让-java-程序慢-30-倍你怎么看"></a> 有人说“Lambda 能让 Java 程序慢 30 倍”，你怎么看？</h3>
      
<p>我认为，“Lambda 能让 Java 程序慢 30 倍”这个争论实际反映了几个方面：</p>
<ul>
<li>第一，基准测试是一个非常有效的通用手段，让我们以直观、量化的方式，判断程序在特定条件下的性能表现。</li>
<li>第二，基准测试必须明确定义自身的范围和目标，否则很有可能产生误导的结果。前面代码片段本身的逻辑就有瑕疵，更多的开销是源于自动装箱、拆箱（auto-boxing/unboxing），而不是源自 Lambda 和 Stream，所以得出的初始结论是没有说服力的。</li>
<li>第三，虽然 Lambda/Stream 为 Java 提供了强大的函数式编程能力，但是也需要正视其局限性：
<ul>
<li>一般来说，我们可以认为 Lambda/Stream 提供了与传统方式接近对等的性能，但是如果对于性能非常敏感，就不能完全忽视它在特定场景的性能差异了，例如：初始化的开销。 Lambda 并不算是语法糖，而是一种新的工作机制，在首次调用时，JVM 需要为其构建CallSite实例。这意味着，如果 Java 应用启动过程引入了很多 Lambda 语句，会导致启动过程变慢。其实现特点决定了 JVM 对它的优化可能与传统方式存在差异。</li>
<li>增加了程序诊断等方面的复杂性，程序栈要复杂很多，Fluent 风格本身也不算是对于调试非常友好的结构，并且在可检查异常的处理方面也存在着局限性等。</li>
</ul>
</li>
</ul>

        <h3 id="jvm-优化-java-代码时都做了什么"   >
          <a href="#jvm-优化-java-代码时都做了什么" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jvm-优化-java-代码时都做了什么"></a> JVM 优化 Java 代码时都做了什么？</h3>
      
<p>JVM 在对代码执行的优化可分为运行时（runtime）优化和即时编译器（JIT）优化。运行时优化主要是解释执行和动态编译通用的一些机制，比如说锁机制（如偏斜锁）、内存分配机制（如 TLAB）等。除此之外，还有一些专门用于优化解释执行效率的，比如说模版解释器、内联缓存（inline cache，用于优化虚方法调用的动态绑定）。</p>
<p>JVM 的即时编译器优化是指将热点代码以方法为单位转换成机器码，直接运行在底层硬件之上。它采用了多种优化方式，包括静态编译器可以使用的如方法内联、逃逸分析，也包括基于程序运行 profile 的投机性优化（speculative/optimistic optimization）。这个怎么理解呢？比如我有一条 instanceof 指令，在编译之前的执行过程中，测试对象的类一直是同一个，那么即时编译器可以假设编译之后的执行过程中还会是这一个类，并且根据这个类直接返回 instanceof 的结果。如果出现了其他类，那么就抛弃这段编译后的机器码，并且切换回解释执行。</p>
<p>当然，JVM 的优化方式仅仅作用在运行应用代码的时候。如果应用代码本身阻塞了，比如说并发时等待另一线程的结果，这就不在 JVM 的优化范畴啦。</p>

        <h2 id="java-应用开发扩展"   >
          <a href="#java-应用开发扩展" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java-应用开发扩展"></a> Java 应用开发扩展</h2>
      

        <h3 id="谈谈-mysql-支持的事务隔离级别以及悲观锁和乐观锁的原理和应用场景"   >
          <a href="#谈谈-mysql-支持的事务隔离级别以及悲观锁和乐观锁的原理和应用场景" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#谈谈-mysql-支持的事务隔离级别以及悲观锁和乐观锁的原理和应用场景"></a> 谈谈 MySQL 支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？</h3>
      
<p>所谓隔离级别（Isolation Level），就是在数据库事务中，为保证并发数据读写的正确性而提出的定义，它并不是 MySQL 专有的概念，而是源于ANSI/ISO制定的SQL-92标准。</p>
<p>每种关系型数据库都提供了各自特色的隔离级别实现，虽然在通常的定义中是以锁为实现单元，但实际的实现千差万别。以最常见的 MySQL InnoDB 引擎为例，它是基于 MVCC（Multi-Versioning Concurrency Control）和锁的复合实现，按照隔离程度从低到高，MySQL 事务隔离级别分为四个不同层次：</p>
<ul>
<li>读未提交（Read uncommitted），就是一个事务能够看到其他事务尚未提交的修改，这是最低的隔离水平，允许脏读出现。</li>
<li>读已提交（Read committed），事务能够看到的数据都是其他事务已经提交的修改，也就是保证不会看到任何中间性状态，当然脏读也不会出现。读已提交仍然是比较低级别的隔离，并不保证再次读取时能够获取同样的数据，也就是允许其他事务并发修改数据，允许不可重复读和幻象读（Phantom Read）出现。</li>
<li>可重复读（Repeatable reads），保证同一个事务中多次读取的数据是一致的，这是 MySQL InnoDB 引擎的默认隔离级别，但是和一些其他数据库实现不同的是，可以简单认为 MySQL 在可重复读级别不会出现幻象读。</li>
<li>串行化（Serializable），并发事务之间是串行化的，通常意味着读取需要获取共享读锁，更新需要获取排他写锁，如果 SQL 使用 WHERE 语句，还会获取区间锁（MySQL 以 GAP 锁形式实现，可重复读级别中默认也会使用），这是最高的隔离级别。</li>
</ul>
<p>至于悲观锁和乐观锁，也并不是 MySQL 或者数据库中独有的概念，而是并发编程的基本概念。主要区别在于，操作共享数据时，“悲观锁”即认为数据出现冲突的可能性更大，而“乐观锁”则是认为大部分情况不会出现冲突，进而决定是否采取排他性措施。</p>
<p>反映到 MySQL 数据库应用开发中，悲观锁一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。乐观锁则与 Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p>
<p>我认为前面提到的 MVCC，其本质就可以看作是种乐观锁机制，而排他性的读写锁、双阶段锁等则是悲观锁的实现。</p>
<p>有关它们的应用场景，你可以构建一下简化的火车余票查询和购票系统。同时查询的人可能很多，虽然具体座位票只能是卖给一个人，但余票可能很多，而且也并不能预测哪个查询者会购票，这个时候就更适合用乐观锁。</p>

        <h3 id="谈谈-spring-bean-的生命周期和作用域"   >
          <a href="#谈谈-spring-bean-的生命周期和作用域" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#谈谈-spring-bean-的生命周期和作用域"></a> 谈谈 Spring Bean 的生命周期和作用域？</h3>
      
<p>Spring Bean 生命周期比较复杂，可以分为创建和销毁两个过程。</p>
<p>首先，创建 Bean 会经过一系列的步骤，主要包括：</p>
<ul>
<li>实例化 Bean 对象。</li>
<li>设置 Bean 属性。</li>
<li>如果我们通过各种 Aware 接口声明了依赖关系，则会注入 Bean 对容器基础设施层面的依赖。具体包括 BeanNameAware、BeanFactoryAware 和 ApplicationContextAware，分别会注入 Bean ID、Bean Factory 或者 ApplicationContext。</li>
<li>调用 BeanPostProcessor 的前置初始化方法 postProcessBeforeInitialization。</li>
<li>如果实现了 InitializingBean 接口，则会调用 afterPropertiesSet 方法。调用 Bean 自身定义的 init 方法。</li>
<li>调用 BeanPostProcessor 的后置初始化方法 postProcessAfterInitialization。</li>
<li>创建过程完毕。</li>
</ul>
<p><img src="../images/%E3%80%90Java%E3%80%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/3a51f06f56b905b8fbf1661359e1727e.png" alt="img" /></p>
<p>第二，Spring Bean 的销毁过程会依次调用 DisposableBean 的 destroy 方法和 Bean 自身定制的 destroy 方法。</p>
<p>Spring Bean 有五个作用域，其中最基础的有下面两种：</p>
<ul>
<li>Singleton，这是 Spring 的默认作用域，也就是为每个 IOC 容器创建唯一的一个 Bean 实例。</li>
<li>Prototype，针对每个 getBean 请求，容器都会单独创建一个 Bean 实例。</li>
</ul>
<p>从 Bean 的特点来看，Prototype 适合有状态的 Bean，而 Singleton 则更适合无状态的情况。另外，使用 Prototype 作用域需要经过仔细思考，毕竟频繁创建和销毁 Bean 是有明显开销的。</p>
<p>如果是 Web 容器，则支持另外三种作用域：</p>
<ul>
<li>Request，为每个 HTTP 请求创建单独的 Bean 实例。</li>
<li>Session，很显然 Bean 实例的作用域是 Session 范围。</li>
<li>GlobalSession，用于 Portlet 容器，因为每个 Portlet 有单独的 Session，GlobalSession 提供一个全局性的 HTTP Session。</li>
</ul>

        <h3 id="对比-java-标准-nio-类库你知道-netty-是如何实现更高性能的吗"   >
          <a href="#对比-java-标准-nio-类库你知道-netty-是如何实现更高性能的吗" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对比-java-标准-nio-类库你知道-netty-是如何实现更高性能的吗"></a> 对比 Java 标准 NIO 类库，你知道 Netty 是如何实现更高性能的吗？</h3>
      
<p>单独从性能角度，Netty 在基础的 NIO 等类库之上进行了很多改进，例如：</p>
<ul>
<li>更加优雅的 Reactor 模式实现、灵活的线程模型、利用 EventLoop 等创新性的机制，可以非常高效地管理成百上千的 Channel。</li>
<li>充分利用了 Java 的 Zero-Copy 机制，并且从多种角度，“斤斤计较”般的降低内存分配和回收的开销。例如，使用池化的 Direct Buffer 等技术，在提高 IO 性能的同时，减少了对象的创建和销毁；利用反射等技术直接操纵 SelectionKey，使用数组而不是 Java 容器等。</li>
<li>使用更多本地代码。例如，直接利用 JNI 调用 Open SSL 等方式，获得比 Java 内建 SSL 引擎更好的性能。</li>
<li>在通信协议、序列化等其他角度的优化。用 JNI 调用 Open SSL 等方式，获得比 Java 内建 SSL 引擎更好的性能。</li>
</ul>
<p>总的来说，Netty 并没有 Java 核心类库那些强烈的通用性、跨平台等各种负担，针对性能等特定目标以及 Linux 等特定环境，采取了一些极致的优化手段。</p>

        <h3 id="谈谈常用的分布式-id-的设计方案snowflake-是否受冬令时切换影响"   >
          <a href="#谈谈常用的分布式-id-的设计方案snowflake-是否受冬令时切换影响" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#谈谈常用的分布式-id-的设计方案snowflake-是否受冬令时切换影响"></a> 谈谈常用的分布式 ID 的设计方案？Snowflake 是否受冬令时切换影响？</h3>
      
<p>首先，我们需要明确通常的分布式 ID 定义，基本的要求包括：</p>
<ul>
<li>全局唯一，区别于单点系统的唯一，全局是要求分布式系统内唯一。</li>
<li>有序性，通常都需要保证生成的 ID 是有序递增的。例如，在数据库存储等场景中，有序 ID 便于确定数据位置，往往更加高效。</li>
</ul>
<p>目前业界的方案很多，典型方案包括：</p>
<ul>
<li>基于数据库自增序列的实现。这种方式优缺点都非常明显，好处是简单易用，但是在扩展性和可靠性等方面存在局限性。</li>
<li>基于 Twitter 早期开源的Snowflake的实现，以及相关改动方案。这是目前应用相对比较广泛的一种方式，其结构定义你可以参考下面的示意图。</li>
</ul>
<p><img src="../images/%E3%80%90Java%E3%80%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/ffd41494a39ef737b3c1151929c3c4ad.png" alt="img" /></p>
<p>整体长度通常是 64 （1 + 41 + 10+ 12 = 64）位，适合使用 Java 语言中的 long 类型来存储。头部是 1 位的正负标识位。紧跟着的高位部分包含 41 位时间戳，通常使用 System.currentTimeMillis()。后面是 10 位的 WorkerID，标准定义是 5 位数据中心 + 5 位机器 ID，组成了机器编号，以区分不同的集群节点。最后的 12 位就是单位毫秒内可生成的序列号数目的理论极限。</p>
<p>Snowflake 的官方版本是基于 Scala 语言，Java 等其他语言的参考实现有很多，是一种非常简单实用的方式，具体位数的定义是可以根据分布式系统的真实场景进行修改的，并不一定要严格按照示意图中的设计。</p>
<ul>
<li>Redis、ZooKeeper、MongoDB 等中间件，也都有各种唯一 ID 解决方案。其中一些设计也可以算作是 Snowflake 方案的变种。例如，MongoDB 的ObjectId提供了一个 12 byte（96 位）的 ID 定义，其中 32 位用于记录以秒为单位的时间，机器 ID 则为 24 位，16 位用作进程 ID，24 位随机起始的计数序列。</li>
<li>国内的一些大厂开源了其自身的部分分布式 ID 实现，InfoQ 就曾经介绍过微信的seqsvr，它采取了相对复杂的两层架构，并根据社交应用的数据特点进行了针对性设计，具体请参考相关代码实现。另外，百度、美团等也都有开源或者分享了不同的分布式 ID 实现，都可以进行参考。</li>
</ul>
<p>关于第二个问题，Snowflake 是否受冬令时切换影响？</p>
<p>我认为没有影响，你可以从 Snowflake 的具体算法实现寻找答案。我们知道 Snowflake 算法的 Java 实现，大都是依赖于 System.currentTimeMillis()，这个数值代表什么呢？从 Javadoc 可以看出，它是返回当前时间和 1970 年 1 月 1 号 UTC 时间相差的毫秒数，这个数值与夏 / 冬令时并没有关系，所以并不受其影响。</p>

        <h2 id="问题"   >
          <a href="#问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2>
      

        <h3 id="动态类型语言和静态类型语言"   >
          <a href="#动态类型语言和静态类型语言" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#动态类型语言和静态类型语言"></a> 动态类型语言和静态类型语言</h3>
      
<p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
<blockquote>
<p>Java：String info = “mogu blog”; (Java是静态类型语言的，会先编译就进行类型检查)</p>
<p>JS：var name = “shkstart”; var name = 10; （运行时才进行检查）</p>
</blockquote>

        <h3 id="虚方法表"   >
          <a href="#虚方法表" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#虚方法表"></a> 虚方法表</h3>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://blog.yuyunzhao.cn/2021/09/23/%E3%80%90JVM%E3%80%91JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/#%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8" >http://blog.yuyunzhao.cn/2021/09/23/【JVM】JVM虚拟机栈/#虚方法表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个<strong>虚方法表</strong>（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>

        <h3 id="思考幸存者区满了以后如何操作"   >
          <a href="#思考幸存者区满了以后如何操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#思考幸存者区满了以后如何操作"></a> 思考：幸存者区满了以后如何操作？</h3>
      
<p>特别注意，<strong>只有在Eden区满了的时候，才会触发Minor GC，而幸存者区满了后，不会主动触发Minor GC操作</strong>，只能被动触发：Eden区满了，会连同幸存者区一起进行Minor GC。</p>
<p>如果幸存者区在GC时发现还是满了， 那么数据会直接放到老年代。</p>

        <h3 id="大对象的存放"   >
          <a href="#大对象的存放" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#大对象的存放"></a> 大对象的存放</h3>
      
<p>JVM</p>

        <h3 id="classloaderloadclassxxx"   >
          <a href="#classloaderloadclassxxx" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#classloaderloadclassxxx"></a> classLoader.loadClass(“xxx”)</h3>
      
<p>只会加载，不会解析和初始化</p>

        <h3 id="string-字面量的创建时机"   >
          <a href="#string-字面量的创建时机" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#string-字面量的创建时机"></a> String 字面量的创建时机</h3>
      
<ul>
<li>
<p>字面量形式的对象在程序启动加载阶段就已经被创建好放到了字符串常量池中，而不是等到执行该方法时才创建</p>
</li>
<li>
<p>字面量形式没有再 new 一个对象，而是把字符串常量池里已经存在的对象的地址赋给了引用对象 a</p>
</li>
<li>
<p><strong>只要其中有一个是变量，结果就在堆中</strong>。原理是底层创建了一个 <code>StringBuilder</code> 对象，将字符串拼接完毕后返回了一个存储在堆中的 <code>String</code> 类型对象</p>
</li>
</ul>
<p>String 对象在 replace 等操作都是重新创建一个新的 String 对象并返回。</p>

        <h3 id="字符串拼接操作"   >
          <a href="#字符串拼接操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#字符串拼接操作"></a> 字符串拼接操作</h3>
      
<ul>
<li>常量与常量的拼接结果在常量池，原理是<strong>编译期优化</strong></li>
<li>常量池中不会存在相同内容的变量</li>
<li><strong>只要其中有一个是变量，结果就在堆中</strong>。变量拼接的原理是使用 <code>StringBuilder</code> 将两个 String 中的 <code>char[]</code> 数组拼接起来，创建一个新的对象存放合并后的 <code>char[]</code></li>
<li>如果拼接的结果调用 <code>intern()</code> 方法，则<strong>主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</strong></li>
</ul>

        <h3 id="为什么字符串常量池在-jdk-17-后移动到了堆内"   >
          <a href="#为什么字符串常量池在-jdk-17-后移动到了堆内" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#为什么字符串常量池在-jdk-17-后移动到了堆内"></a> 为什么字符串常量池在 JDK 1.7 后移动到了堆内</h3>
      
<blockquote>
<p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p>
</blockquote>
<p>为了堆内 GC 时可以清楚不使用的字符串字面量。为了调优方便</p>
<p>为什么要调整位置？</p>
<ul>
<li>永久代的默认空间大小比较小</li>
<li>永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生<code>OOM：PermGen Space</code></li>
<li>堆中空间足够大，字符串可被及时回收</li>
</ul>

        <h3 id="stringbuildertostring"   >
          <a href="#stringbuildertostring" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#stringbuildertostring"></a> StringBuilder.toString()</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>)</span><br></pre></td></tr></table></div></figure>
<p>强调一下，toString()的调用，在字符串常量池中，没有生成 “ab”。而是直接在堆中生成一个 String 对象，其内存储着 <code>char[] = &#123;'a', 'b'&#125;</code></p>
<p>这是因为 <code>StringBuilder</code> 的拼接机制是在<strong>运行期间动态执行</strong>的，因此编译器无法事先知道拼接后的字符串值是什么，也就无法在 JVM 启动时提前将字面量加载到字符串常量池里，从而只能直接在堆中存储该字符串对象的值。而静态的拼接方式是可以事先得知并存储在字符串常量池中的。</p>
<p>源码解释：<code>StringBuilder</code> 的 <code>toString()</code>方法是直接将其内维护的 <code>char[] value</code>数组内的元素通过构造器赋值给新建的 String 对象，而并没有以字面量的形式出现这个拼接后的字符串，因此不会在字符串常量池中创建 <code>&quot;ab&quot;</code> 对象，只有通过 <code>intern()</code> 方法才会将该对象存储到常量池中。</p>
<p><img src="/images/%E3%80%90Java%E3%80%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/0012.png" alt="img" /></p>

        <h2 id="框架篇"   >
          <a href="#框架篇" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#框架篇"></a> 框架篇</h2>
      

        <h3 id="spring-介绍"   >
          <a href="#spring-介绍" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#spring-介绍"></a> Spring 介绍</h3>
      
<p>Spring 是一个快速开发框架，帮助程序员管理对象（IOC机制）：帮助程序员 new 对象，管理对象间的依赖，进行对象销毁。</p>
<p>周瑜的 Spring 源码课程。</p>
<p>启动流程：</p>
<p>原型bean，懒加载的单例bean都不需要在启动时加载</p>
<p>AOP 可以加日志。Controller 层的异常处理 JSR303</p>

        <h2 id="分布式篇"   >
          <a href="#分布式篇" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#分布式篇"></a> 分布式篇</h2>
      

        <h3 id="项目中分布式锁的设计方案"   >
          <a href="#项目中分布式锁的设计方案" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#项目中分布式锁的设计方案"></a> 项目中分布式锁的设计方案</h3>
      
<p>最终项目使用<strong>RedissonClient</strong>操作分布式锁，保证加锁/设置过期时间操作的原子性；删除/判断uuid操作的原子性。思路：</p>
<ul>
<li>先查看缓存中是否有该数据，如果有就返回</li>
<li>如果没有，先加分布式锁，然后再去数据库里查数据。而不应该先加锁再查缓存</li>
</ul>
<p>其中，Redisson将在Redis缓存中创建一个锁（<strong>Hash</strong>结构），其key值为<code>&quot;catalogJson-lock&quot;</code>，其内存储了<code>key = uuid:线程号, value = 1</code>，代表当前线程对象拥有了该锁。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先查询缓存是否存在，如果存在就直接返回，否则先加上分布式锁，然后再去数据库里查</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJsonWithRedis() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 空结果缓存（或布隆过滤器）：解决缓存穿透</span></span><br><span class="line"><span class="comment">     * 2. 设置过期时间（加随机值）：解决缓存雪崩</span></span><br><span class="line"><span class="comment">     * 3. 加锁：解决缓存击穿</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 序列化：先将Java对象转成JSON字符串，然后向缓存中存储JSON字符串，</span></span><br><span class="line">    <span class="comment">// 反序列化：读取时也是读取出JSON字符串，再转成Java对象使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 先查询是否有缓存</span></span><br><span class="line">    String cache = redisTemplate.opsForValue().get(<span class="string">&quot;catalogJSON&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(cache)) &#123;</span><br><span class="line">        <span class="comment">// 2. 缓存如果没命中，先加上分布式锁，然后再去数据库里查数据</span></span><br><span class="line">        Map&lt;String, List&lt;Catalog2Vo&gt;&gt; catalogJson = getCatalogJsonFromDBWithRedissonLock();</span><br><span class="line">        <span class="comment">// 将Java对象转换成JSON字符串</span></span><br><span class="line">        String s = JSON.toJSONString(catalogJson);</span><br><span class="line">        <span class="comment">// 3. 将查询到的数据放入缓存</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;catalogJSON&quot;</span>, s);</span><br><span class="line">        <span class="keyword">return</span> catalogJson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓存中的JSON字符串转换成实际对象。其中，TypeReference 以匿名内部类的形式创建</span></span><br><span class="line">    Map&lt;String, List&lt;Catalog2Vo&gt;&gt; result = JSON.parseObject(cache, <span class="keyword">new</span> TypeReference&lt;Map&lt;String, List&lt;Catalog2Vo&gt;&gt;&gt;() &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果Redis中缓存不存在，先加上分布式锁，然后再查数据库 </span></span><br><span class="line"><span class="comment"> * 使用Redisson操作分布式锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJsonFromDBWithRedissonLock() &#123;</span><br><span class="line">    <span class="comment">// 1. 原子性加锁，其内会自动设置过期时间（看门狗+自动续期机制）。也可以手动指定过期时间</span></span><br><span class="line">    RLock lock = redissonClient.getLock(<span class="string">&quot;catalogJson-lock&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, List&lt;Catalog2Vo&gt;&gt; catalogJsonFromDB;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 加锁后，去数据库里查数据</span></span><br><span class="line">        catalogJsonFromDB = getCatalogJsonFromDB();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 最后原子性解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> catalogJsonFromDB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="redisson-分布式锁的实现原理"   >
          <a href="#redisson-分布式锁的实现原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redisson-分布式锁的实现原理"></a> Redisson 分布式锁的实现原理</h3>
      
<p>不手动指定过期时间，使用<strong>看门狗默认的过期时间 + 自动续期策略</strong>：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redisson 是上文中注入到容器中的 RedissonClient 对象</span></span><br><span class="line">RLock lock = redisson.getLock(<span class="string">&quot;catalogJson-lock&quot;</span>);  <span class="comment">// 设置锁名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁，若其他线程发现该锁已经被锁上，则阻塞式等待其他线程解锁后才继续运行</span></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 业务...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 严谨的写法：</span></span><br><span class="line">    <span class="keyword">if</span> (lock.isLocked() &amp;&amp; lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>流程：</p>
<ul>
<li>当前线程在执行 <code>lock()</code> 后，将在Redis缓存中创建一个锁（<strong>Hash</strong>结构），其key值为<code>&quot;catalogJson-lock&quot;</code>，其内存储了<code>key = uuid:线程号, value = 1</code>，代表当前线程对象拥有了该锁；</li>
<li>此时其他线程再调用<code>lock()</code> 时将发现Redis缓存中已经存在了<code>&quot;myLock&quot;</code>锁，因此会<strong>阻塞等待</strong>（<code>while(true)</code>循环判断锁是否还在）；</li>
<li>等待当前线程调用 <code>unlock()</code> 后，该<code>&quot;catalogJson-lock&quot;</code>锁将从Redis缓存中移除，此时其他线程才可以结束阻塞，创建另一把锁，即再在Redis缓存中创建一个<code>&quot;catalogJson-lock&quot;</code> 。</li>
</ul>
<p>上述方式的细节：</p>
<ul>
<li>锁的<strong>自动续期</strong>：如果业务超长，运行期间自动会给锁续期到30s，不用担心业务时间长，锁自动过期被删掉。</li>
<li>加锁的业务只要<strong>运行完成</strong>，就不会给当前锁续期，即使不手动解锁，锁也默认也会在30s后自动删除。</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://yuyun-zhao.github.io">yuyun zhao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://yuyun-zhao.github.io/2021/04/25/%E3%80%90Java%E3%80%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">http://yuyun-zhao.github.io/2021/04/25/%E3%80%90Java%E3%80%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.github.io/tags/Java/">Java</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/04/25/%E3%80%90Java%E3%80%91%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">【Java】代理模式</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/04/23/%E3%80%90Spring%E3%80%91Spring5-%E6%B1%87%E6%80%BB/"><span class="paginator-prev__text">【Spring】Spring 汇总</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E5%9F%BA%E7%A1%80"><span class="toc-text">
           Java 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-java-%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%90%86%E8%A7%A3java-%E6%98%AF%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E8%BF%99%E5%8F%A5%E8%AF%9D%E6%AD%A3%E7%A1%AE%E5%90%97"><span class="toc-text">
           谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E5%AF%B9%E6%AF%94-exception-%E5%92%8C-error%E5%8F%A6%E5%A4%96%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%80%E8%88%AC%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">
           请对比 Exception 和 Error，另外，运行时异常与一般异常有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88final-finally-finalize%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-text">
           谈谈final、finally、 finalize有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8-%E8%BD%AF%E5%BC%95%E7%94%A8-%E5%BC%B1%E5%BC%95%E7%94%A8-%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">
           强引用、软引用、弱引用、幻象引用有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-stringbuffer-stringbuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">
           String、StringBuffer、StringBuilder有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86"><span class="toc-text">
           谈谈 Java 反射机制，动态代理是基于什么原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int-%E5%92%8C-integer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E8%B0%88%E8%B0%88-integer-%E7%9A%84%E5%80%BC%E7%BC%93%E5%AD%98%E8%8C%83%E5%9B%B4"><span class="toc-text">
           int 和 Integer 有什么区别？谈谈 Integer 的值缓存范围。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-vector-arraylist-linkedlist-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="toc-text">
           对比 Vector、ArrayList、LinkedList 有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-hashtable-hashmap-treemap-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-hashmap-%E7%9A%84%E6%8E%8C%E6%8F%A1"><span class="toc-text">
           对比 Hashtable、HashMap、TreeMap 有什么不同？谈谈你对 HashMap 的掌握</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%B9%E5%99%A8%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84concurrenthashmap-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%9C%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">
           如何保证容器是线程安全的？ConcurrentHashMap 如何实现高效地线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B-io-%E6%96%B9%E5%BC%8F-nio-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">
           Java 提供了哪些 IO 方式？ NIO 如何实现多路复用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F%E5%93%AA%E4%B8%80%E7%A7%8D%E6%9C%80%E9%AB%98%E6%95%88"><span class="toc-text">
           Java有几种文件拷贝方式？哪一种最高效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">
           谈谈接口和抽象类有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%B7%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8Fspring-%E7%AD%89%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%BC%8F"><span class="toc-text">
           谈谈你知道的设计模式？请手动实现单例模式，Spring 等框架中使用了哪些模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%92%8C-reentrantlock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%9C%89%E4%BA%BA%E8%AF%B4-synchronized-%E6%9C%80%E6%85%A2%E8%BF%99%E8%AF%9D%E9%9D%A0%E8%B0%B1%E5%90%97"><span class="toc-text">
           synchronized 和 ReentrantLock 有什么区别？有人说 synchronized 最慢，这话靠谱吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7-%E9%99%8D%E7%BA%A7"><span class="toc-text">
           synchronized 底层如何实现？什么是锁的升级、降级？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E8%B0%88%E8%B0%88%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB"><span class="toc-text">
           一个线程两次调用 start() 方法会出现什么情况？谈谈线程的生命周期和状态转移。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8Bjava%E7%A8%8B%E5%BA%8F%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D-%E4%BF%AE%E5%A4%8D"><span class="toc-text">
           什么情况下Java程序会产生死锁？如何定位、修复？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-%E5%B9%B6%E5%8F%91%E5%8C%85%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">
           Java 并发包提供了哪些并发工具类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84-concurrentlinkedqueue-%E5%92%8C-linkedblockingqueue-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">
           并发包中的 ConcurrentLinkedQueue 和 LinkedBlockingQueue 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-%E5%B9%B6%E5%8F%91%E7%B1%BB%E5%BA%93%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D-%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-text">
           Java 并发类库提供的线程池有哪几种？ 分别有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomicinteger%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%A7%E5%93%81%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%BA%94%E7%94%A8cas%E6%93%8D%E4%BD%9C"><span class="toc-text">
           AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E4%BB%8B%E7%BB%8D%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">
           请介绍类加载过程，什么是双亲委派模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA-java-%E7%B1%BB"><span class="toc-text">
           有哪些方法可以在运行时动态生成一个 Java 类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-jvm-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%88%92%E5%88%86%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F-outofmemoryerror"><span class="toc-text">
           谈谈 JVM 内存区域的划分，哪些区域可能发生 OutOfMemoryError？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E5%92%8C%E8%AF%8A%E6%96%ADjvm%E5%A0%86%E5%86%85%E5%92%8C%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8"><span class="toc-text">
           如何监控和诊断JVM堆内和堆外内存使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">
           Java 常见的垃圾收集器有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84-gc-%E8%B0%83%E4%BC%98%E6%80%9D%E8%B7%AF"><span class="toc-text">
           谈谈你的 GC 调优思路？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84-happen-before-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">
           Java 内存模型中的 happen-before 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%9C%A8-docker-%E7%AD%89%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-text">
           Java 程序运行在 Docker 等容器环境有哪些新问题？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80"><span class="toc-text">
           Java 性能基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%87%BA%E7%8E%B0%E6%98%8E%E6%98%BE%E5%8F%98%E6%85%A2%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E8%AF%8A%E6%96%AD%E6%80%9D%E8%B7%AF"><span class="toc-text">
           后台服务出现明显“变慢”，谈谈你的诊断思路？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BA%BA%E8%AF%B4lambda-%E8%83%BD%E8%AE%A9-java-%E7%A8%8B%E5%BA%8F%E6%85%A2-30-%E5%80%8D%E4%BD%A0%E6%80%8E%E4%B9%88%E7%9C%8B"><span class="toc-text">
           有人说“Lambda 能让 Java 程序慢 30 倍”，你怎么看？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm-%E4%BC%98%E5%8C%96-java-%E4%BB%A3%E7%A0%81%E6%97%B6%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">
           JVM 优化 Java 代码时都做了什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%89%A9%E5%B1%95"><span class="toc-text">
           Java 应用开发扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-mysql-%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%A5%E5%8F%8A%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">
           谈谈 MySQL 支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-spring-bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">
           谈谈 Spring Bean 的生命周期和作用域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-java-%E6%A0%87%E5%87%86-nio-%E7%B1%BB%E5%BA%93%E4%BD%A0%E7%9F%A5%E9%81%93-netty-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9B%B4%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%90%97"><span class="toc-text">
           对比 Java 标准 NIO 类库，你知道 Netty 是如何实现更高性能的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F-id-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88snowflake-%E6%98%AF%E5%90%A6%E5%8F%97%E5%86%AC%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E5%BD%B1%E5%93%8D"><span class="toc-text">
           谈谈常用的分布式 ID 的设计方案？Snowflake 是否受冬令时切换影响？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-text">
           问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-text">
           动态类型语言和静态类型语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-text">
           虚方法表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E5%B9%B8%E5%AD%98%E8%80%85%E5%8C%BA%E6%BB%A1%E4%BA%86%E4%BB%A5%E5%90%8E%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-text">
           思考：幸存者区满了以后如何操作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E6%94%BE"><span class="toc-text">
           大对象的存放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#classloaderloadclassxxx"><span class="toc-text">
           classLoader.loadClass(“xxx”)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-text">
           String 字面量的创建时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">
           字符串拼接操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%9C%A8-jdk-17-%E5%90%8E%E7%A7%BB%E5%8A%A8%E5%88%B0%E4%BA%86%E5%A0%86%E5%86%85"><span class="toc-text">
           为什么字符串常量池在 JDK 1.7 后移动到了堆内</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stringbuildertostring"><span class="toc-text">
           StringBuilder.toString()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E7%AF%87"><span class="toc-text">
           框架篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-%E4%BB%8B%E7%BB%8D"><span class="toc-text">
           Spring 介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%AF%87"><span class="toc-text">
           分布式篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-text">
           项目中分布式锁的设计方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redisson-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">
           Redisson 分布式锁的实现原理</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/author.png" alt="avatar"></div><p class="sidebar-ov-author__text">no code no life</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YUYUN-ZHAO" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="zyy18749810683" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1024462136" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:im.yuyunzhao@gmail.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gmail</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">158</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">42</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">42</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>yuyun zhao</span><span class="footer__devider">|</span><span>沪ICP备2022000458号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>