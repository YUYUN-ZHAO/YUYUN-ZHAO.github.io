<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="Redis 简介         Redis官网 、Redis中文网  Redis：REmote DIctionary Server（远程字典服务器） 是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的（key&#x2F;value）分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="【Redis】Redis 基础">
<meta property="og:url" content="http://yuyun-zhao.github.io/2021/09/09/%E3%80%90Redis%E3%80%91Redis/index.html">
<meta property="og:site_name" content="yuyun zhao&#39;s blog">
<meta property="og:description" content="Redis 简介         Redis官网 、Redis中文网  Redis：REmote DIctionary Server（远程字典服务器） 是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的（key&#x2F;value）分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210913131720145.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912213742688.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912213906532.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912214047542.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912214645546.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912215152100.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210913122404598.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210913122513817.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210911230855564.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210911230754903.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210911231436324.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210911231420212.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210911231758180.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210911231825494.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210911232231984.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912103134052.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912111523166.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912104201388.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912111553281.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912111619198.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912111730249.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/aHR0cHM6Ly9naXRlZS5jb20vamFsbGVua3dvbmcvTGVhcm5SZWRpcy9yYXcvbWFzdGVyL2ltYWdlLzIxLnBuZw">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912112446186.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912114736426.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/aHR0cHM6Ly9naXRlZS5jb20vamFsbGVua3dvbmcvTGVhcm5SZWRpcy9yYXcvbWFzdGVyL2ltYWdlLzIyLnBuZw">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210913183818788.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210913183826952.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912202032972.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912202226170.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912202406006.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912202423699.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912202607757.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912202630691.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912204058177.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912204652370.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912205253939.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210913165922239.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210913164351029.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210913174004677.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210912211245500.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210913173713479.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210913175731575.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210915195625155.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210915195120417.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210915195317930.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210915195323682.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210914170043586.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210914174222618.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210914175544276.png">
<meta property="article:published_time" content="2021-09-09T14:15:25.000Z">
<meta property="article:modified_time" content="2021-09-17T07:11:01.553Z">
<meta property="article:author" content="yuyun zhao">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="中间件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yuyun-zhao.github.io/images/%E3%80%90Redis%E3%80%91Redis/image-20210913131720145.png"><title>【Redis】Redis 基础 | yuyun zhao's blog</title><link ref="canonical" href="http://yuyun-zhao.github.io/2021/09/09/%E3%80%90Redis%E3%80%91Redis/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">文章</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">yuyun zhao's blog</div><div class="header-banner-info__subtitle">no code no life</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">【Redis】Redis 基础</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-17</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">17.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">107分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210913131720145.png" alt="image-20210913131720145" /></p>

        <h2 id="redis-简介"   >
          <a href="#redis-简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-简介"></a> Redis 简介</h2>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://redis.io/" >Redis官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 、<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.redis.cn/" >Redis中文网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p><strong>Redis：REmote DIctionary Server（远程字典服务器）</strong> 是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的（key/value）分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器。</p>

        <h3 id="redis-单线程模型"   >
          <a href="#redis-单线程模型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-单线程模型"></a> Redis 单线程模型</h3>
      
<p>Redis 采用<strong>单线程模型</strong>来处理客户端的请求。对读写等事件的响应是通过对<code>epoll</code>函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率。</p>
<blockquote>
<p>Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本， 它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>
</blockquote>
<p>Redis是<strong>单线程 + 多路IO复用技术</strong></p>
<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</p>
<p><strong>串行  vs  多线程+锁（memcached） vs  单线程 + 多路IO复用（Redis）</strong></p>
<p>（与Memcache三点不同：支持多数据类型，支持持久化，单线程+多路IO复用）</p>

        <h3 id="redis-特点"   >
          <a href="#redis-特点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-特点"></a> Redis 特点</h3>
      
<p>Redis 与其他 key - value 缓存软件有以下三个特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份</li>
</ul>
<p>Redis 能够用来：</p>
<ul>
<li>内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务</li>
<li>取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面</li>
<li>模拟类似于HttpSession这种需要设定过期时间的功能</li>
<li>发布、订阅消息系统</li>
<li>定时器、计数器</li>
</ul>
<p>Redis 安装见 <a href="https://yuyun-zhao.github.io/documents/linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.pdf">Linux 开发环境配置文档</a></p>
<span id="more"></span>

        <h2 id="redis-五大数据类型"   >
          <a href="#redis-五大数据类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-五大数据类型"></a> Redis 五大数据类型</h2>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u011863024/article/details/107476187" >https://blog.csdn.net/u011863024/article/details/107476187</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<ul>
<li><strong>String</strong>（字符串）
<ul>
<li>String是Redis最基本的类型，可以理解成与Memcached一模一样的类型，一个key对应一个value。</li>
<li>String类型是<strong>二进制安全的</strong>。意思是Redis的String可以包含任何数据。比如jpg图片或者序列化的对象。</li>
<li>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</li>
</ul>
</li>
<li><strong>Hash</strong>（哈希，类似java里的Map）
<ul>
<li>Redis Hash 是一个键值对集合。</li>
<li>Redis Hash是一个String类型的field和value的映射表，Hash特别适合用于存储对象。<br />
类似Java里面的<code>Map&lt;String,Object&gt;</code></li>
</ul>
</li>
<li><strong>List</strong>（列表）
<ul>
<li>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</li>
<li>它的底层实际是个链表</li>
</ul>
</li>
<li><strong>Set</strong>（集合）
<ul>
<li>Redis的Set是String类型的无序集合。它是通过<code>HashTable</code>实现实现的</li>
</ul>
</li>
<li><strong>Zset</strong>（sorted set：有序集合）
<ul>
<li>Redis Zset 和 Set 一样也是String类型元素的集合，且不允许重复的成员。</li>
<li>不同的是每个元素都会关联一个double类型的分数。</li>
<li>Redis正是通过分数来为集合中的成员进行从小到大的排序。Zset的成员是唯一的，但分数（score）却可以重复。</li>
</ul>
</li>
</ul>
<p>Redis 常见数据类型操作命令：</p>
<ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://redisdoc.com/" >Redis 命令参考</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://redis.io/commands" >Redis 官网命令参考</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>

        <h3 id="string"   >
          <a href="#string" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#string"></a> String</h3>
      
<p>String的数据结构为简单动态字符串（Simple Dynamic String,缩写SDS）。是可以修改的字符串，内部结构实现上类似于Java的<code>ArrayList</code>，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912213742688.png" alt="image-20210912213742688" /></p>
<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>

        <h3 id="list"   >
          <a href="#list" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#list"></a> List</h3>
      
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底层实际是个<strong>双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912213906532.png" alt="image-20210912213906532" /></p>
<p>List的数据结构为<strong>快速链表quickList</strong>。</p>
<p>首先在列表元素较少的情况下会使用一块<strong>连续的内存</strong>存储，这个结构是<strong>ziplist</strong>，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成<strong>quicklist</strong>。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912214047542.png" alt="image-20210912214047542" /></p>
<p>Redis将链表和<strong>ziplist</strong>结合起来组成了<strong>quicklist</strong>。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>

        <h3 id="set"   >
          <a href="#set" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#set"></a> Set</h3>
      
<p>Set对外提供的功能与List类似是一个列表的功能，特殊之处在于Set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，Set是一个很好的选择，并且Set提供了判断某个成员是否在一个Set集合内的重要接口，这个也是List所不能提供的。</p>
<p>Redis的Set是String类型的<strong>无序集合</strong>。它底层其实是一个value为null的<strong>Hash</strong>表，所以添加/删除/查找的<strong>复杂度都是O(1)</strong>。一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变。</p>
<p>Set数据结构是Dict字典，字典是用哈希表实现的。Java中<code>HashSet</code>的内部实现使用的是<code>HashMap</code>，只不过所有的value都指向同一个对象。<strong>Redis的Set结构也是一样，它的内部也使用Hash结构，所有的value都指向同一个内部值。</strong></p>

        <h3 id="hash"   >
          <a href="#hash" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#hash"></a> Hash</h3>
      
<p>Hash 是一个键值对集合。它是一个String类型的field和value的映射表，Hash特别适合用于存储对象。它类似Java里面的<code>Map&lt;String,Map&lt;K,V&gt;&gt;</code>，存储方式：</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912214645546.png" alt="image-20210912214645546" /></p>
<p>通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。</p>
<p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>

        <h3 id="zset"   >
          <a href="#zset" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#zset"></a> Zset</h3>
      
<p>Redis有序集合Zset与普通集合Set非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>，这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p>
<p>因为元素是有序的，所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<p>一方面它等价于Java的数据结构<code>Map&lt;String, Double&gt;</code>，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>Zset底层使用了两个数据结构</p>
<ul>
<li>Hash，Hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</li>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li>
</ul>
<p>跳跃表示例：</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912215152100.png" alt="image-20210912215152100" /></p>

        <h3 id="实际应用场景"   >
          <a href="#实际应用场景" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#实际应用场景"></a> 实际应用场景</h3>
      

        <h4 id="string-2"   >
          <a href="#string-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#string-2"></a> String</h4>
      
<ul>
<li>商品编号、订单号采用INCR命令生成</li>
<li>是否喜欢的文章</li>
</ul>

        <h4 id="hash-2"   >
          <a href="#hash-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#hash-2"></a> Hash</h4>
      
<ul>
<li>新增商品 <code>hset shopcar:uid1024 334488 1</code></li>
<li>新增商品 <code>hset shopcar:uid1024 334477 1</code></li>
<li>增加商品数量 <code>hincrby shopcar:uid1024 334477 1</code></li>
<li>商品总数 <code>hlen shopcar:uid1024</code></li>
<li>全部选择 <code>hgetall shopcar:uid1024</code></li>
</ul>

        <h4 id="list-2"   >
          <a href="#list-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#list-2"></a> List</h4>
      
<p>A和B发布了文章分别是11和22。</p>
<ul>
<li>我关注了A和B，只要他们发布了新文章，就会安装进我的List：<code>lpush likearticle:myid1122</code></li>
<li>查看我自己的号订阅的全部文章，类似分页，下面0~10就是一次显示10条：<code>lrange likearticle:myid 0 10</code></li>
</ul>

        <h4 id="set-2"   >
          <a href="#set-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#set-2"></a> Set</h4>
      
<ul>
<li>微信抽奖小程序
<ul>
<li>用户ID，立即参与按钮
<ul>
<li><code>SADD key 用户ID</code></li>
</ul>
</li>
<li>显示已经有多少人参与了、上图23208人参加
<ul>
<li><code>SCARD key</code></li>
</ul>
</li>
<li>抽奖(从set中任意选取N个中奖人)
<ul>
<li><code>SRANDMEMBER key 2</code>（随机抽奖2个人，元素不删除）</li>
<li><code>SPOP key 3</code>（随机抽奖3个人，元素会删除）</li>
</ul>
</li>
</ul>
</li>
<li>微信朋友圈点赞
<ul>
<li>新增点赞
<ul>
<li><code>sadd pub:msglD 点赞用户ID1 点赞用户ID2</code></li>
</ul>
</li>
<li>取消点赞
<ul>
<li><code>srem pub:msglD 点赞用户ID</code></li>
</ul>
</li>
<li>展现所有点赞过的用户
<ul>
<li><code>SMEMBERS pub:msglD</code></li>
</ul>
</li>
<li>点赞用户数统计，就是常见的点赞红色数字
<ul>
<li><code>scard pub:msgID</code></li>
</ul>
</li>
<li>判断某个朋友是否对楼主点赞过
<ul>
<li><code>SISMEMBER pub:msglD用户ID</code></li>
</ul>
</li>
</ul>
</li>
<li>微博好友关注社交关系
<ul>
<li>共同关注：我去到局座张召忠的微博，马上获得我和局座共同关注的人
<ul>
<li><code>sadd s1 1 2 3 4 5</code></li>
<li><code>sadd s2 3 4 5 6 7</code></li>
<li><code>SINTER s1 s2</code></li>
</ul>
</li>
<li>我关注的人也关注他(大家爱好相同)</li>
</ul>
</li>
<li>QQ内推可能认识的人
<ul>
<li><code>sadd s1 1 2 3 4 5</code></li>
<li><code>sadd s2 3 4 5 6 7</code></li>
<li><code>SINTER s1 s2</code></li>
<li><code>SDIFF s1 s2</code></li>
<li><code>SDIFF s2 s1</code></li>
</ul>
</li>
</ul>

        <h4 id="zset-2"   >
          <a href="#zset-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#zset-2"></a> Zset</h4>
      
<ul>
<li>根据商品销售对商品进行排序显示
<ul>
<li>定义商品销售排行榜（sorted set集合），key为goods:sellsort，分数为商品销售数量。</li>
<li>商品编号1001的销量是9，商品编号1002的销量是15 <code>- zadd goods:sellsort 9 1001 15 1002</code></li>
<li>有一个客户又买了2件商品1001，商品编号1001销量加2 - <code>zincrby goods:sellsort 2 1001</code></li>
<li>求商品销量前10名 - <code>ZRANGE goods:sellsort 0 10 withscores</code></li>
</ul>
</li>
<li>抖音热搜
<ul>
<li>点击视频
<ul>
<li><code>ZINCRBY hotvcr:20200919 1 八佰</code></li>
<li><code>ZINCRBY hotvcr:20200919 15 八佰 2 花木兰</code></li>
</ul>
</li>
<li>展示当日排行前10条
<ul>
<li><code>ZREVRANGE hotvcr:20200919 0 9 withscores</code></li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="redis-新数据类型"   >
          <a href="#redis-新数据类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-新数据类型"></a> Redis 新数据类型</h2>
      

        <h3 id="bitmaps"   >
          <a href="#bitmaps" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#bitmaps"></a> Bitmaps</h3>
      
<p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210913122404598.png" alt="image-20210913122404598" /></p>
<p>合理地使用操作位能够有效地提高内存使用率和开发效率。</p>
<p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p>
<ul>
<li>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li>
<li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</li>
</ul>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210913122513817.png" alt="image-20210913122513817" /></p>
<p>Bitmaps可用于统计网站的活跃用户数量，占用内存远小于Set。</p>
<p>Bitmaps常用命令见 <a href="https://yuyun-zhao.github.io/documents/Redis6.pdf">Redis6 文档</a>。</p>

        <h3 id="hyperloglog"   >
          <a href="#hyperloglog" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#hyperloglog"></a> HyperLogLog</h3>
      
<p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为<strong>基数问题</strong>。解决基数问题有很多种方案：</p>
<ul>
<li>数据存储在MySQL表中，使用distinct count计算不重复个数</li>
<li>使用Redis提供的hash、set、bitmaps等数据结构来处理</li>
</ul>
<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。能否能够降低一定的精度来平衡存储空间？Redis推出了<strong>HyperLogLog</strong></p>
<p>Redis HyperLogLog 是用来做<strong>基数统计</strong>的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>什么是基数？比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<p>HyperLogLog常用命令见 <a href="https://yuyun-zhao.github.io/documents/Redis6.pdf">Redis6 文档</a>。</p>

        <h3 id="geospatial"   >
          <a href="#geospatial" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#geospatial"></a> Geospatial</h3>
      
<p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。Redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<p>Geospatial常用命令见 <a href="https://yuyun-zhao.github.io/documents/Redis6.pdf">Redis6 文档</a>。</p>

        <h2 id="redis-常用命令"   >
          <a href="#redis-常用命令" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-常用命令"></a> Redis 常用命令</h2>
      

        <h3 id="key-关键字"   >
          <a href="#key-关键字" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#key-关键字"></a> Key 关键字</h3>
      
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210911230855564.png" alt="image-20210911230855564" /></p>

        <h3 id="string-3"   >
          <a href="#string-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#string-3"></a> String</h3>
      
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210911230754903.png" alt="image-20210911230754903" /></p>
<p>常用命令：</p>
<ul>
<li><code>SET key value</code></li>
<li><code>GET key</code></li>
<li><code>MSET key value [key value…]</code>  同时设置多个键值</li>
<li><code>MGET key [key…]</code> 同时获取多个键值</li>
<li><code>INCR key</code> 递增数字 （可以不用预先设置key的数值。如果预先设置key但值不是数字，则会报错)</li>
<li><code>INCRBY key increment</code> 增加指定的整数</li>
<li><code>DECR key</code> 递减数值</li>
<li><code>DECRBY key decrement</code> 减少指定的整数</li>
<li><code>STRLEN key</code>  获取字符串长度</li>
<li><code>SETNX key value</code>  分布式锁</li>
</ul>

        <h3 id="list-3"   >
          <a href="#list-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#list-3"></a> List</h3>
      
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210911231436324.png" alt="image-20210911231436324" /></p>
<p>常用命令：</p>
<ul>
<li><code>LPUSH key value [value …]</code>  向列表左边添加元素</li>
<li><code>RPUSH key value [value …]</code>  向列表右边添加元素</li>
<li><code>LRANGE key start stop</code>  查看列表</li>
<li><code>LLEN key</code>  获取列表中元素的个数</li>
</ul>
<p>性能总结：</p>
<ul>
<li>它是一个字符串链表，left、right都可以插入添加；</li>
<li>如果键不存在，创建新的链表；</li>
<li>如果键已存在，新增内容；</li>
<li>如果值全移除，对应的键也就消失了。</li>
<li>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</li>
</ul>

        <h3 id="set-3"   >
          <a href="#set-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#set-3"></a> Set</h3>
      
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210911231420212.png" alt="image-20210911231420212" /></p>
<p>常用命令：</p>
<ul>
<li><code>SADD key member [member …]</code>  添加元素</li>
<li><code>SREM key member [member …]</code>  删除元素</li>
<li><code>SMEMBERS key</code>  获取集合中的所有元素</li>
<li><code>SISMEMBER key member</code>  判断元素是否在集合中</li>
<li><code>SCARD key</code>  获取集合中的元素个数</li>
<li><code>SRANDMEMBER key [数字]</code>  从集合中随机弹出一个元素，元素不删除</li>
<li><code>SPOP key[数字]</code>  从集合中随机弹出一个元素，出一个删一个</li>
</ul>
<p>集合运算：</p>
<ul>
<li>集合的差集运算A - B
<ul>
<li>属于A但不属于B的元素构成的集合</li>
<li><code>SDIFF key [key …]</code></li>
</ul>
</li>
<li>集合的交集运算A ∩ B
<ul>
<li>属于A同时也属于B的共同拥有的元素构成的集合</li>
<li><code>SINTER key [key …]</code></li>
</ul>
</li>
<li>集合的并集运算A U B
<ul>
<li>属于A或者属于B的元素合并后的集合</li>
<li><code>SUNION key [key …]</code></li>
</ul>
</li>
</ul>

        <h3 id="hash-3"   >
          <a href="#hash-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#hash-3"></a> Hash</h3>
      
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210911231758180.png" alt="image-20210911231758180" /></p>
<p>常用命令：</p>
<ul>
<li><code>HSET key field value</code>  一次设置一个字段值</li>
<li><code>HGET key field</code>  一次获取一个字段值</li>
<li><code>HMSET key field value [field value …]</code>  一次设置多个字段值</li>
<li><code>HMGET key field [field …]</code>  一次获取多个字段值</li>
<li><code>HGETALL key</code>  获取所有字段值</li>
<li><code>HLEN key</code>  获取某个key内的全部数量</li>
<li><code>HDEL key</code>  删除一个key</li>
</ul>

        <h3 id="zset-3"   >
          <a href="#zset-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#zset-3"></a> ZSet</h3>
      
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210911231825494.png" alt="image-20210911231825494" /></p>
<p>常用命令：</p>
<ul>
<li><code>ZADD key score member [score member …]</code>  添加元素</li>
<li><code>ZRANGE key start stop [WITHSCORES]</code>  按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素</li>
<li><code>ZSCORE key member</code> 获取元素的分数</li>
<li><code>ZREM key member [member …]</code>  删除元素</li>
<li><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code> 获取指定分数范围的元素</li>
<li><code>ZINCRBY key increment member</code>  增加某个元素的分数</li>
<li><code>ZCARD key</code>  获取集合中元素的数量</li>
<li><code>ZCOUNT key min max</code>  获得指定分数范围内的元素个数</li>
<li><code>ZREMRANGEBYRANK key start stop</code> 按照排名范围删除元素</li>
<li>获取元素的排名
<ul>
<li><code>ZRANK key member</code>  从小到大</li>
<li><code>ZREVRANK key member</code>  从大到小</li>
</ul>
</li>
</ul>

        <h2 id="redis-配置文件介绍"   >
          <a href="#redis-配置文件介绍" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-配置文件介绍"></a> Redis 配置文件介绍</h2>
      
<p>Redis 的配置文件位于 Redis 安装目录下，文件名为 <code>redis.conf</code>可以通过 CONFIG 命令查看或设置配置项。</p>
<p><code>Redis CONFIG</code> 命令格式如下：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME</span><br></pre></td></tr></table></div></figure>
<p><strong>实例</strong></p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET loglevel</span><br><span class="line"></span><br><span class="line">1) <span class="string">&quot;loglevel&quot;</span></span><br><span class="line">2) <span class="string">&quot;notice&quot;</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="参数说明"   >
          <a href="#参数说明" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数说明"></a> 参数说明</h3>
      
<p><code>redis.conf</code> 配置项说明如下：</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210911232231984.png" alt="image-20210911232231984" /></p>

        <h2 id="redis-持久化"   >
          <a href="#redis-持久化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-持久化"></a> Redis 持久化</h2>
      
<p>Redis 的两种持久化方式：</p>
<ul>
<li><strong>RDB（Redis DataBase）</strong>：备份数据集</li>
<li><strong>AOF（Append Only File）</strong>：仅备份指令</li>
</ul>

        <h3 id="rdb"   >
          <a href="#rdb" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rdb"></a> RDB</h3>
      
<p>RDB（Redis DataBase）是指在指定的时间间隔内将内存中的<strong>数据集快照</strong>写入磁盘，也就是行话讲的<code>Snapshot</code>快照，它恢复时是将快照文件直接读到内存里。</p>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个<strong>临时文件</strong>中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，<strong>主进程是不进行任何IO操作的</strong>，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>
<blockquote>
<p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并<strong>作为原进程的子进程</strong></p>
<p>在Linux程序中，fork() 会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”</p>
<p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p>
</blockquote>
<p>写时复制技术：</p>
<p>其他线程在读取数据时，当有写操作时，先将数据复制一份出来，写操作的线程将向其内写数据。写完后将数据与原先数据进行合并。之后再来读操作时读取的就是新的内容。（将原数据的引用指向复制后的数据上）</p>
<p>RDB持久化过程：</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912103134052.png" alt="image-20210912103134052" /></p>
<p>RDB 默认保存的备份文件为 <code>dump.rdb</code> 文件（可以在配置文件中修改名称）。相关配置在 <code>redis.conf</code> 的 <code>### SNAPSHOTTING ###</code> 部分。<code>dump.rdb</code>文件的保存路径在配置文件的 <code>dir ./</code> 位置配置。</p>
<p><strong>如何触发RDB快照</strong>：</p>
<ul>
<li>配置文件中默认的快照配置 <code>dbfilename dump.rdb</code></li>
<li>命令 <code>save</code> 或者是 <code>bgsave</code>
<ul>
<li><code>save</code>：同步保存，阻塞其他所有操作</li>
<li><code>bgsave</code>：Redis会在后台（Background）<strong>异步</strong>进行快照操作， 快照同时还可以响应客户端请求。可以通过 <code>lastsave</code> 命令获取最后一次成功执行快照的时间</li>
</ul>
</li>
<li>执行 <code>flushall</code> 命令，也会产生 <code>dump.rdb</code> 文件，但里面是空的，无意义</li>
</ul>
<p><strong>如何恢复</strong>：</p>
<ul>
<li>将备份文件<code>dump.rdb</code>移动到 Redis 安装目录并启动服务即可</li>
<li><code>CONFIG GET dir</code>获取备份文件保存的目录</li>
</ul>
<p><strong>如何停止</strong>：</p>
<p>动态停止RDB保存规则的方法：<code>redis-cli config set save &quot;&quot;</code></p>

        <h3 id="rdb-常见配置"   >
          <a href="#rdb-常见配置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rdb-常见配置"></a> RDB 常见配置</h3>
      
<p><code>dump.rdb</code>文件的保存路径：</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912111523166.png" alt="image-20210912111523166" /></p>
<p><strong>保存时机策略</strong>：</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912104201388.png" alt="image-20210912104201388" /></p>
<p>默认保存时机策略是：1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。若想禁用保存，则可以不设置<code>save</code>指令或给<code>save</code>传入空字符串。</p>
<p><strong>stop-writes-on-bgsave-error</strong>：</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912111553281.png" alt="image-20210912111553281" /></p>
<p>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes。</p>
<p><strong>rdbcompression 压缩文件</strong>：</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912111619198.png" alt="image-20210912111619198" /></p>
<p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes。</p>
<p><strong>rdbchecksum 检查完整性</strong>：</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912111730249.png" alt="image-20210912111730249" /></p>
<p>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。推荐yes。</p>

        <h3 id="rdb-优势与劣势"   >
          <a href="#rdb-优势与劣势" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rdb-优势与劣势"></a> RDB 优势与劣势</h3>
      
<p><strong>优势</strong></p>
<ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会<strong>丢失最后一次快照后的所有修改</strong></li>
<li>Fork的时候，内存中的数据被克隆了一份，<strong>大致2倍的膨胀性</strong>需要考虑</li>
<li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能。</li>
</ul>

        <h3 id="rdb-小结"   >
          <a href="#rdb-小结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rdb-小结"></a> RDB 小结</h3>
      
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/aHR0cHM6Ly9naXRlZS5jb20vamFsbGVua3dvbmcvTGVhcm5SZWRpcy9yYXcvbWFzdGVyL2ltYWdlLzIxLnBuZw" alt="img" /></p>
<ul>
<li>RDB是一个非常紧凑的文件。</li>
<li>RDB在保存RDB文件时<strong>父进程唯一需要做的就是fork出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能</strong>。</li>
<li>与AOF相比，在恢复大的数据集的时候，RDB方式会更快一一些。</li>
<li>数据丢失风险大。</li>
<li>RDB需要经常fork子进程来保存数据集到硬盘上，当数据集比较大的时候fork的过程是非常耗时的吗，可能会导致Redis在一些毫秒级不能回应客户端请求。</li>
</ul>

        <h3 id="aof"   >
          <a href="#aof" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#aof"></a> AOF</h3>
      
<p>AOF（Append Only File）以<strong>日志的形式来记录每个写操作</strong>（增量保存），将Redis执行过的所有<strong>写指令记录下来（读操作不记录）</strong>， <strong>只许追加（append）文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。AOF的同步是<strong>异步完成的</strong>。</p>
<p><strong>AOF和RDB同时开启时，系统默认读取AOF的数据（数据不会存在丢失）</strong></p>

        <h3 id="aof-持久化流程"   >
          <a href="#aof-持久化流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#aof-持久化流程"></a> AOF 持久化流程</h3>
      
<ul>
<li>客户端的请求写命令会被append追加到AOF缓冲区内；</li>
<li>AOF缓冲区根据AOF <strong>持久化策略[always,everysec,no]</strong> 将操作sync同步到磁盘的AOF文件中；</li>
<li>AOF文件大小超过重写策略或手动重写时，会对AOF文件<strong>rewrite</strong>重写，压缩AOF文件容量；</li>
<li>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；</li>
</ul>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912112446186.png" alt="image-20210912112446186" /></p>
<p>RDB 默认保存的备份文件为 <code>appendonly.aof</code> 文件（可以在配置文件中修改名称）。相关配置在 <code>redis.conf</code> 的 <code>### APPEND ONLY MODE ###</code> 部分。AOF文件的保存路径，同RDB的路径一致。</p>
<p><strong>AOF和RDB同时开启时，系统默认读取AOF的数据（数据不会存在丢失）</strong></p>
<p>若 <code>appendonly.aof</code> 文件出现损坏，可以使用<code>Redis-check-aof --fix</code>命令进行修复。</p>

        <h3 id="aof-同步频率设置"   >
          <a href="#aof-同步频率设置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#aof-同步频率设置"></a> AOF 同步频率设置</h3>
      
<ul>
<li><strong>appendfsync always</strong>：始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</li>
<li><strong>appendfsync everysec</strong>：<strong>每秒同步</strong>，每秒记入日志一次，<strong>如果宕机，本秒的数据可能丢失</strong>（RDB方式损失的时间可能更长）。</li>
<li><strong>appendfsync no</strong>：Redis不主动进行同步，把同步时机交给操作系统。</li>
</ul>

        <h3 id="rewrite-重写压缩"   >
          <a href="#rewrite-重写压缩" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rewrite-重写压缩"></a> Rewrite 重写压缩</h3>
      
<p>AOF采用<strong>文件追加方式，文件会越来越大</strong>。为避免出现此种情况，新增了<strong>重写机制Rewrite</strong>：当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的<strong>最小指令集</strong>。可以使用命令 <code>bgrewriteaof</code>：在一个子进程中进行aof的重写，从而不阻塞主进程对其余命令的处理，同时解决了aof文件过大问题。</p>

        <h4 id="rewrite-原理"   >
          <a href="#rewrite-原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rewrite-原理"></a> Rewrite 原理</h4>
      
<p>AOF文件持续增长而过大时，<strong>会fork出一条新进程来将文件重写（也是先写临时文件最后再rename）</strong>，<strong>redis4.0版本后的重写，实质上就是把 rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作</strong>。</p>
<p>每次 rewrite 并不是基于旧的指令日志进行 merge 的（因为可能某次宕机导致日志中存储错误的指令），而是<strong>基于当时内存中的数据</strong>进行指令的重新构建，这样健壮性会好很多。</p>

        <h4 id="rewrite-相关配置"   >
          <a href="#rewrite-相关配置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rewrite-相关配置"></a> Rewrite 相关配置</h4>
      
<p><strong><code>no-appendfsync-on-rewrite</code></strong></p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/jingkyks/article/details/46956905" >https://blog.csdn.net/jingkyks/article/details/46956905</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>同时在执行<code>bgrewriteaof</code>操作和主进程写aof文件的操作，两者都会操作磁盘，而<code>bgrewriteaof</code>往往会涉及大量磁盘操作，这样就会造成主进程在写aof文件的时候出现阻塞的情形，现在<code>no-appendfsync-on-rewrite</code>参数出场了。</p>
<blockquote>
<p>如果该参数设置为no，是最安全的方式，不会丢失数据，但是要忍受阻塞的问题。如果设置为yes呢？这就相当于将appendfsync设置为no，这说明并没有执行磁盘操作，只是写入了缓冲区，因此这样并不会造成阻塞（因为没有竞争磁盘），但是如果这个时候redis挂掉，就会丢失数据。丢失多少数据呢？在linux的操作系统的默认设置下，最多会丢失30s的数据。</p>
</blockquote>
<ul>
<li>如果 <code>no-appendfsync-on-rewrite=yes</code> ：正在重写时新增命令不再写入aof文件，而是写入缓存，等重写结束再同步到aof文件。这种模式下用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</li>
<li>如果 <code>no-appendfsync-on-rewrite=no</code>：正在重写时新增命令会阻塞等待重写操作完成再同步到磁盘中，缺点是会发生阻塞。（数据安全，但是性能降低）</li>
</ul>
<p><strong>重写触发机制</strong>：</p>
<p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。</p>
<p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的<strong>两倍</strong>且文件大于<strong>64M</strong>时触发。修改以下配置即可更改重写触发时机：</p>
<ul>
<li><code>auto-aof-rewrite-percentage</code>：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</li>
<li><code>auto-aof-rewrite-min-size</code>：设置重写的基准值，最小文件64MB。达到这个值开始重写，一般该值设置大一些 3~5GB。</li>
</ul>

        <h3 id="rewrite-流程"   >
          <a href="#rewrite-流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rewrite-流程"></a> Rewrite 流程</h3>
      
<ul>
<li><code>bgrewriteaof</code>触发重写，判断是否当前有<code>bgsave</code>（RDB进程）或<code>bgrewriteaof</code>在运行，如果有，则等待该命令结束后再继续执行。</li>
<li><strong>主进程fork出子进程执行重写操作，保证主进程不会阻塞</strong>。</li>
<li>子进程遍历Redis内存中数据到<strong>临时文件</strong>，<strong>客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</strong></li>
<li>子进程写完新的AOF文件后，<strong>向主进程发信号，父进程更新统计信息</strong>。</li>
<li>主进程把<code>aof_rewrite_buf</code>中的数据写入到新的AOF文件。</li>
<li>使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</li>
</ul>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912114736426.png" alt="image-20210912114736426" /></p>

        <h3 id="aof-优势与劣势"   >
          <a href="#aof-优势与劣势" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#aof-优势与劣势"></a> AOF 优势与劣势</h3>
      
<p><strong>优势</strong></p>
<ul>
<li>备份机制更稳健，<strong>丢失数据概率更低</strong>。</li>
<li>可读的日志文本，通过操作AOF稳健，可以处理误操作。</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>相同数据集的数据而言aof文件占用磁盘空间要远大于rdb文件，恢复速度慢于rdb</li>
<li>每次读写都同步的话，有一定的性能压力。</li>
<li>AOF运行效率要慢于RDB，每秒同步策略效率较好，不同步效率和RDB相同</li>
</ul>

        <h3 id="aof-小结"   >
          <a href="#aof-小结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#aof-小结"></a> AOF 小结</h3>
      
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/aHR0cHM6Ly9naXRlZS5jb20vamFsbGVua3dvbmcvTGVhcm5SZWRpcy9yYXcvbWFzdGVyL2ltYWdlLzIyLnBuZw" alt="img" /></p>
<ul>
<li>AOF文件时一个只进行<strong>追加的日志文件</strong></li>
<li>Redis可以在AOF文件体积变得过大时，<strong>自动地在后台对AOF进行重写</strong></li>
<li>AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此AOF文件的内容非常容易被人读懂，对文件进行分析也很轻松</li>
<li>对于相同的数据集来说，<strong>AOF文件的体积通常要大于RDB文件的体积</strong></li>
<li>根据所使用的 fsync 策略，<strong>AOF的速度可能会慢于RDB</strong></li>
</ul>

        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
      
<p>官方推荐两个都启用。</p>
<ul>
<li>如果对数据不敏感，可以选单独用RDB。</li>
<li>不建议单独用 AOF，因为可能会出现Bug。</li>
<li>如果只是做纯内存缓存，可以都不用。</li>
</ul>
<p><strong>官方建议</strong>：</p>
<ul>
<li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li>
<li>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾</li>
<li>Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大</li>
<li>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式</li>
</ul>
<p>同时开启两种持久化方式：</p>
<ul>
<li>在这种情况下，当redis重启的时候会<strong>优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</strong></li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ 建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份）， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li>
</ul>
<p>性能建议：</p>
<ul>
<li>因为RDB文件只用作后备用途，建议只在 Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</li>
<li>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价：一是带来了持续的IO，二是AOF Rewrite的最后将Rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</li>
<li>只要硬盘许可，应该尽量减少AOF Rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。</li>
<li>默认超过原大小100%大小时重写可以改到适当的数值。</li>
</ul>

        <h2 id="redis-发布和订阅"   >
          <a href="#redis-发布和订阅" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-发布和订阅"></a> Redis 发布和订阅</h2>
      
<p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。Redis 客户端可以订阅任意数量的频道。</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210913183818788.png" alt="image-20210913183818788" /></p>
<p>当给这个频道发布消息后，消息就会发送给订阅的客户端</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210913183826952.png" alt="image-20210913183826952" /></p>
<p>Redis Sentinel 间通讯时使用了发布订阅功能。</p>

        <h2 id="redis-事务"   >
          <a href="#redis-事务" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-事务"></a> Redis 事务</h2>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.redis.cn/topics/transactions.html" >Redis 事务官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>Redis事务的主要作用就是<strong>串联多个命令防止别的命令插队</strong>。</p>

        <h3 id="事务常用命令"   >
          <a href="#事务常用命令" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#事务常用命令"></a> 事务常用命令</h3>
      
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912202032972.png" alt="image-20210912202032972" /></p>
<p><strong>Multi、Exec、Discard</strong></p>
<p>从输入<code>Multi</code>命令开始（<strong>组队阶段</strong>），输入的命令都会依次进入<strong>命令队列</strong>中，<strong>但不会执行</strong>，直到输入<code>Exec</code>命令后进入<strong>执行阶段</strong>，Redis会将之前命令队列中的命令依次执行。组队的过程中可以通过<code>Discard</code>命令来放弃组队。</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912202226170.png" alt="image-20210912202226170" /></p>
<ol>
<li>当<strong>组队阶段</strong>中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</li>
</ol>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912202406006.png" alt="image-20210912202406006" /></p>
<ol start="2">
<li>当<strong>执行阶段</strong>某个命令报出了错误，则<strong>只有报错的命令不会被执行，而其他的命令都会执行</strong>，不会回滚。</li>
</ol>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912202423699.png" alt="image-20210912202423699" /></p>

        <h3 id="事务三阶段"   >
          <a href="#事务三阶段" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#事务三阶段"></a> 事务三阶段</h3>
      
<ul>
<li>开启：以<code>MULTI</code>开始一个事务</li>
<li>入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</li>
<li>执行：由<code>EXEC</code>命令触发事务</li>
</ul>

        <h3 id="watch"   >
          <a href="#watch" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#watch"></a> WATCH</h3>
      
<p><code>WATCH</code>指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变， 比如某个list已被别的客户端<code>push/pop</code>过了，整个事务队列都不会被执行。</p>
<p>通过<code>WATCH</code>命令在事务执行之前监控了多个Keys，倘若在<code>WATCH</code>之后有任何Key的值发生了变化， <code>EXEC</code>命令执行的事务都将被放弃，同时返回<code>Nullmulti-bulk</code>应答以通知调用者事务执行失败</p>

        <h3 id="悲观锁"   >
          <a href="#悲观锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#悲观锁"></a> 悲观锁</h3>
      
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912202607757.png" alt="image-20210912202607757" /></p>
<p><strong>悲观锁（Pessimistic Lock）</strong>，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p>

        <h3 id="乐观锁"   >
          <a href="#乐观锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#乐观锁"></a> 乐观锁</h3>
      
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912202630691.png" alt="image-20210912202630691" /></p>
<p><strong>乐观锁（Optimistic Lock）</strong>，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号</strong>等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p>
<p>何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。</p>
<p>此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，<strong>如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据</strong>。</p>
<p>使用 <strong>WATCH 乐观锁 + LUA脚本</strong> 可以解决<strong>超卖</strong>问题和<strong>库存遗留</strong>问题。详细代码见见 <a href="https://yuyun-zhao.github.io/documents/Redis6.pdf">Redis6 文档</a>。</p>

        <h3 id="redis-事务三特性"   >
          <a href="#redis-事务三特性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-事务三特性"></a> Redis 事务三特性</h3>
      
<ul>
<li><strong>单独的隔离操作</strong>：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</li>
<li><strong>没有隔离级别的概念</strong>：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行， 也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题</li>
<li><strong>不保证原子性</strong>：Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li>
</ul>

        <h2 id="redis-主从复制"   >
          <a href="#redis-主从复制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-主从复制"></a> Redis 主从复制</h2>
      
<p>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，<strong>Master以写为主，Slave以读为主</strong>。主从复制能够用来：</p>
<ul>
<li>读写分离，性能扩展</li>
<li>容灾快速恢复</li>
</ul>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912204058177.png" alt="image-20210912204058177" /></p>
<p>每次与Master断开连接之后，都需要重新连接，除非配置进<code>redis.conf</code>文件（具体位置：<code>redis.conf</code>搜寻<code>#### REPLICATION ####</code>）。常用命令：</p>
<ul>
<li>从库配置命令：<code>slaveof 主库IP 主库端口</code>。</li>
<li>查看当前主从配置：<code>info replication</code></li>
</ul>
<blockquote>
<p>replication<br />
英 [ˌreplɪ’keɪʃ(ə)n] 美 [ˌreplɪ’keɪʃ(ə)n]<br />
n.<br />
(绘画等的)复制;拷贝;重复(实验);(尤指对答辩的)回答</p>
</blockquote>

        <h3 id="常见问题"   >
          <a href="#常见问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#常见问题"></a> 常见问题</h3>
      
<ul>
<li>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制？比如从k4进来，那之前的123是否也可以复制？答：从头开始复制；123也可以复制</li>
<li>从机是否可以写？set可否？答：从机不可写，不可set，主机可写</li>
<li>主机shutdown后情况如何？从机是上位还是原地待命答：从机还是原地待命</li>
<li>主机又回来了后，主机新增记录，从机还能否顺利复制？答：能</li>
<li>其中一台从机down后情况如何？依照原有它能跟上大部队吗？答：不能跟上，每次与master断开之后，都需要重新连接，除非你配置进<code>redis.conf</code>文件（具体位置：<code>redis.conf</code>搜寻<code>#### REPLICATION ####</code>）</li>
</ul>

        <h3 id="薪火相传"   >
          <a href="#薪火相传" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#薪火相传"></a> 薪火相传</h3>
      
<p>上一个slave可以是下一个slave的Master，slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master，可以有效减轻master的写压力，去中心化降低风险。风险是一旦某个slave宕机，后面的slave都没法备份。主机挂了，从机还是从机，无法写数据了。中途变更转向：会清除之前的数据，重新建立拷贝最新的。</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912204652370.png" alt="image-20210912204652370" /></p>

        <h3 id="反客为主"   >
          <a href="#反客为主" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#反客为主"></a> 反客为主</h3>
      
<p>当一个master宕机后，后面的slave可以立刻升为master，使当前数据库停止与其他数据库的同步，转成主数据库。其后面的slave不用做任何修改。</p>
<p>使用命令：<code>SLAVEOF no one</code></p>

        <h3 id="主从复制原理"   >
          <a href="#主从复制原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#主从复制原理"></a> 主从复制原理</h3>
      
<p>slave启动成功连接到master后会发送一个<code>sync</code>命令。master接到命令启动后台的<strong>存盘进程</strong>，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个<strong>RDB数据文件</strong>到slave，以完成一次完全同步。</p>
<ul>
<li><strong>全量复制</strong>：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中</li>
<li><strong>增量复制</strong>：master继续将<strong>新的</strong>所有收集到的修改命令依次传给slave（只传送新增的修改命令），完成同步</li>
</ul>
<p>在Redis2.8版本后，主从断线后恢复的情况下实现增量复制。</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912205253939.png" alt="image-20210912205253939" /></p>

        <h2 id="redis-哨兵模式sentinel"   >
          <a href="#redis-哨兵模式sentinel" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-哨兵模式sentinel"></a> Redis 哨兵模式（sentinel）</h2>
      
<blockquote>
<p>更多细节见博客 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.huaweicloud.com/articles/f2e85fe106cd4b353928348513fecdab.html%E3%80%81https://www.cnblogs.com/kevingrace/p/9004460.html" >https://www.huaweicloud.com/articles/f2e85fe106cd4b353928348513fecdab.html、https://www.cnblogs.com/kevingrace/p/9004460.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>哨兵模式是<strong>反客为主的自动版</strong>，能够在后台监控主机是否故障，如果故障了根据<strong>投票数</strong>自动将从库转换为主库。通常哨兵也配置多个，互相监控。一组sentinel能同时监控多个master，原master重启后会变为从机。哨兵与服务器间通过发布订阅获得消息。</p>
<p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器(instance) 该系统执行以下三个任务:</p>
<ul>
<li><strong>监控(Monitoring)</strong>：Sentinel 会不断地定期检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒(Notification)</strong>：当被监控的某个 Redis 服务器出现问题时，Sentinel 可以通过 API 向管理员或者其他应用程序发送通知（例如发邮件）。</li>
<li><strong>自动故障迁移(Automaticfailover)</strong>：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器；通过发布与订阅功能， 将更新后的配置传播给所有其他 Sentinel ， 其他 Sentinel 对它们自己的配置进行更新。<strong>当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址</strong>，使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols) 来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</p>
<p>哨兵是 Redis 集群架构中非常重要的一个组件，主要功能如下：</p>
<ul>
<li><strong>集群监控</strong>，负责监控 Redis Master 和 Slave 进程是否正常工作；</li>
<li><strong>消息通知</strong>，如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员；</li>
<li><strong>故障转移</strong>，如果 Master node 挂掉了，会自动转移到 Slave node 上；</li>
<li><strong>配置中心</strong>，如果故障转移发生了，通知 Client 客户端新的 Master 地址。</li>
</ul>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210913165922239.png" alt="image-20210913165922239" /></p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210913164351029.png" alt="image-20210913164351029" /></p>
<p>假设主服务器宕机，哨兵1先监测到这个结果，系统并不会立刻进行 <strong>failover（故障转移）</strong> 过程，仅仅是哨兵1主观地认为其不可用，此现象称为<strong>主观下线</strong>。当其后的哨兵也检测到主服务器不可用，并且数量达到一定值时（该数量在配置文件中配置，见下文），那么哨兵之间将进行一次投票，选出某一个哨兵发出 failover 指令，根据优先级/偏移量选出新的主机，所有从机都设置该服务器为主服务器，这个过程被称为<strong>客观下线</strong>。</p>
<p><strong>主观下线</strong>：所谓主观下线，就是<strong>单个</strong>sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。</p>
<p>sentinel会以每秒一次的频率向所有与其建立了命令连接的实例（master，从服务，其他sentinel）发ping命令，通过判断ping回复是有效回复，还是无效回复来判断实例时候在线（对该sentinel来说是“主观在线”）。</p>
<p>sentinel配置文件中的<code>down-after-milliseconds</code>设置了判断主观下线的时间长度，如果实例在<code>down-after-milliseconds</code>毫秒内，返回的都是无效回复，那么sentinel会认为该实例已（主观）下线，修改其flags状态为<code>SRI_S_DOWN</code>。如果多个sentinel监视一个服务，有可能存在多个sentinel的<code>down-after-milliseconds</code>配置不同，这个在实际生产中要注意。</p>
<p><strong>客观下线</strong>：当主观下线的节点是主节点时，此时该哨兵3节点会通过指令<code>sentinel is-masterdown-by-addr</code>寻求其它哨兵节点对主节点的判断，如果其他的哨兵也认为主节点主观线下了，则当认为主观下线的票数超过了<code>quorum</code>（选举）个数，此时哨兵节点则认为该主节点确实有问题，这样就客观下线了，大部分哨兵节点都同意下线操作，也就说是客观下线。</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210913174004677.png" alt="image-20210913174004677" /></p>
<p>哨兵至少需要3个实例，来保证自己的健壮性。哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用性。对于哨兵+redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充分的测试和演练。</p>

        <h3 id="自动故障转移机制"   >
          <a href="#自动故障转移机制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#自动故障转移机制"></a> 自动故障转移机制</h3>
      
<p>哪个从机会被选举为主机呢？首先判断每个slave与master断开连接的次数：如果一个slave与master失去联系超过10次，并且每次都超过了配置的最大失联时间(<code>down-after-milliseconds</code>)，如果sentinel在进行failover时发现slave失联，那么这个slave就会被sentinel认为不适合用来做新master的。</p>
<p>符合上述条件的slave才会被列入master候选人列表，并根据以下顺序来进行排序：</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210912211245500.png" alt="image-20210912211245500" /></p>
<ul>
<li>根据优先级别：<code>slave-priority</code> （在配置文件中配置<code>slave-priority</code>设置）。优先级默认：<code>slave-priority 100</code>，值越小优先级越高（如果一个redis的slave优先级配置为0，那么它将永远不会被选为master。但是它依然会从master哪里复制数据。）</li>
<li>偏移量是指与原主机数据相比相差最少的，即同步率最高的（根据复制的下标数比较谁的次数多）</li>
<li>每个Redis实例启动后都会随机生成一个40位的<code>runid</code></li>
</ul>

        <h3 id="配置方法"   >
          <a href="#配置方法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#配置方法"></a> 配置方法</h3>
      
<ol>
<li>新建<code>sentinel.conf</code>文件</li>
<li>配置监控的master地址：<code>sentinel monitor mymaster 127.0.0.1 6379 1</code></li>
</ol>
<p>其中<code>mymaster</code>为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量（可以同时配置多个哨兵一起监控，此处配置的1代表至少1个哨兵觉得主服务器宕机才可以进行重新选举）。</p>
<ol start="3">
<li>启动哨兵：<code>redis-sentinel  ./sentinel.conf</code></li>
</ol>

        <h3 id="复制延时"   >
          <a href="#复制延时" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#复制延时"></a> 复制延时</h3>
      
<p>由于所有的写操作都是先在master上操作，然后同步更新到slave上，所以从master同步到slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，slave机器数量的增加也会使这个问题更加严重。</p>

        <h3 id="哨兵-leader-选举算法"   >
          <a href="#哨兵-leader-选举算法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#哨兵-leader-选举算法"></a> 哨兵 leader 选举算法</h3>
      
<p>如果主节点被判定为<strong>客观下线</strong>之后，就要选取一个哨兵节点来完成后面的故障转移工作，选举出一个leader的流程如下：</p>
<ul>
<li>每个在线的哨兵节点都可以成为领导者，当它确认（比如哨兵3）主节点下线时，会向其它哨兵发<code>is-master-down-by-addr</code>命令，征求判断并要求将自己设置为领导者，由领导者处理故障转移；</li>
<li>当其它哨兵收到此命令时，可以同意或者拒绝它成为领导者；</li>
<li>如果哨兵3发现自己在选举的票数大于等于<code>num(sentinels)/2+1</code>时，将成为领导者，如果没有超过，继续选举…</li>
</ul>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210913173713479.png" alt="image-20210913173713479" /></p>

        <h3 id="redis-哨兵主备切换的数据丢失问题"   >
          <a href="#redis-哨兵主备切换的数据丢失问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-哨兵主备切换的数据丢失问题"></a> Redis 哨兵主备切换的数据丢失问题</h3>
      
<p>共有两种数据丢失场景：</p>

        <h4 id="1-异步复制时间过长"   >
          <a href="#1-异步复制时间过长" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#1-异步复制时间过长"></a> 1. 异步复制时间过长</h4>
      
<p>因为master-&gt;slave的复制是<strong>异步的</strong>，所以可能有部分数据还没复制到slave，master就宕机了（此时异步复制时间过长），这些数据就丢失了。</p>

        <h4 id="2-脑裂"   >
          <a href="#2-脑裂" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#2-脑裂"></a> 2. 脑裂</h4>
      
<p>脑裂，也就是说，某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着，这个时候，<strong>集群中就会出现两个master</strong>。</p>
<p>此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master数据可能就会丢失。因此master在恢复的时候，会被作为一个slave挂到新的master上，自己的数据会被清空，从新的master复制数据，导致刚才客户端传来的数据丢失。</p>

        <h4 id="解决异步复制和脑裂导致的数据丢失"   >
          <a href="#解决异步复制和脑裂导致的数据丢失" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#解决异步复制和脑裂导致的数据丢失"></a> 解决异步复制和脑裂导致的数据丢失</h4>
      
<p>设置数据复制和同步的延迟时间，<strong>当slave与master间的数据复制同步时间超过了延迟时间，就拒绝客户端的写请求</strong>：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1   # 最少一个slave和master进行数据复制同步时超过延迟时间 </span><br><span class="line">min-slaves-max-lag 10   # 延迟时间10s</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>lag：落后，即延迟了10s</p>
</blockquote>
<p>该配置要求至少有1个slave进行数据复制和同步的延迟不能超过10秒。如果一旦某个slave和master进行数据复制和同步的<strong>延迟超过了10秒钟</strong>，那么这个时候，master就<strong>不会再接收任何请求了</strong>（即，若slave和master数据同步时间太长，master就别再写数据了，让客户端等待稍后再写）。</p>

        <h4 id="1-减少异步复制的数据丢失"   >
          <a href="#1-减少异步复制的数据丢失" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#1-减少异步复制的数据丢失"></a> 1. 减少异步复制的数据丢失</h4>
      
<p>有了<code>min-slaves-max-lag</code>这个配置，就可以确保说，一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就<strong>拒绝写请求</strong>（让客户端稍后再写），这样可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低的可控范围内。</p>

        <h4 id="2-减少脑裂的数据丢失"   >
          <a href="#2-减少脑裂的数据丢失" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#2-减少脑裂的数据丢失"></a> 2. 减少脑裂的数据丢失</h4>
      
<p>如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求（让客户端稍后再写）。</p>
<p>这样脑裂后的<strong>旧master就不会接受client的新数据</strong>，也就避免了数据丢失。上面的配置就确保了，如果跟任何一个slave丢了连接，在10秒后发现没有slave给自己ack，那么就拒绝新的写请求。因此在脑裂场景下，最多就丢失10秒的数据。</p>

        <h3 id="总结-2"   >
          <a href="#总结-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3>
      
<p>哨兵架构，几乎可以做到了我们的要实现的<strong>高可用</strong>，但是哨兵的选举还是<strong>需要时间的</strong>，而且<strong>中间会阻塞客户端的请求</strong>，假如我们的选举消耗了1秒（实际可能几秒，高则几十秒），就在这1秒的时候来了客户端的请求，那个请求也是不可用的，并且我们的读写的节点实际还是单节点的，怎么办? 使用 Redis集群架构：</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210913175731575.png" alt="image-20210913175731575" /></p>
<p>Redis的集群其实就是一个个小的主从结合在一起（官方建议小于1000个小主从），变成了我们的Redis集群，每个小主从也就是我们的Redis数据分片。</p>

        <h2 id="redis-cluster-集群"   >
          <a href="#redis-cluster-集群" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-cluster-集群"></a> Redis Cluster 集群</h2>
      

        <h3 id="问题引出"   >
          <a href="#问题引出" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题引出"></a> 问题引出</h3>
      
<ul>
<li>容量不够，redis如何进行扩容？</li>
<li>并发写操作， redis如何分摊？</li>
</ul>
<p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p>
<p>之前通过代理主机来解决，但是 Redis 3.0 中提供了解决方案。就是<strong>无中心化集群配置</strong>。</p>

        <h3 id="什么是集群"   >
          <a href="#什么是集群" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#什么是集群"></a> 什么是集群</h3>
      
<p>Redis 集群实现了对Redis的<strong>水平扩容</strong>，即启动N个Redis节点，将整个数据库分布存储在这N个节点中，<strong>每个节点存储总数据的 1/N</strong>。Redis 的集群的功能就是为了解决<strong>单机 Redis 容量有限的问题</strong>。</p>
<p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<p>Redis Cluster 集群节点<strong>最小配置 6 个节点以上（3 主 3 从）</strong>，其中<strong>主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</strong></p>
<p>Redis Cluster 采用<strong>虚拟槽分区</strong>，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p>
<p><strong>Redis Cluster 可以说是 Redis Sentinel 带分片的加强版</strong>。也可以说：</p>
<ul>
<li><strong>Redis Sentinel 着眼于高可用</strong>，在 master 宕机时会自动将 slave 提升为 master ，继续提供服务。</li>
<li><strong>Redis Cluster 着眼于扩展性</strong>，在单个 Redis 内存不足时，使用 Cluster 进行分片存储。</li>
</ul>
<p>Redis 集群配置方法见 <a href="https://yuyun-zhao.github.io/documents/Redis6.pdf">Redis6 文档</a>。</p>

        <h3 id="slots-哈希槽"   >
          <a href="#slots-哈希槽" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#slots-哈希槽"></a> slots 哈希槽</h3>
      
<p>一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 <code>CRC16(key) % 16384</code> 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p>
<p>为什么是 16384 呢？主要考虑集群内的网络带宽，而 16384 刚好是 2K 字节大小。</p>
<p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：</p>
<ul>
<li>节点 A 负责处理 0 号至 5460 号插槽。</li>
<li>节点 B 负责处理 5461 号至 10922 号插槽。</li>
<li>节点 C 负责处理 10923 号至 16383 号插槽。</li>
</ul>
<p>在<code>redis-cli</code>每次录入、查询键值，Redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，Redis会报错，并告知应前往的Redis实例地址和端口。</p>
<p><code>redis-cli</code>客户端提供了 <code>–c</code> 参数实现自动重定向：如 <code>redis-cli -c –p 6379</code> 登入后，再录入、查询键值对可以自动重定向。</p>
<p>不在一个 slot 下的键值，是不能使用 <code>mget</code>, <code>mset</code> 等多键操作。</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210915195625155.png" alt="image-20210915195625155" /></p>
<p>可以通过 <code>&#123;&#125;</code> 来定义组的概念，从而使key中 <code>&#123;&#125;</code> 内相同内容的键值对放到一个slot中去。</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210915195120417.png" alt="image-20210915195120417" /></p>

        <h3 id="查询集群中的值"   >
          <a href="#查询集群中的值" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#查询集群中的值"></a> 查询集群中的值</h3>
      
<p><code>CLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt;</code> 返回 <code>count</code> 个 <code>slot</code> 槽中的键。</p>

        <h3 id="故障恢复"   >
          <a href="#故障恢复" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#故障恢复"></a> 故障恢复</h3>
      
<p>如果主节点下线？从节点能否自动升为主节点？注意：<strong>15秒超时</strong></p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210915195317930.png" alt="image-20210915195317930" /></p>
<p>主节点恢复后，主从关系会如何？<strong>主节点回来变成从机。</strong></p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210915195323682.png" alt="image-20210915195323682" /></p>
<p>如果某一段插槽的所有主从节点都宕掉，Redis服务是否还能继续?</p>
<ul>
<li>如果某一段插槽的所有主从都挂掉，而 <code>cluster-require-full-coverage</code> 为 yes ，那么 ，<strong>整个集群都挂掉</strong></li>
<li>如果某一段插槽的所有主从都挂掉，而 <code>cluster-require-full-coverage</code> 为 no ，那么，<strong>该插槽</strong>数据全都不能使用，也无法存储，但其他插槽仍然可以使用。</li>
</ul>
<p>其中 <code>cluster-require-full-coverage</code> 为 <code>redis.conf</code>中的参数。</p>

        <h3 id="集群优点"   >
          <a href="#集群优点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#集群优点"></a> 集群优点</h3>
      
<ul>
<li>无中心架构：访问任何一台服务器的主机都能路由到指定的服务器上，无需单独配置一台服务器进行路由；</li>
<li>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；</li>
<li>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；</li>
<li>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升；</li>
<li>降低运维成本，提高系统的扩展性和可用性。</li>
</ul>

        <h3 id="集群缺点"   >
          <a href="#集群缺点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#集群缺点"></a> 集群缺点</h3>
      
<ul>
<li>Client 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅 JedisCluster 相对成熟，异常处理部分还不完善，比如常见的 “max redirect exception”。</li>
<li>节点会因为某些原因发生阻塞（阻塞时间大于 clutser-node-timeout），被判断下线，这种 failover 是没有必要的。</li>
<li>数据通过异步复制，不保证数据的强一致性。</li>
<li>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</li>
<li>Slave 在集群中充当 “冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。</li>
</ul>

        <h2 id="redis-应用问题解决"   >
          <a href="#redis-应用问题解决" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-应用问题解决"></a> Redis 应用问题解决</h2>
      

        <h3 id="缓存穿透"   >
          <a href="#缓存穿透" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#缓存穿透"></a> 缓存穿透</h3>
      
<p>大量的请求瞬时涌入系统，而这个数据在 Redis 中<strong>不存在</strong>，<strong>所有的请求都落到了数据库上</strong>，从而可能压垮数据源。例如反复用一个不存在的用户id进行访问，会对数据库进行大量查询。造成这种情况的原因有系统设计不合理、缓存数据更新不及时，或爬虫等恶意攻击。</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210914170043586.png" alt="image-20210914170043586" /></p>
<p>解决办法：</p>
<p><strong>1. 使用布隆过滤器</strong></p>
<p>布隆过滤器是一种比较巧妙的<strong>概率型数据结构</strong>，它实际上是一个很长的二进制向量 bitmaps 和一系列随机映射函数（哈希函数）。</p>
<blockquote>
<p>详细介绍见博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43263751" >https://zhuanlan.zhihu.com/p/43263751</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。</p>
<p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果<strong>是概率性的，而不是确切的</strong>。</p>
</blockquote>
<p>其思想是：将查询的参数都存储到一个 bitmaps 中，在查询缓存前，再找个新的 bitmap，在里面对参数进行验证。如果验证的 bitmaps 中存在，则进行底层缓存的数据查询，如果 bitmap 中不存在查询参数，则进行拦截，不再进行缓存的数据查询。</p>
<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</p>
<p>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p><strong>2. 缓存空对象</strong></p>
<p>如果从数据库查询的结果为空，<strong>依然把这个结果进行缓存</strong>，那么当用 key 获取数据时，即使数据不存在，Redis 也可以直接返回结果，避免多次访问数据库。但是缓存空值的缺点是：</p>
<ul>
<li>如果存在黑客恶意的随机访问，造成<strong>缓存过多的空值</strong>，那么可能造成很多<strong>内存空间的浪费</strong>。但是也可以对这些数据设置很短的过期时间来控制；</li>
<li>如果查询的 key 对应的 Redis 缓存空值没有过期，数据库这时有了新数据，那么会出现<strong>数据库和缓存数据不一致</strong>的问题。但是可以保证当数据库有数据后更新缓存进行解决。</li>
</ul>
<p><strong>3. 设置可访问的名单（白名单）</strong></p>
<p>使用 bitmaps 类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p>
<p><strong>4. 进行实时监控</strong></p>
<p>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p>

        <h3 id="缓存击穿"   >
          <a href="#缓存击穿" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#缓存击穿"></a> 缓存击穿</h3>
      
<p>缓存击穿是指一个key非常热点（其内容存在于数据库中，不像缓存穿透里key的内容不存在），但某个时刻，其在Redis中过期，这时大量且持久的并发集中对数据库中的这个key进行访问，就会瞬间压垮数据库，就像在屏幕上凿开一个洞，击穿了数据库。常见场景：微博突发热点，大量高并发请求瞬间访问该热点key，但该key在某个时刻过期，其过期瞬间这些高并发请求就会一起访问数据库，导致其被击穿。</p>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210914174222618.png" alt="image-20210914174222618" /></p>
<p>解决方法：</p>
<p><strong>1. 预先设置热门数据</strong></p>
<p>在Redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</p>
<p><strong>2. 实时调整</strong></p>
<p>现场监控哪些数据热门，实时调整key的过期时长</p>
<p><strong>3. 使用分布式锁</strong></p>
<p>使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可，不会再访问数据库。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。Redis 分布式锁使用方法见文章<a href="https://yuyun-zhao.github.io/2021/09/15/%E3%80%90Redis%E3%80%91Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">【Redis】Redis 分布式锁</a></p>
<p>在缓存失效的时候（判断拿出来的值为空），不是立即去访问数据库，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key。</p>
<ul>
<li>当操作返回成功时，再进行访问数据库的操作，并回设缓存，最后删除mutex key；</li>
<li>当操作返回失败，证明有线程正在访问数据库，当前线程睡眠一段时间再重试整个get缓存的方法。</li>
</ul>
<p><img src="/images/%E3%80%90Redis%E3%80%91Redis/image-20210914175544276.png" alt="image-20210914175544276" /></p>

        <h3 id="缓存雪崩"   >
          <a href="#缓存雪崩" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#缓存雪崩"></a> 缓存雪崩</h3>
      
<p>缓存雪崩是指当大量缓存几乎同一时间失效或Redis宕机时，大量的请求访问直接请求数据库，导致数据库服务器无法抗住请求或挂掉的情况。这时网站常常会出现 502 错误，导致网站不可用问题。</p>
<p>缓存雪崩与缓存击穿的区别在于这里针对<strong>很多key几乎同时过期</strong>，前者则是<strong>某一个key</strong>。</p>
<p>缓存失效时的雪崩效应对底层系统的冲击非常可怕，在预防缓存雪崩时，有以下方案：</p>
<p><strong>1. 构建多级缓存架构</strong></p>
<p>Nginx缓存 + Redis缓存 + 其他缓存（ehcache等）</p>
<p><strong>2. 使用锁或队列</strong></p>
<p>用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。</p>
<p><strong>3. 设置过期标志更新缓存</strong></p>
<p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p>
<p><strong>4. 将缓存失效时间分散开</strong></p>
<p>比如我们可以在原有的失效时间基础上增加一个<strong>随机值</strong>，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<p><strong>5. 服务降级</strong></p>
<p>对数据库进行过载保护或应用层限流，这种情况下一般是在网站处于大流量、高并发时，服务器整体不能承受时，可以采用的一种限流保护措施；</p>

        <h3 id="分布式锁"   >
          <a href="#分布式锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#分布式锁"></a> 分布式锁</h3>
      
<p>Redis 分布式锁使用方法见文章<a href="https://yuyun-zhao.github.io/2021/09/15/%E3%80%90Redis%E3%80%91Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">【Redis】Redis 分布式锁</a></p>

        <h2 id="jedis-使用"   >
          <a href="#jedis-使用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jedis-使用"></a> Jedis 使用</h2>
      
<p>导入 Maven 依赖：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="jedis-常用-api"   >
          <a href="#jedis-常用-api" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jedis-常用-api"></a> Jedis 常用 API</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAPI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key</span></span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Iterator iterator = keys.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">            String key = (String) iterator.next();</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;jedis.exists====&gt;&quot;</span> + jedis.exists(<span class="string">&quot;k2&quot;</span>));</span><br><span class="line">        System.out.println(jedis.ttl(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String</span></span><br><span class="line">        <span class="comment">// jedis.append(&quot;k1&quot;,&quot;myreids&quot;);</span></span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">        jedis.set(<span class="string">&quot;k4&quot;</span>, <span class="string">&quot;k4_redis&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------&quot;</span>);</span><br><span class="line">        jedis.mset(<span class="string">&quot;str1&quot;</span>, <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;str2&quot;</span>, <span class="string">&quot;v2&quot;</span>, <span class="string">&quot;str3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line">        System.out.println(jedis.mget(<span class="string">&quot;str1&quot;</span>, <span class="string">&quot;str2&quot;</span>, <span class="string">&quot;str3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// list</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// jedis.lpush(&quot;mylist&quot;,&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;,&quot;v4&quot;,&quot;v5&quot;);</span></span><br><span class="line">        List&lt;String&gt; list = jedis.lrange(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set</span></span><br><span class="line">        jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;jd001&quot;</span>);</span><br><span class="line">        jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;jd002&quot;</span>);</span><br><span class="line">        jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;jd003&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; set1 = jedis.smembers(<span class="string">&quot;orders&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Iterator iterator = set1.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">            String string = (String) iterator.next();</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.srem(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;jd002&quot;</span>);</span><br><span class="line">        System.out.println(jedis.smembers(<span class="string">&quot;orders&quot;</span>).size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash</span></span><br><span class="line">        jedis.hset(<span class="string">&quot;hash1&quot;</span>, <span class="string">&quot;userName&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        System.out.println(jedis.hget(<span class="string">&quot;hash1&quot;</span>, <span class="string">&quot;userName&quot;</span>));</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;telphone&quot;</span>, <span class="string">&quot;13811814763&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;abc@163.com&quot;</span>);</span><br><span class="line">        jedis.hmset(<span class="string">&quot;hash2&quot;</span>, map);</span><br><span class="line">        List&lt;String&gt; result = jedis.hmget(<span class="string">&quot;hash2&quot;</span>, <span class="string">&quot;telphone&quot;</span>, <span class="string">&quot;email&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : result) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// zset</span></span><br><span class="line">        jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">60d</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">70d</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">80d</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">90d</span>, <span class="string">&quot;v4&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; s1 = jedis.zrange(<span class="string">&quot;zset01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (Iterator iterator = s1.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">            String string = (String) iterator.next();</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="jedis-事务"   >
          <a href="#jedis-事务" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jedis-事务"></a> Jedis 事务</h3>
      
<p>未加锁事务：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Response;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监控key，如果该动了事务就被放弃</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 3 jedis.watch(&quot;serialNum&quot;); jedis.set(&quot;serialNum&quot;,&quot;s#####################&quot;);</span></span><br><span class="line"><span class="comment">		 * jedis.unwatch();</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        Transaction transaction = jedis.multi();<span class="comment">// 被当作一个命令进行执行</span></span><br><span class="line">        Response&lt;String&gt; response = transaction.get(<span class="string">&quot;serialNum&quot;</span>);</span><br><span class="line">        transaction.set(<span class="string">&quot;serialNum&quot;</span>, <span class="string">&quot;s002&quot;</span>);</span><br><span class="line">        response = transaction.get(<span class="string">&quot;serialNum&quot;</span>);</span><br><span class="line">        transaction.lpush(<span class="string">&quot;list3&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        transaction.lpush(<span class="string">&quot;list3&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        transaction.lpush(<span class="string">&quot;list3&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">        transaction.exec();</span><br><span class="line">        <span class="comment">// 2 transaction.discard();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;serialNum***********&quot;</span> + response.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>加锁时事务（<code>jedis.watch(&quot;xxx&quot;)</code>）：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="keyword">int</span> balance; <span class="comment">// 可用余额</span></span><br><span class="line">        <span class="keyword">int</span> debt; <span class="comment">// 欠额</span></span><br><span class="line">        <span class="keyword">int</span> amtToSubtract = <span class="number">10</span>; <span class="comment">// 实刷额度</span></span><br><span class="line"></span><br><span class="line">        jedis.watch(<span class="string">&quot;balance&quot;</span>);</span><br><span class="line">        <span class="comment">// jedis.set(&quot;balance&quot;,&quot;5&quot;);//此句不该出现，模拟其他程序已经修改了该条目</span></span><br><span class="line">        Thread.sleep(<span class="number">7000</span>);</span><br><span class="line">        balance = Integer.parseInt(jedis.get(<span class="string">&quot;balance&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; amtToSubtract) &#123;</span><br><span class="line">            jedis.unwatch();</span><br><span class="line">            System.out.println(<span class="string">&quot;modify&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;***********transaction&quot;</span>);</span><br><span class="line">            Transaction transaction = jedis.multi();</span><br><span class="line">            transaction.decrBy(<span class="string">&quot;balance&quot;</span>, amtToSubtract);</span><br><span class="line">            transaction.incrBy(<span class="string">&quot;debt&quot;</span>, amtToSubtract);</span><br><span class="line">            transaction.exec();</span><br><span class="line">            balance = Integer.parseInt(jedis.get(<span class="string">&quot;balance&quot;</span>));</span><br><span class="line">            debt = Integer.parseInt(jedis.get(<span class="string">&quot;debt&quot;</span>));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;*******&quot;</span> + balance);</span><br><span class="line">            System.out.println(<span class="string">&quot;*******&quot;</span> + debt);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通俗点讲，watch命令就是标记一个键，如果标记了一个键，在提交事务前如果该键被别人修改过，那事务就会失败，这种情况通常可以在程序中重新再尝试一次。</span></span><br><span class="line"><span class="comment">	 * 首先标记了键balance，然后检查余额是否足够，不足就取消标记，并不做扣减；足够的话，就启动事务进行更新操作，</span></span><br><span class="line"><span class="comment">	 * 如果在此期间键balance被其它人修改，那在提交事务（执行exec）时就会报错，程序中通常可以捕获这类错误再重新执行一次，直到成功。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TestTX test = <span class="keyword">new</span> TestTX();</span><br><span class="line">        <span class="keyword">boolean</span> retValue = test.transMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;main retValue-------: &quot;</span> + retValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="jedis-主从复制"   >
          <a href="#jedis-主从复制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jedis-主从复制"></a> Jedis 主从复制</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis_M = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        Jedis jedis_S = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6380</span>);</span><br><span class="line"></span><br><span class="line">        jedis_S.slaveof(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis_M.set(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;1122V2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String result = jedis_S.get(<span class="string">&quot;class&quot;</span>);<span class="comment">//可能有延迟，需再次启动才能使用</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="jedispool"   >
          <a href="#jedispool" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jedispool"></a> JedisPool</h3>
      
<ol>
<li>获取Jedis实例需要从JedisPool中获取</li>
<li>用完Jedis实例需要返还给JedisPool</li>
<li>如果Jedis在使用过程中出错，则也需要还给JedisPool</li>
</ol>
<p>饿汉模式下的JedisPool单例创建：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JedisPoolUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPoolInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (JedisPoolUtil.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">                    JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">                    poolConfig.setMaxActive(<span class="number">1000</span>);</span><br><span class="line">                    poolConfig.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">                    poolConfig.setMaxWait(<span class="number">100</span> * <span class="number">1000</span>);</span><br><span class="line">                    poolConfig.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                    jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(JedisPool jedisPool, Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">            jedisPool.returnResourceObject(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>测试：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JedisPool jedisPool = JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">        JedisPool jedisPool2 = JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(jedisPool == jedisPool2);</span><br><span class="line"></span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            jedis.set(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JedisPoolUtil.release(jedisPool, jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="jedispool-配置总结"   >
          <a href="#jedispool-配置总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jedispool-配置总结"></a> JedisPool 配置总结</h3>
      
<p>JedisPool的配置参数大部分是由<strong>JedisPoolConfig</strong>的对应项来赋值的。</p>
<ul>
<li><strong>maxActive</strong>：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted。</li>
<li><strong>maxIdle</strong>：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</li>
<li><strong>whenExhaustedAction</strong>：表示当pool中的jedis实例都被allocated完时，pool要采取的操作；默认有三种。
<ul>
<li><code>WHEN_EXHAUSTED_FAIL</code> --&gt; 表示无jedis实例时，直接抛出NoSuchElementException；</li>
<li><code>WHEN_EXHAUSTED_BLOCK</code> --&gt; 则表示阻塞住，或者达到maxWait时抛出JedisConnectionException；</li>
<li><code>WHEN_EXHAUSTED_GROW</code> --&gt; 则表示新建一个jedis实例，也就说设置的maxActive无用；</li>
</ul>
</li>
<li><strong>maxWait</strong>：表示当borrow一个jedis实例时，最大的等待时间，如果超过等待时间，则直接抛JedisConnectionException；</li>
<li><strong>testOnBorrow</strong>：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；</li>
<li><strong>testOnReturn</strong>：return 一个jedis实例给pool时，是否检查连接可用性（ping()）；</li>
<li><strong>testWhileIdle</strong>：如果为true，表示有一个idle object evitor线程对idle object进行扫描，如果validate失败，此object会被从pool中drop掉；这一项只有在timeBetweenEvictionRunsMillis大于0时才有意义；</li>
<li><strong>timeBetweenEvictionRunsMillis</strong>：表示idle object evitor两次扫描之间要sleep的毫秒数；</li>
<li><strong>numTestsPerEvictionRun</strong>：表示idle object evitor每次扫描的最多的对象数；</li>
<li><strong>minEvictableIdleTimeMillis</strong>：表示一个对象至少停留在idle状态的最短时间，然后才能被idle object evitor扫描并驱逐；这一项只有在timeBetweenEvictionRunsMillis大于0时才有意义；</li>
<li><strong>softMinEvictableIdleTimeMillis</strong>：在minEvictableIdleTimeMillis基础上，加入了至少minIdle个对象已经在pool里面了。如果为-1，evicted不会根据idle time驱逐任何对象。如果minEvictableIdleTimeMillis&gt;0，则此项设置无意义，且只有在timeBetweenEvictionRunsMillis大于0时才有意义；</li>
<li><strong>lifo</strong>：borrowObject返回对象时，是采用DEFAULT_LIFO（last in first out，即类似cache的最频繁使用队列），如果为False，则表示FIFO队列；</li>
</ul>
<p>其中JedisPoolConfig对一些参数的默认设置如下：</p>
<ul>
<li>testWhileIdle=true</li>
<li>minEvictableIdleTimeMills=60000</li>
<li>timeBetweenEvictionRunsMillis=30000</li>
<li>numTestsPerEvictionRun=-1</li>
</ul>

        <h2 id="redis-60-新功能"   >
          <a href="#redis-60-新功能" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-60-新功能"></a> Redis 6.0 新功能</h2>
      
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://yuyun-zhao.github.io">yuyun zhao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://yuyun-zhao.github.io/2021/09/09/%E3%80%90Redis%E3%80%91Redis/">http://yuyun-zhao.github.io/2021/09/09/%E3%80%90Redis%E3%80%91Redis/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.github.io/tags/Redis/">Redis</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/09/10/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">【操作系统】进程管理</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/09/08/%E3%80%90Redis%E3%80%91NoSQL%E4%BB%8B%E7%BB%8D/"><span class="paginator-prev__text">【Redis】NoSQL 介绍</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E7%AE%80%E4%BB%8B"><span class="toc-text">
           Redis 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">
           Redis 单线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E7%89%B9%E7%82%B9"><span class="toc-text">
           Redis 特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">
           Redis 五大数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-text">
           String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-text">
           List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-text">
           Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash"><span class="toc-text">
           Hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zset"><span class="toc-text">
           Zset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">
           实际应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string-2"><span class="toc-text">
           String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash-2"><span class="toc-text">
           Hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list-2"><span class="toc-text">
           List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-2"><span class="toc-text">
           Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zset-2"><span class="toc-text">
           Zset</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">
           Redis 新数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bitmaps"><span class="toc-text">
           Bitmaps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hyperloglog"><span class="toc-text">
           HyperLogLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#geospatial"><span class="toc-text">
           Geospatial</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">
           Redis 常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#key-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">
           Key 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-3"><span class="toc-text">
           String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list-3"><span class="toc-text">
           List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-3"><span class="toc-text">
           Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash-3"><span class="toc-text">
           Hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zset-3"><span class="toc-text">
           ZSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-text">
           Redis 配置文件介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-text">
           参数说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">
           Redis 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rdb"><span class="toc-text">
           RDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdb-%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE"><span class="toc-text">
           RDB 常见配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdb-%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="toc-text">
           RDB 优势与劣势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdb-%E5%B0%8F%E7%BB%93"><span class="toc-text">
           RDB 小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof"><span class="toc-text">
           AOF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof-%E6%8C%81%E4%B9%85%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-text">
           AOF 持久化流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof-%E5%90%8C%E6%AD%A5%E9%A2%91%E7%8E%87%E8%AE%BE%E7%BD%AE"><span class="toc-text">
           AOF 同步频率设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rewrite-%E9%87%8D%E5%86%99%E5%8E%8B%E7%BC%A9"><span class="toc-text">
           Rewrite 重写压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rewrite-%E5%8E%9F%E7%90%86"><span class="toc-text">
           Rewrite 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rewrite-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="toc-text">
           Rewrite 相关配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rewrite-%E6%B5%81%E7%A8%8B"><span class="toc-text">
           Rewrite 流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof-%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="toc-text">
           AOF 优势与劣势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof-%E5%B0%8F%E7%BB%93"><span class="toc-text">
           AOF 小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">
           总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-text">
           Redis 发布和订阅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E4%BA%8B%E5%8A%A1"><span class="toc-text">
           Redis 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">
           事务常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%B8%89%E9%98%B6%E6%AE%B5"><span class="toc-text">
           事务三阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watch"><span class="toc-text">
           WATCH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">
           悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">
           乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E4%BA%8B%E5%8A%A1%E4%B8%89%E7%89%B9%E6%80%A7"><span class="toc-text">
           Redis 事务三特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">
           Redis 主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">
           常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-text">
           薪火相传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="toc-text">
           反客为主</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">
           主从复制原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8Fsentinel"><span class="toc-text">
           Redis 哨兵模式（sentinel）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E6%9C%BA%E5%88%B6"><span class="toc-text">
           自动故障转移机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="toc-text">
           配置方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%BB%B6%E6%97%B6"><span class="toc-text">
           复制延时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5-leader-%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95"><span class="toc-text">
           哨兵 leader 选举算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E5%93%A8%E5%85%B5%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-text">
           Redis 哨兵主备切换的数据丢失问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF"><span class="toc-text">
           1. 异步复制时间过长</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%84%91%E8%A3%82"><span class="toc-text">
           2. 脑裂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6%E5%92%8C%E8%84%91%E8%A3%82%E5%AF%BC%E8%87%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1"><span class="toc-text">
           解决异步复制和脑裂导致的数据丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%87%8F%E5%B0%91%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1"><span class="toc-text">
           1. 减少异步复制的数据丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%8F%E5%B0%91%E8%84%91%E8%A3%82%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1"><span class="toc-text">
           2. 减少脑裂的数据丢失</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">
           总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-cluster-%E9%9B%86%E7%BE%A4"><span class="toc-text">
           Redis Cluster 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%87%BA"><span class="toc-text">
           问题引出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E7%BE%A4"><span class="toc-text">
           什么是集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slots-%E5%93%88%E5%B8%8C%E6%A7%BD"><span class="toc-text">
           slots 哈希槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-text">
           查询集群中的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-text">
           故障恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E4%BC%98%E7%82%B9"><span class="toc-text">
           集群优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%BC%BA%E7%82%B9"><span class="toc-text">
           集群缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-text">
           Redis 应用问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">
           缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-text">
           缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">
           缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">
           分布式锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jedis-%E4%BD%BF%E7%94%A8"><span class="toc-text">
           Jedis 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jedis-%E5%B8%B8%E7%94%A8-api"><span class="toc-text">
           Jedis 常用 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jedis-%E4%BA%8B%E5%8A%A1"><span class="toc-text">
           Jedis 事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jedis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">
           Jedis 主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jedispool"><span class="toc-text">
           JedisPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jedispool-%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93"><span class="toc-text">
           JedisPool 配置总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-60-%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-text">
           Redis 6.0 新功能</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/author.png" alt="avatar"></div><p class="sidebar-ov-author__text">no code no life</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YUYUN-ZHAO" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="zyy1024462136" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1024462136" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:im.yuyunzhao@gmail.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gmail</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">102</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">35</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">35</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>yuyun zhao</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.xml"></script></body></html>