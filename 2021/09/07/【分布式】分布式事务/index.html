<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="分布式事务        分布式事务，就是指不是在单个服务或单个数据库架构下，产生的事务：  跨数据源的分布式事务 跨服务的分布式事务 综合情况                       1）跨数据源        随着业务数据规模的快速发展，数据量越来越大，单库单表逐渐成为瓶颈。所以我们对数据库进行了水平拆分，将原单库单表拆分成数据库分片，于是就产生了跨数据库事务问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="【分布式】分布式事务">
<meta property="og:url" content="http://yuyun-zhao.github.io/2021/09/07/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/index.html">
<meta property="og:site_name" content="yuyun zhao&#39;s blog">
<meta property="og:description" content="分布式事务        分布式事务，就是指不是在单个服务或单个数据库架构下，产生的事务：  跨数据源的分布式事务 跨服务的分布式事务 综合情况                       1）跨数据源        随着业务数据规模的快速发展，数据量越来越大，单库单表逐渐成为瓶颈。所以我们对数据库进行了水平拆分，将原单库单表拆分成数据库分片，于是就产生了跨数据库事务问题。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304201018438-1631008633494.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304202639509-1631008633494.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304204442839-1631008633494.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304205842784-1631008633494.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/aHR0cHM6Ly9naXRlZS5jb20vamFsbGVua3dvbmcvTGVhcm5SZWRpcy9yYXcvbWFzdGVyL2ltYWdlLzIwLnBuZw">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210120471-1631008633494.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210414309-1631008633494.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210506575-1631008633494.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210521364-1631008633494.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210540168-1631008633494.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210557117-1631008633494.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305141029973.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305141318326.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305142812815.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305155521612.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305155830732.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305181454125.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305183431211.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305200131083.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305205430863.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305212340203.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305213652558.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305214649845.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/1561965208439-606129fe-6761-4177-8887-1fda9306f104.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/1561960344792-8810110b-1eda-4417-944e-7051ca52f90d.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305230513415.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305225811888-1631068234111.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305225811888.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/302377d33ddcd708e20b996bd9f2c7b8.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/302377d33ddcd708e20b996bd9f2c7b8.png">
<meta property="article:published_time" content="2021-09-07T09:50:32.000Z">
<meta property="article:modified_time" content="2022-03-13T01:51:59.727Z">
<meta property="article:author" content="yuyun zhao">
<meta property="article:tag" content="分布式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304201018438-1631008633494.png"><title>【分布式】分布式事务 | yuyun zhao's blog</title><link ref="canonical" href="http://yuyun-zhao.github.io/2021/09/07/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">文章</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">yuyun zhao's blog</div><div class="header-banner-info__subtitle">no code no life</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">【分布式】分布式事务</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">11k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">60分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h2 id="分布式事务"   >
          <a href="#分布式事务" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#分布式事务"></a> 分布式事务</h2>
      
<p>分布式事务，就是指不是在单个服务或单个数据库架构下，产生的事务：</p>
<ul>
<li>跨数据源的分布式事务</li>
<li>跨服务的分布式事务</li>
<li>综合情况</li>
</ul>

        <h3 id="1跨数据源"   >
          <a href="#1跨数据源" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#1跨数据源"></a> 1）跨数据源</h3>
      
<p>随着业务数据规模的快速发展，数据量越来越大，单库单表逐渐成为瓶颈。所以我们对数据库进行了水平拆分，将原单库单表拆分成数据库分片，于是就产生了跨数据库事务问题。</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304201018438-1631008633494.png" alt="image-20200304201018438" /></p>

        <h3 id="2跨服务"   >
          <a href="#2跨服务" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#2跨服务"></a> 2）跨服务</h3>
      
<p>在业务发展初期，“一块大饼”的单业务系统架构，能满足基本的业务需求。但是随着业务的快速发展，系统的访问量和业务复杂程度都在快速增长，单系统架构逐渐成为业务发展瓶颈，解决业务系统的高耦合、可伸缩问题的需求越来越强烈。</p>
<p>如下图所示，按照面向服务（SOA）的架构的设计原则，将单业务系统拆分成多个业务系统，降低了各系统之间的耦合度，使不同的业务系统专注于自身业务，更有利于业务的发展和系统容量的伸缩。</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304202639509-1631008633494.png" alt="image-20200304202639509" /></p>
<span id="more"></span>

        <h3 id="3分布式系统的数据一致性问题"   >
          <a href="#3分布式系统的数据一致性问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#3分布式系统的数据一致性问题"></a> 3）分布式系统的数据一致性问题</h3>
      
<p>在数据库水平拆分、服务垂直拆分之后，一个业务操作通常要跨多个数据库、服务才能完成。在分布式网络环境下，我们无法保障所有服务、数据库都百分百可用，一定会出现部分服务、数据库执行成功，另一部分执行失败的问题。</p>
<p>当出现部分业务操作成功、部分业务操作失败时，业务数据就会出现不一致。例如电商行业中比较常见的下单付款案例，包括下面几个行为：</p>
<ul>
<li>创建新订单</li>
<li>扣减商品库存</li>
<li>从用户账户余额扣除金额</li>
</ul>
<p>完成上面的操作需要访问三个不同的微服务和三个不同的数据库。</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304204442839-1631008633494.png" alt="image-20200304204442839" /></p>
<p>在分布式环境下，肯定会出现部分操作成功、部分操作失败的问题，比如：订单生成了，库存也扣减了，但是用户账户的余额不足，这就造成数据不一致。订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证ACID原则。</p>
<p>但是当我们把三件事情看做一个事情事，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，不允许出现部分成功部分失败的现象，这就是分布式系统下的事务了。</p>
<p>此时ACID难以满足，这是分布式事务要解决的问题。为什么分布式系统下，事务的ACID原则难以满足？这得从<strong>CAP定理</strong>和<strong>BASE理论</strong>说起。</p>

        <h2 id="cap-定理"   >
          <a href="#cap-定理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cap-定理"></a> CAP 定理</h2>
      
<blockquote>
<p>本小节内容摘自：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2018/07/cap.html" >CAP 定理的含义</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>什么是CAP定理呢？</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304205842784-1631008633494.png" alt="image-20200304205842784" /></p>
<p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</p>
<ul>
<li><strong>Consistency（一致性）</strong></li>
<li><strong>Availability（可用性）</strong></li>
<li><strong>Partition tolerance （分区容错性）</strong></li>
</ul>
<p>它们的第一个字母分别是 C、A、P。Eric Brewer 说，这三个指标<strong>不可能同时做到</strong>。这个结论就叫做 CAP 定理。</p>
<p>由于当前的网络硬件肯定会出现延迟丢包等问题，所以<strong>分区容忍性</strong>是我们必须需要实现的。所以我们只能在<strong>一致性</strong>和<strong>可用性</strong>之间进行权衡，<strong>没有</strong>NoSQL系统能同时保证这三点。</p>
<ul>
<li>CA：传统Oracle数据库</li>
<li>AP：大多数网站架构的选择</li>
<li>CP：Redis、Mongodb</li>
</ul>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/aHR0cHM6Ly9naXRlZS5jb20vamFsbGVua3dvbmcvTGVhcm5SZWRpcy9yYXcvbWFzdGVyL2ltYWdlLzIwLnBuZw" alt="img" /></p>

        <h3 id="partition-tolerance"   >
          <a href="#partition-tolerance" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#partition-tolerance"></a> Partition tolerance</h3>
      
<p>先看 Partition tolerance，中文叫做&quot;分区容错&quot;。</p>
<p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分<strong>区容错的意思是，区间通信可能失败</strong>。比如，一台服务器放在上海，另一台服务器放在北京，这就是两个区，它们之间可能因网络问题无法通信。如图：</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210120471-1631008633494.png" alt="image-20200304210120471" /></p>
<p>上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。</p>
<p>一般来说，分布式系统，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。根据CAP 定理，剩下的 C 和 A 无法同时做到。</p>

        <h3 id="consistency"   >
          <a href="#consistency" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#consistency"></a> Consistency</h3>
      
<p>Consistency 中文叫做&quot;一致性&quot;。意思是，<strong>写操作之后的读操作，必须返回该值</strong>。举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210414309-1631008633494.png" alt="image-20200304210414309" /></p>
<p>接下来，用户的读操作就会得到 v1。这就叫一致性。</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210506575-1631008633494.png" alt="image-20200304210506575" /></p>
<p>问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210521364-1631008633494.png" alt="image-20200304210521364" /></p>
<p>为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210540168-1631008633494.png" alt="image-20200304210540168" /></p>
<p>这样的话，用户向 G2 发起读操作，也能得到 v1。</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210557117-1631008633494.png" alt="image-20200304210557117" /></p>

        <h3 id="availability"   >
          <a href="#availability" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#availability"></a> Availability</h3>
      
<p>Availability 中文叫做&quot;可用性&quot;，意思是<strong>只要收到用户的请求，服务器就必须给出回应（对和错不论）</strong>。</p>
<p>用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。</p>

        <h3 id="consistency-和-availability-的矛盾"   >
          <a href="#consistency-和-availability-的矛盾" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#consistency-和-availability-的矛盾"></a> Consistency 和 Availability 的矛盾</h3>
      
<p>一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。</p>
<ul>
<li>如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。</li>
<li>如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。</li>
</ul>
<p>综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。</p>

        <h3 id="几点疑问"   >
          <a href="#几点疑问" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#几点疑问"></a> 几点疑问</h3>
      
<ul>
<li>怎样才能同时满足CA？除非是单点架构。</li>
<li>何时要满足CP？对一致性要求高的场景。例如我们的Zookeeper就是这样的，在服务节点间数据同步时，服务对外不可用。</li>
<li>何时满足AP？对可用性要求较高的场景。例如Eureka，必须保证注册中心随时可用，不然拉取不到服务就可能出问题。</li>
</ul>

        <h2 id="base-理论"   >
          <a href="#base-理论" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#base-理论"></a> BASE 理论</h2>
      
<p>BASE理论是对CAP理论的延伸，思想是即使无法做到强一致性（CAP的一致性就是强一致性），但是可以采用适当的弱一致性，即<strong>最终一致性</strong>。BASE就是为了解决关系数据库强一致性而引起的可用性降低问题（即为了满足CP，导致A降低）而提出的解决方案。它的思想是通过<strong>让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观</strong>。</p>
<p>BASE是三个单词的缩写：</p>
<ul>
<li><strong>Basically Available</strong>（基本可用）：基本可用是指分布式系统中在出现故障的时候，<strong>允许损失部分可用性</strong>（例如响应时间，功能上的可用性）。需要注意的是基本可用不等价于系统不可用。服务在等待同步的一小段时间内是不可用的，所以只是基本可用。即一两个节点的不可用不能影响整个系统的不可用（这个节点宕机了去查其他节点也行，只要有能用的就可以，慢一些也无所谓。不必所有节点都得可用）
<ul>
<li><strong>响应时间</strong>上的损失：正常情况下搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房断电断网故障），查询的结果响应时间增加到了1~2秒</li>
<li><strong>功能</strong>上的损失：购物网站双十一购物高峰，为了保证系统的稳定性，部分消费者会被引入到一个降级页面</li>
</ul>
</li>
<li><strong>Soft state</strong>（软状态）：不像强一致性系统只有两个状态，要么成功要么失败。软状态是指允许 系统存在<strong>中间状态</strong>（“<strong>正在同步中</strong>”状态），而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体现。MySQL 主从复制的<strong>异步复制</strong>就是一种体现。也就是说：<strong>系统允许有延迟，等待一定时间后能保证数据一致即可</strong>。</li>
<li><strong>Eventually consistent</strong>（最终一致性）：最终致性是指系统中的<strong>所有数据副本经过一定时间后，最终能够达到一致的状态</strong>。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。不是数据立刻一致，而是等一段时间后一致，最终结果是一致的即可。</li>
</ul>

        <h3 id="强一致性-弱一致性-最终一致性"   >
          <a href="#强一致性-弱一致性-最终一致性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#强一致性-弱一致性-最终一致性"></a> 强一致性、弱一致性、最终一致性</h3>
      
<p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，</p>
<ul>
<li>要求更新过的数据能被后续的访问都能看到，这是<strong>强一致性</strong></li>
<li>如果能容忍后续的部分或者全部访问不到，则是<strong>弱一致性</strong></li>
<li>如果经过一段时间后要求能访问到更新后的数据，则是<strong>最终一致性</strong></li>
</ul>

        <h3 id="173-分布式事务"   >
          <a href="#173-分布式事务" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#173-分布式事务"></a> 17.3 分布式事务</h3>
      
<p>我们解决分布式事务就是根据上述理论来实现。还以上面的下单减库存和扣款为例：订单服务、库存服务、用户服务及他们对应的数据库就是分布式应用中的三个部分。</p>
<ul>
<li><strong>CP方式</strong>：现在如果要满足事务的强一致性，就必须在订单服务数据库锁定的同时，对库存服务、用户服务数据资源同时锁定。等待三个服务业务全部处理完成，才可以释放资源。此时如果有其他请求想要操作被锁定的资源就会被阻塞，这样就是满足了CP。这就是强一致，弱可用</li>
<li><strong>AP方式</strong>：三个服务的对应数据库各自独立执行自己的业务，执行本地事务，不要求互相锁定资源。但是这个中间状态下，我们去访问数据库，可能遇到数据不一致的情况，不过我们需要做一些后补措施，<strong>保证在经过一段时间后，数据最终满足一致性</strong>，例如高峰期视频的点击量等数据不需要强一致性，但要保证高可用。又例如订单服务下单成功后，库存服务锁库存失败，此时不要求订单服务立即回滚保证一致，而是可以允许等待一定时间后再将该订单数据删除以保证最终一致。这就是高可用，但弱一致（最终一致）。</li>
</ul>
<p>由上面的两种思想，延伸出了很多的分布式事务解决方案：</p>
<ul>
<li><strong>XA</strong></li>
<li><strong>TCC</strong></li>
<li><strong>可靠消息最终一致</strong></li>
<li><strong>AT</strong></li>
</ul>
<p>下文将逐一介绍这些解决方案。</p>

        <h2 id="2pc-二阶段提交"   >
          <a href="#2pc-二阶段提交" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#2pc-二阶段提交"></a> 2PC 二阶段提交</h2>
      
<blockquote>
<p>参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35298019" >漫话分布式系统共识协议: 2PC/3PC篇</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h3 id="xa"   >
          <a href="#xa" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#xa"></a> XA</h3>
      
<p>分布式事务的解决手段之一，就是<strong>二阶段提交协议</strong>（2PC：Two-Phase Commit）</p>
<p>1994 年，X/Open 组织（即现在的 Open Group ）定义了分布式事务处理的 DTP 模型。该模型包括这样几个角色：</p>
<ul>
<li><strong>应用程序（ AP ）</strong>：我们的微服务</li>
<li><strong>事务管理器（ TM ）</strong>：全局事务管理者</li>
<li><strong>资源管理器（ RM ）</strong>：一般是数据库</li>
<li><strong>通信资源管理器（ CRM ）</strong>：是TM和RM间的<strong>通信中间件</strong></li>
</ul>
<p>在该模型中，一个分布式事务（全局事务）可以被拆分成许多个本地事务，运行在不同的AP和RM上。每个本地事务的ACID很好实现，但是全局事务必须保证其中包含的每一个本地事务都能同时成功，若有一个本地事务失败，则所有其它事务都必须回滚。但问题是，本地事务处理过程中，并不知道其它事务的运行状态。因此，就需要通过CRM来通知各个本地事务，同步事务执行的状态。</p>
<p>因此，各个本地事务的通信必须有统一的标准，否则不同数据库间就无法通信。<strong>XA</strong> 就是 X/Open DTP中通信中间件与TM间联系的<strong>接口规范</strong>，定义了用于通知事务开始、提交、终止、回滚等接口，各个数据库厂商都必须实现这些接口。</p>

        <h3 id="二阶段提交协议"   >
          <a href="#二阶段提交协议" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二阶段提交协议"></a> 二阶段提交协议</h3>
      
<p><strong>二阶段提交协议</strong>（2 Phase Commit）就是根据XA Transactions这一思想衍生出来的，将全局事务拆分为两个阶段来执行：</p>
<ul>
<li>阶段一：准备阶段，各个本地事务完成本地事务的准备工作。</li>
<li>阶段二：执行阶段，各个本地事务根据上一阶段执行结果，进行提交或回滚。</li>
</ul>
<p>这个过程中需要一个协调者（coordinator），还有事务的参与者（voter）。二阶段提交是一个<strong>刚性事务</strong>。</p>

        <h3 id="正常情况"   >
          <a href="#正常情况" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#正常情况"></a> 正常情况</h3>
      
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305141029973.png" alt="image-20200305141029973" /></p>
<ul>
<li><strong>投票阶段</strong>：协调组询问各个事务参与者，是否可以执行事务。每个事务参与者执行事务，写入redo和undo日志，然后反馈事务执行成功的信息（<code>agree</code>）</li>
<li><strong>提交阶段</strong>：协调组发现每个参与者都可以执行事务（<code>agree</code>），于是向各个事务参与者发出<code>commit</code>指令，各个事务参与者提交事务。</li>
</ul>

        <h3 id="异常情况"   >
          <a href="#异常情况" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#异常情况"></a> 异常情况</h3>
      
<p>当然，也有异常的时候：</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305141318326.png" alt="image-20200305141318326" /></p>
<ul>
<li><strong>投票阶段</strong>：协调组询问各个事务参与者，是否可以执行事务。每个事务参与者执行事务，写入redo和undo日志，然后反馈事务执行结果，但只要有一个参与者返回的是<code>Disagree</code>，则说明执行失败。</li>
<li><strong>提交阶段</strong>：协调组发现有一个或多个参与者返回的是<code>Disagree</code>，认为执行失败。于是向各个事务参与者发出<code>abort</code>指令，各个事务参与者回滚事务。</li>
</ul>
<p>3PC 在 2PC 的基础上引入了<strong>超时机制</strong>：无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理</p>

        <h3 id="缺陷"   >
          <a href="#缺陷" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#缺陷"></a> 缺陷</h3>
      
<p>二阶段提交的问题：</p>
<p><strong>1. 单点故障问题</strong></p>
<p>2PC的缺点在于不能处理<code>fail-stop</code>形式的节点failure，即coordinator在提交阶段宕机时，voters不能得知其他事务到底是执行成功还是失败。比如下图这种情况：</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305142812815.png" alt="image-20200305142812815" /></p>
<p>假设coordinator和voter3都在Commit这个阶段crash了, 而voter1和voter2没有收到commit消息. 这时候voter1和voter2就陷入了一个困境. 因为他们并不能判断现在是两个场景中的哪一种：</p>
<ul>
<li>上轮全票通过然后voter3第一个收到了commit的消息并在commit操作之后crash了</li>
<li>上轮voter3反对所以干脆没有通过。</li>
</ul>
<p><strong>2. 阻塞问题</strong></p>
<p>在准备阶段、提交阶段，每个事务参与者都会<strong>锁定本地资源</strong>，<strong>并等待其它事务的执行结果</strong>，阻塞时间较长，资源锁定时间太久，因此执行的效率就比较低了，在高并发情境下基本无法工作。</p>
<p>面对二阶段提交的上述缺点，后来又演变出了三阶段提交，但是依然没有完全解决阻塞和资源锁定的问题，而且引入了一些新的问题，因此实际使用的场景较少。</p>

        <h3 id="使用场景"   >
          <a href="#使用场景" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3>
      
<p><strong>对事务有强一致性要求</strong>，对事务执行效率不敏感，并且不希望有太多代码侵入。</p>

        <h2 id="tcc-事务补偿型方案"   >
          <a href="#tcc-事务补偿型方案" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tcc-事务补偿型方案"></a> TCC - 事务补偿型方案</h2>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.zhdba.com/mysqlops/2012/04/06/innodb-log1/" >http://www.zhdba.com/mysqlops/2012/04/06/innodb-log1/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>TCC模式可以解决2PC中的资源锁定和阻塞问题，减少资源锁定时间。TCC是一种<strong>柔性事务</strong>。它是一种<strong>事务补偿型方案</strong>，使用补偿的思路。</p>
<hr />
<p>刚性事务与柔性事务</p>
<ul>
<li>刚性事务：遵循ACID原则，强一致性</li>
<li>柔性事务：遵循BASE理论，最终一致性</li>
</ul>
<p>与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。</p>
<hr />

        <h3 id="基本原理"   >
          <a href="#基本原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h3>
      
<p>它本质是一种<strong>补偿</strong>的思路。事务运行过程包括三个方法：</p>
<ul>
<li><strong>Try</strong>：资源的检测和预留；</li>
<li><strong>Confirm</strong>：执行的业务操作提交；要求 Try 成功 Confirm 一定要能成功；</li>
<li><strong>Cancel</strong>：预留资源释放。</li>
</ul>
<p>执行分两个阶段：</p>
<ul>
<li><strong>准备阶段（try）</strong>：资源的检测和预留；</li>
<li><strong>执行阶段（confirm/cancel）</strong>：根据上一步结果，判断下面的执行方法。如果上一步中所有事务参与者都成功，则这里执行confirm。反之，执行cancel</li>
</ul>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305155521612.png" alt="image-20200305155521612" /></p>
<p>粗看似乎与两阶段提交没什么区别，但其实差别很大：</p>
<ul>
<li>try、confirm、cancel都是<strong>独立的事务</strong>，不受其它参与者的影响，<strong>不会阻塞等待</strong></li>
<li>try、confirm、cancel由程序员在业务层编写，锁粒度有代码控制</li>
</ul>

        <h3 id="实例"   >
          <a href="#实例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#实例"></a> 实例</h3>
      
<p>我们以之前的下单业务中的扣减余额为例来看下三个不同的方法要怎么编写，假设账户A原来余额是100，需要余额扣减30元。如图：</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305155830732.png" alt="image-20200305155830732" /></p>
<p>一阶段（Try）：余额检查，并冻结用户部分金额，此阶段执行完毕，<strong>事务已经提交</strong></p>
<ul>
<li>检查用户余额是否充足，如果充足，冻结部分余额</li>
<li><strong>在账户表中添加冻结金额字段</strong>，值为30，余额不变</li>
</ul>
<p>二阶段：提交或补偿</p>
<ul>
<li><strong>提交（Confirm）</strong>：真正的扣款，把冻结金额从余额中扣除，冻结金额清空
<ul>
<li>修改冻结金额为0，修改余额为100-30 = 70元</li>
</ul>
</li>
<li><strong>补偿（Cancel）</strong>：释放之前冻结的金额，<strong>并非回滚</strong>
<ul>
<li>余额不变，修改账户冻结金额为0</li>
</ul>
</li>
</ul>
<p>总结：一阶段不修改真实的字段，只修改添加的冻结金额字段；二阶段若提交则修改真实字段，清除冻结金额字段，若失败则只需清除冻结金额字段</p>

        <h3 id="优点"   >
          <a href="#优点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3>
      
<p>TCC执行的每一个阶段都会提交本地事务并释放锁，并<strong>不需要等待其它事务的执行结果</strong>。而如果其它事务执行失败，<strong>最后不是回滚，而是执行补偿操作</strong>。这样就<strong>避免了资源的长期锁定和阻塞等待</strong>，<strong>执行效率比较高</strong>，属于<strong>性能比较好</strong>的分布式事务方式。</p>

        <h3 id="缺点"   >
          <a href="#缺点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3>
      
<ul>
<li>代码侵入：需要<strong>人为编写</strong>代码实现try、confirm、cancel，代码侵入较多</li>
<li>开发成本高：一个业务需要拆分成3个步骤，分别编写业务实现，业务编写比较复杂</li>
<li>安全性考虑：cancel动作如果执行失败，资源就无法释放，需要引入重试机制，而重试可能导致重复执行，还要考虑重试时的幂等问题</li>
</ul>

        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
      
<p>每个单独的事务是强一致，但<strong>整体不是强一致</strong>（因为一阶段中每个事务都会立即提交，不会等待其他的事务一起提交，这样如果其他的事务失败了就不是整体强一致，还需要再在二阶段<strong>手动写补偿</strong>的代码把一阶段提交的额外字段数据给补偿掉）</p>

        <h3 id="使用场景-2"   >
          <a href="#使用场景-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#使用场景-2"></a> 使用场景</h3>
      
<ul>
<li>对事务有一定的一致性要求（最终一致）</li>
<li>对性能要求较高</li>
<li>开发人员具备较高的编码能力和幂等处理经验</li>
</ul>

        <h2 id="可靠消息服务-最大努力通知型方案"   >
          <a href="#可靠消息服务-最大努力通知型方案" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#可靠消息服务-最大努力通知型方案"></a> 可靠消息服务 - 最大努力通知型方案</h2>
      
<p>这种实现方式的思路，其实是源于ebay，其基本的设计思想是将远程分布式事务拆分成一系列的本地事务，一旦某个服务执行失败，就使用<strong>消息队列</strong>通知其他服务进行回滚，之所以叫最大通知型是因为他会不断地发送消息直到其他服务受到该消息后进行回滚。它也是一种<strong>柔性事务</strong>。</p>
<p>按规律进行通知，<strong>不保证数据一定能通知成功，但会提供可查询操作接口进行核对</strong>。这种方案主要用在与第三方系统通讯时，比如调用微信或支付宝支付后的支付结果通知。这种方案也是结合MQ进行实现。例如：通过MQ发送http请求，设置最大通知次数。达到通知次数后即不再通知。</p>
<p>案例：银行通知、商户通知等（各大交易业务平台间的商户通知：多次通知、查询校对、对账文件），支付宝的支付成功异步回调</p>

        <h3 id="基本原理-2"   >
          <a href="#基本原理-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#基本原理-2"></a> 基本原理</h3>
      
<p>一般分为事务的发起者A和事务的其它参与者B：</p>
<ul>
<li>事务发起者A执行本地事务</li>
<li>事务发起者A通过<strong>消息队列MQ</strong>将需要执行的事务信息发送给事务参与者B</li>
<li>事务参与者B事先订阅该消息队列，在接收到消息后执行本地事务，若失败则一直重试执行事务</li>
</ul>
<p>如图：</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305181454125.png" alt="image-20200305181454125" /></p>
<p>这个过程有点像你去学校食堂吃饭：</p>
<ul>
<li>拿着钱去收银处，点一份红烧牛肉面，付钱</li>
<li>收银处给你发一个小票，还有一个号牌，你别把票弄丢！</li>
<li>你凭小票和号牌一定能领到一份红烧牛肉面，不管需要多久</li>
</ul>
<p>几个注意事项：</p>
<ul>
<li>事务发起者A必须确保本地事务成功后，消息一定发送成功</li>
<li>MQ必须保证消息正确投递和持久化保存</li>
<li>事务参与者B必须确保消息<strong>最终一定能消费</strong>，<strong>如果失败需要多次重试</strong>，时效性可能比较差</li>
<li>事务B执行失败，会一直重试，但<strong>不会导致事务A回滚</strong></li>
</ul>
<p>那么问题来了，我们如何保证消息发送一定成功？如何保证消费者一定能收到消息？</p>

        <h3 id="本地消息表"   >
          <a href="#本地消息表" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#本地消息表"></a> 本地消息表</h3>
      
<p>为了避免消息发送失败或丢失，我们可以把消息持久化到数据库中。实现时有简化版本和解耦合版本两种方式。</p>

        <h4 id="简化版本"   >
          <a href="#简化版本" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#简化版本"></a> 简化版本</h4>
      
<p>原理图：</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305183431211.png" alt="image-20200305183431211" /></p>
<ul>
<li>
<p>事务发起者：</p>
<ul>
<li>开启本地事务</li>
<li>执行事务相关业务</li>
<li>发送消息到MQ</li>
<li>把消息持久化到数据库，标记为已发送</li>
<li>提交本地事务</li>
</ul>
</li>
<li>
<p>事务接收者：</p>
<ul>
<li>接收消息</li>
<li>开启本地事务</li>
<li>处理事务相关业务</li>
<li>修改数据库消息状态为已消费</li>
<li>提交本地事务</li>
</ul>
</li>
<li>
<p>额外的定时任务</p>
<ul>
<li>定时扫描表中超时未消费消息，重新发送</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：与tcc相比，实现方式较为简单，开发成本低。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>数据一致性完全依赖于消息服务，因此消息服务必须是可靠的。</li>
<li>需要处理被动业务方的幂等问题</li>
<li>被动业务失败不会导致主动业务的回滚，而是重试被动的业务</li>
<li><strong>事务业务与消息发送业务耦合</strong>、业务数据与消息表要在一起</li>
</ul>

        <h4 id="独立消息服务"   >
          <a href="#独立消息服务" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#独立消息服务"></a> 独立消息服务</h4>
      
<p>为了解决上述问题，我们会引入一个独立的消息服务，来完成对消息的持久化、发送、确认、失败重试等一系列行为，大概的模型如下：</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305200131083.png" alt="image-20200305200131083" /></p>
<p>一次消息发送的时序图：</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305205430863.png" alt="image-20200305205430863" /></p>
<p>事务发起者A的基本执行步骤：</p>
<ul>
<li>开启本地事务</li>
<li>通知消息服务，准备发送消息（消息服务将消息持久化，标记为准备发送）</li>
<li>执行本地业务，
<ul>
<li>执行失败则终止，通知消息服务，取消发送（消息服务修改订单状态）</li>
<li>执行成功则继续，通知消息服务，确认发送（消息服务发送消息、修改订单状态）</li>
</ul>
</li>
<li>提交本地事务</li>
</ul>
<p>消息服务本身提供下面的接口：</p>
<ul>
<li>准备发送：把消息持久化到数据库，并标记状态为准备发送</li>
<li>取消发送：把数据库消息状态修改为取消</li>
<li>确认发送：把数据库消息状态修改为确认发送。尝试发送消息，成功后修改状态为已发送</li>
<li>确认消费：消费者已经接收并处理消息，把数据库消息状态修改为已消费</li>
<li>定时任务：定时扫描数据库中状态为确认发送的消息，然后询问对应的事务发起者，事务业务执行是否成功，结果：
<ul>
<li>业务执行成功：尝试发送消息，成功后修改状态为已发送</li>
<li>业务执行失败：把数据库消息状态修改为取消</li>
</ul>
</li>
</ul>
<p>事务参与者B的基本步骤：</p>
<ul>
<li>接收消息</li>
<li>开启本地事务</li>
<li>执行业务</li>
<li>通知消息服务，消息已经接收和处理</li>
<li>提交事务</li>
</ul>
<p><strong>优点：</strong> 解除了事务业务与消息相关业务的耦合</p>
<p><strong>缺点：</strong> 实现起来比较复杂</p>

        <h3 id="rocketmq-事务消息"   >
          <a href="#rocketmq-事务消息" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rocketmq-事务消息"></a> RocketMQ 事务消息</h3>
      
<p>RocketMQ本身自带了事务消息，可以保证消息的可靠性，原理其实就是<strong>自带了本地消息表</strong>，与上面的思路类似。</p>

        <h3 id="rabbitmq-的消息确认"   >
          <a href="#rabbitmq-的消息确认" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-的消息确认"></a> RabbitMQ 的消息确认</h3>
      
<p>RabbitMQ 确保消息不丢失的思路比较奇特，并没有使用传统的本地表，而是利用了消息的确认机制：</p>
<ul>
<li>生产者确认机制：确保消息从生产者到达MQ不会有问题
<ul>
<li>消息生产者发送消息到RabbitMQ时，可以设置一个异步的监听器，监听来自MQ的ACK</li>
<li>MQ接收到消息后，会返回一个回执给生产者：
<ul>
<li>消息到达交换机后路由失败，会返回失败ACK</li>
<li>消息路由成功，持久化失败，会返回失败ACK</li>
<li>消息路由成功，持久化成功，会返回成功ACK</li>
</ul>
</li>
<li>生产者提前编写好不同回执的处理方式
<ul>
<li><strong>失败回执：等待一定时间后重新发送</strong></li>
<li>成功回执：记录日志等行为</li>
</ul>
</li>
</ul>
</li>
<li>消费者确认机制：确保消息能够被消费者正确消费
<ul>
<li>消费者需要在监听队列的时候指定<strong>手动ACK模式</strong></li>
<li>RabbitMQ把消息投递给消费者后，会等待消费者ACK，<strong>接收到ACK后才删除消息</strong>，如果没有接收到ACK消息会一直保留在服务端，如果消费者断开连接或异常后，消息会投递给其它消费者。</li>
<li>消费者处理完消息，提交事务后，手动ACK。如果执行过程中抛出异常，则不会ACK，业务处理失败，等待下一条消息</li>
</ul>
</li>
</ul>
<p>经过上面的两种确认机制，可以确保从消息生产者到消费者的消息安全，再结合生产者和消费者两端的本地事务，即可保证一个分布式事务的最终一致性。</p>

        <h3 id="消息事务的优缺点"   >
          <a href="#消息事务的优缺点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消息事务的优缺点"></a> 消息事务的优缺点</h3>
      
<p>总结上面的几种模型，消息事务的优缺点如下：</p>
<ul>
<li>优点：
<ul>
<li>业务相对简单，不需要编写三个阶段业务</li>
<li>是多个本地事务的结合，因此资源锁定周期短，性能好</li>
</ul>
</li>
<li>缺点：
<ul>
<li>代码侵入</li>
<li>依赖于MQ的可靠性</li>
<li>消息发起者可以回滚，但是消息参与者无法引起事务回滚</li>
<li>事务时效性差，取决于MQ消息发送是否及时，还有消息参与者的执行情况</li>
</ul>
</li>
</ul>

        <h2 id="at自动提交模式"   >
          <a href="#at自动提交模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#at自动提交模式"></a> AT（自动提交）模式</h2>
      
<blockquote>
<p>Seata <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/dev/mode/at-mode.html" >官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>
</blockquote>
<p>2019年 1 月份，Seata 开源了 AT（<strong>Auto Transaction</strong>）模式。AT 模式是一种<strong>无侵入</strong>的分布式事务解决方案。可以看做是<strong>对TCC或者二阶段提交模型的一种优化</strong>，解决了TCC模式中的代码侵入、编码复杂等问题。</p>
<p>在 AT 模式下，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架<strong>会自动生成事务的二阶段提交和回滚操作</strong>。</p>
<p>但是，<strong>AT 模式不适合高并发场景</strong>，其吞吐量和并发非常低。这是因为其需要<strong>给数据库添加全局行锁</strong>，并且频繁删除 before image 和 after image，这就会导致并发降低。</p>

        <h3 id="基本原理-3"   >
          <a href="#基本原理-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#基本原理-3"></a> 基本原理</h3>
      
<p>流程图：</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305212340203.png" alt="image-20200305212340203" /></p>
<p>有没有感觉跟TCC的执行很像，都是分两个阶段：</p>
<ul>
<li>一阶段：执行本地事务，并返回执行结果</li>
<li>二阶段：根据一阶段的结果，判断二阶段做法是提交还是回滚</li>
</ul>
<p>但AT模式底层做的事情可完全不同，而且第二阶段<strong>根本不需要我们编写，全部有Seata自己实现了</strong>。也就是说：我们写的<strong>代码与本地事务时代码一样</strong>，无需手动处理分布式事务。</p>
<p>那么，AT模式如何实现无代码侵入，如何帮我们自动实现二阶段代码的呢？</p>

        <h3 id="一阶段"   >
          <a href="#一阶段" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#一阶段"></a> 一阶段</h3>
      
<p>在一阶段，Seata 会<strong>拦截“业务 SQL”</strong>：</p>
<ul>
<li>首先解析 SQL 语义，根据SQL语义找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将这些要更新的数据保存成“<strong>before image</strong>”（前镜像，undo log，用于二阶段回滚时恢复原数据）</li>
<li>然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将这些更新后的数据保存成“<strong>after image</strong>”（后镜像，redo log，其用于二阶段回滚前对比当前数据有无被脏写）</li>
<li>将<strong>前后镜像</strong>数据以及<strong>业务 SQL 相关的信息</strong>组成一条回滚日志记录，插入到 <code>UNDO_LOG</code> 表中（数据库中除了业务表还需要准备一张 <code>UNDO_LOG</code> 表存放这些回滚日志，用于回滚时利用记录的SQL语句与前镜像进行回滚补偿）。</li>
<li>最后获取<strong>全局行锁</strong>，<strong>立即提交事务（不阻塞）</strong>。</li>
</ul>
<p>以上操作全部<strong>在一个数据库事务内完成</strong>，这样保证了一阶段操作的<strong>原子性</strong>。这里的<code>before image</code>和<code>after image</code>类似于数据库的<strong>undo</strong>和<strong>redo</strong>日志，但其实<strong>是用数据库模拟的</strong>，即将undo和redo日志保存到日志Log表里。</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305213652558.png" alt="image-20200305213652558" /></p>

        <h3 id="二阶段-提交"   >
          <a href="#二阶段-提交" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二阶段-提交"></a> 二阶段 提交</h3>
      
<p>二阶段如果是提交的话，因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段<strong>保存的快照数据和行锁删掉，完成数据清理即可</strong>。</p>

        <h3 id="二阶段-回滚"   >
          <a href="#二阶段-回滚" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二阶段-回滚"></a> 二阶段 回滚</h3>
      
<p>二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。回滚方式便是用“<strong>before image</strong>”还原业务数据。</p>
<p>但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “<strong>after image</strong>”，<strong>如果两份数据完全一致就说明没有脏写</strong>，可以还原业务数据，如果不一致就说明有<strong>脏写</strong>，出现脏写就需要转人工处理。不过因为有<strong>全局锁</strong>机制，所以可以降低出现<strong>脏写</strong>的概率。</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305214649845.png" alt="image-20200305214649845" /></p>
<p>AT 模式的一阶段、二阶段提交和回滚<strong>均由 Seata 框架自动生成</strong>，用户只需编写“业务 SQL”，便能轻松接入分布式事务，AT 模式是一种对业务<strong>无任何侵入</strong>的分布式事务解决方案。AT 模式的补偿等操作是框架<strong>自动实现</strong>，TCC 则需要<strong>手动添加补偿代码</strong>。</p>

        <h3 id="优缺点"   >
          <a href="#优缺点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h3>
      
<p>优点：</p>
<ul>
<li>与2PC相比：每个分支事务都是独立提交，不互相等待，<strong>减少了资源锁定和阻塞时间</strong></li>
<li>与TCC相比：二阶段的执行操作全部<strong>自动化生成</strong>，<strong>无代码侵入</strong>，开发成本低</li>
</ul>
<p>缺点：</p>
<ul>
<li>与TCC相比，需要动态生成二阶段的反向补偿操作，<strong>执行性能略低于TCC</strong></li>
<li>AT 模式不适合高并发场景，因为其需要给数据库添加全局锁，一旦加锁就会导致并发降低</li>
</ul>

        <h3 id="几种模式对比"   >
          <a href="#几种模式对比" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#几种模式对比"></a> 几种模式对比</h3>
      
<ul>
<li>XA 二阶段：一阶段会有阻塞问题，必须等到所有事务都提交才能一起提交，每个事务都会阻塞等待其他事务</li>
<li>TCC：一阶段不阻塞，二阶段需要手动添加补偿代码，较繁琐</li>
<li>AT：一阶段不阻塞，每个事务执行完立即提交；二阶段框架自动实现补偿，性能略低于TCC；不适合高并发场景（因为要加行锁并且频繁删除 before image 和 after image）</li>
</ul>

        <h2 id="saga-模式"   >
          <a href="#saga-模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#saga-模式"></a> Saga 模式</h2>
      
<p>Saga 模式是 Seata 即将开源的长事务解决方案，将由蚂蚁金服主要贡献。其理论基础是Hector &amp; Kenneth  在1987年发表的论文<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://microservices.io/patterns/data/saga.html" >Sagas</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>
<p>Seata 官网对于Saga的指南：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/user/saga.html" >https://seata.io/zh-cn/docs/user/saga.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="基本模型"   >
          <a href="#基本模型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#基本模型"></a> 基本模型</h3>
      
<p>在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</p>
<p>分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/1561965208439-606129fe-6761-4177-8887-1fda9306f104.png" alt="Saga 模式" /></p>
<p>Saga 模式下分布式事务通常是由事件驱动的，各个参与者之间是异步执行的，Saga 模式是一种长事务解决方案。</p>

        <h3 id="适用场景"   >
          <a href="#适用场景" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景：</h3>
      
<ul>
<li>业务流程长、业务流程多</li>
<li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</li>
</ul>

        <h3 id="优点-2"   >
          <a href="#优点-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h3>
      
<ul>
<li>一阶段提交本地事务，无锁，高性能</li>
<li>事件驱动架构，参与者可异步执行，高吞吐</li>
<li>补偿服务易于实现</li>
</ul>

        <h3 id="缺点-2"   >
          <a href="#缺点-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h3>
      
<p>不保证隔离性（应对方案见<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/user/saga.html" >用户文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>）</p>

        <h2 id="seata"   >
          <a href="#seata" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#seata"></a> Seata</h2>
      

        <h3 id="介绍"   >
          <a href="#介绍" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h3>
      
<blockquote>
<p>Seata：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/seata/seata" >https://</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/seata/seata" >github.com/seata/seata</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>Seata（Simple Extensible Autonomous Transaction Architecture，简单可扩展自治事务框架）是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。Seata 开源半年左右，目前已经有接近一万 star，社区非常活跃。</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/1561960344792-8810110b-1eda-4417-944e-7051ca52f90d.png" alt="Seata" /></p>
<p>Seata 会有 4 种分布式事务解决方案，分别是 AT 模式、TCC 模式、Saga 模式和 XA 模式：</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305230513415.png" alt="image-20200305230513415" /></p>
<p>Seata中比较常用的是<strong>AT模式</strong>。下面将介绍其工作原理。</p>

        <h3 id="seata-产品模块"   >
          <a href="#seata-产品模块" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#seata-产品模块"></a> Seata 产品模块</h3>
      
<p>如下图所示，Seata 中有三大模块，分别是 <strong>TM</strong>、<strong>RM</strong> 和 <strong>TC</strong>。 <strong>其中 TM 和 RM 是作为 Seata 的客户端与业务系统集成在一起（集成在业务代码中）</strong>，<strong>TC 作为 Seata 的服务端独立部署，并被注册到注册中心和配置中心</strong>。</p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305225811888-1631068234111.png" alt="image-20200305225811888" /></p>

        <h3 id="seata-详细架构和流程"   >
          <a href="#seata-详细架构和流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#seata-详细架构和流程"></a> Seata 详细架构和流程</h3>
      
<p>Seata 中的几个基本概念：</p>
<ul>
<li><strong>TC（Transaction Coordinator）</strong> ：事务协调者，维护全局和分支事务的状态，驱动全局事务提交或回滚（TM之间的协调者），<strong>TC作为Seata的服务端 Seata-Serve，下载后直接使用jar包运行，其将被注册到注册中心和配置中心从而被各个微服务订阅</strong>。</li>
<li><strong>TM（Transaction Manager）</strong> ：事务管理器，定义全局事务的范围：开始全局事务、提交或回滚全局事务。TM对应的方法使用 <strong>@GlobalTransactional</strong> 注解标注，其内的业务代码处于同一个全局事务下。</li>
<li><strong>RM（Resource Manager）</strong> ：资源管理器，管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305225811888.png" alt="image-20200305225811888" /></p>
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/302377d33ddcd708e20b996bd9f2c7b8.png" alt="img" /></p>
<p><strong>三者工作分工</strong>：</p>
<ul>
<li>TM：业务模块中全局事务的开启者
<ul>
<li>向TC开启一个全局事务（标注 <strong>@GlobalTransactionnal</strong> 注解代表开启一个全局事务）</li>
<li>全局事务创建成功并生成一个全局唯一的<code>XID</code>，<code>XID</code>在微服务调用链路的上下文中传播；</li>
<li>调用其它微服务（例如订单模块作为TM调用了库存模块和支付模块）</li>
<li>TM向TC发起针对<code>XID</code>的<strong>全局提交或回滚决议</strong></li>
</ul>
</li>
<li>RM：业务模块执行者中包含RM部分，负责<strong>向TC汇报事务执行状态</strong>
<ul>
<li>负责与数据库交互，执行本地事务</li>
<li><strong>向TC注册分支事务</strong>，并提交本地事务执行结果</li>
<li>将其纳入XID对应全局事务的管辖</li>
</ul>
</li>
<li>TM：结束对微服务的调用，<strong>通知TC全局事务执行完毕，事务一阶段结束</strong></li>
<li>TC：<strong>汇总各个分支事务执行结果，决定分布式事务是提交还是回滚</strong>，通知所有 RM提交/回滚资源，事务二阶段结束。</li>
</ul>
<p><strong>三者的关系</strong>：</p>
<ul>
<li>TM用于开启全局事务生成<code>XID</code>，调用其他微服务，并在全局事务的方法执行完毕后通知TC全局事务执行完毕（即一阶段结束），此时TC即可统计各个分支事务的执行结果判断二阶段应该是提交还是回滚；</li>
<li>每个RM与本地数据库交互，执行本地事务并立即提交（不阻塞），之后向TC注册当前分支事务的信息，最后将本地事务提交的结果上报给 TC；</li>
<li>TC调度<code>XID</code>下管辖的全部分支事务完成提交或回滚请求。其先保存每个RM注册的分支事务信息，当收到TM的一阶段结束通知后，根据接收汇总到的各个分支事务的执行结果判断二阶段应该是提交还是回滚：若都成功，则通知每个RM二阶段提交；若有失败，则通知每个RM二阶段回滚</li>
</ul>
<p>示例：</p>
<ul>
<li>TC 管理全局，在服务端部署。</li>
<li>TM 标注在 Service 层，在业务代码处控制整个事务。例如下订单的 Service 方法</li>
<li>RM 标注在每个微服务上，控制本地事务，操纵数据库。例如分别标注在操作订单表和操作库存表的方法上</li>
</ul>
<p>例如 TM 标注在下订单业务。其先通知 TC，自己准备开启一个全局事务 ，然后各个 RM 开始注册分支事务，并且实时通知 TC 自己的状态，这样 TC 就实时知道 RM 的状态是成功还是失败。一旦某一个RM 通知 TC 自己失败了，TC 就命令其他的 RM 回滚。</p>

        <h3 id="seata-两个阶段具体工作流程"   >
          <a href="#seata-两个阶段具体工作流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#seata-两个阶段具体工作流程"></a> Seata 两个阶段具体工作流程</h3>
      
<p><img src="/images/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/302377d33ddcd708e20b996bd9f2c7b8.png" alt="img" /></p>
<p><strong>一阶段</strong>：</p>
<ul>
<li>TM开启全局事务，并向TC声明全局事务，包括全局事务<code>XID</code>信息</li>
<li>TM所在服务调用其它微服务</li>
<li>微服务主要由RM来执行
<ul>
<li>查询<code>before_image</code></li>
<li>执行本地事务</li>
<li>查询<code>after_image</code></li>
<li>生成<code>undo_log</code>并写入数据库</li>
<li>向TC注册分支事务，告知事务执行结果</li>
<li>获取全局锁（阻止其它全局事务并发修改当前数据）</li>
<li>释放本地锁（不影响其它业务对数据的操作）</li>
</ul>
</li>
<li>待所有业务执行完毕，事务发起者（TM）会尝试向TC提交全局事务</li>
</ul>
<p><strong>二阶段</strong>：</p>
<ul>
<li>TC统计分支事务执行情况，根据结果判断下一步行为：
<ul>
<li>分支都成功：通知分支事务，提交事务</li>
<li>有分支执行失败：通知执行成功的分支事务，回滚数据</li>
</ul>
</li>
<li>分支事务的RM收到TC传来的消息：
<ul>
<li>提交事务：直接清空<code>before_image</code>和<code>after_image</code>信息，释放全局锁</li>
<li>回滚事务：
<ul>
<li>校验<code>after_image</code>，判断是否有脏写</li>
<li>如果没有脏写，回滚数据到<code>before_image</code>，清除<code>before_image</code>和<code>after_image</code></li>
<li>如果有脏写，请求人工介入</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h3 id="seata-工作流程示例"   >
          <a href="#seata-工作流程示例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#seata-工作流程示例"></a> Seata 工作流程示例</h3>
      
<p>详见Seata的官方文档：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/overview/what-is-seata.html" >https://seata.io/zh-cn/docs/overview/what-is-seata.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<blockquote>

        <h4 id="场景"   >
          <a href="#场景" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#场景"></a> 场景</h4>
      
</blockquote>
<p>以一个示例来说明 AT 分支的整个工作过程。</p>
<p>业务表：<code>product</code></p>
<div class="table-container"><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Key</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>bigint(20)</td>
<td>PRI</td>
</tr>
<tr>
<td>name</td>
<td>varchar(100)</td>
<td></td>
</tr>
<tr>
<td>since</td>
<td>varchar(100)</td>
<td></td>
</tr>
</tbody>
</table></div>
<p>AT 分支事务的业务逻辑：</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update product <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;GTS&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span>;</span><br></pre></td></tr></table></div></figure>
<blockquote>

        <h4 id="一阶段-2"   >
          <a href="#一阶段-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#一阶段-2"></a> 一阶段</h4>
      
</blockquote>
<p>过程：</p>
<ol>
<li><strong>解析 SQL</strong>：得到 SQL 的类型（UPDATE），表（product），条件（where name = ‘TXC’）等相关的信息。</li>
<li><strong>查询 before image（前镜像）</strong>：根据解析得到的条件信息，生成查询语句，定位数据（即修改前先查询出来当前这，保存到undo log）。</li>
</ol>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, since <span class="keyword">from</span> product <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span>;</span><br></pre></td></tr></table></div></figure>
<p>得到前镜像：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>since</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>TXC</td>
<td>2014</td>
</tr>
</tbody>
</table></div>
<ol start="3">
<li><strong>执行业务 SQL</strong>：更新这条记录的 name 为 ‘GTS’。</li>
<li><strong>查询 after image（后镜像）</strong>：根据前镜像的结果，通过 <strong>主键（id）</strong> 定位数据。</li>
</ol>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, since <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> `<span class="number">1</span>`;</span><br></pre></td></tr></table></div></figure>
<p>得到后镜像：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>since</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>GTS</td>
<td>2014</td>
</tr>
</tbody>
</table></div>
<ol start="5">
<li><strong>插入回滚日志</strong>：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 <code>UNDO_LOG</code> 表中：</li>
</ol>
<figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;branchId&quot;</span>: <span class="number">641789253</span>,</span><br><span class="line">    <span class="attr">&quot;undoItems&quot;</span>: [&#123;</span><br><span class="line">        <span class="attr">&quot;afterImage&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;rows&quot;</span>: [&#123;</span><br><span class="line">                <span class="attr">&quot;fields&quot;</span>: [&#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="number">1</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;GTS&quot;</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;since&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;2014&quot;</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;],</span><br><span class="line">            <span class="attr">&quot;tableName&quot;</span>: <span class="string">&quot;product&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;beforeImage&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;rows&quot;</span>: [&#123;</span><br><span class="line">                <span class="attr">&quot;fields&quot;</span>: [&#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="number">1</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;TXC&quot;</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;since&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;2014&quot;</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;],</span><br><span class="line">            <span class="attr">&quot;tableName&quot;</span>: <span class="string">&quot;product&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;sqlType&quot;</span>: <span class="string">&quot;UPDATE&quot;</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="attr">&quot;xid&quot;</span>: <span class="string">&quot;xid:xxx&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="6">
<li><strong>提交前，向 TC 注册分支</strong>：申请 <code>product</code> 表中，主键值等于 1 的记录的 <strong>全局锁</strong> 。</li>
<li><strong>本地事务提交</strong>：业务数据的更新和前面步骤中生成的 <code>UNDO LOG</code> 一并提交。</li>
<li><strong>将本地事务提交的结果上报给 TC</strong>。</li>
</ol>
<blockquote>

        <h4 id="二阶段-回滚-2"   >
          <a href="#二阶段-回滚-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二阶段-回滚-2"></a> 二阶段-回滚</h4>
      
</blockquote>
<p>若收到 TC 的<strong>分支回滚</strong>请求，开启一个本地事务，执行如下操作：</p>
<ol>
<li>通过 <code>XID</code> 和 <code>Branch ID</code> 查找到相应的 <code>UNDO LOG</code> 记录（同一个微服务可能同时参与多个不同的事务组，有多个 <code>XID</code>）。</li>
<li><strong>数据校验</strong>：拿 <code>UNDO LOG</code> 中的后镜像与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理。</li>
<li>根据 <code>UNDO LOG</code> 中的<strong>前镜像</strong>和<strong>业务 SQL 的相关信息</strong>生成并执行回滚的语句：</li>
</ol>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update product <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></div></figure>
<ol start="4">
<li><strong>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC</strong>。</li>
</ol>
<blockquote>

        <h4 id="二阶段-提交-2"   >
          <a href="#二阶段-提交-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二阶段-提交-2"></a> 二阶段-提交</h4>
      
</blockquote>
<ol>
<li>收到 TC 的<strong>分支提交</strong>请求，把请求放入一个<strong>异步任务的队列</strong>中，<strong>马上返回提交成功</strong>的结果给 TC。</li>
<li>异步任务阶段的分支提交请求将<strong>异步和批量地删除相应 <code>UNDO LOG</code> 记录</strong>。</li>
</ol>
<p>以上即为 Seata 框架的工作原理，关于 Seata 框架的使用见文章 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://blog.yuyunzhao.cn/2021/09/08/%E3%80%90SpringCloud%E3%80%91Seata/" >【Spring Cloud】Spring Cloud Alibaba Nacos</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://yuyun-zhao.github.io">yuyun zhao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://yuyun-zhao.github.io/2021/09/07/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">http://yuyun-zhao.github.io/2021/09/07/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/09/08/%E3%80%90SpringCloud%E3%80%91Seata/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">【Spring Cloud】Spring Cloud Alibaba Seata</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/09/06/%E3%80%90SpringCloud%E3%80%91Sentinel/"><span class="paginator-prev__text">【Spring Cloud】Spring Cloud Alibaba Sentinel</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">
           分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E8%B7%A8%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-text">
           1）跨数据源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E8%B7%A8%E6%9C%8D%E5%8A%A1"><span class="toc-text">
           2）跨服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">
           3）分布式系统的数据一致性问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap-%E5%AE%9A%E7%90%86"><span class="toc-text">
           CAP 定理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#partition-tolerance"><span class="toc-text">
           Partition tolerance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consistency"><span class="toc-text">
           Consistency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#availability"><span class="toc-text">
           Availability</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consistency-%E5%92%8C-availability-%E7%9A%84%E7%9F%9B%E7%9B%BE"><span class="toc-text">
           Consistency 和 Availability 的矛盾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%82%B9%E7%96%91%E9%97%AE"><span class="toc-text">
           几点疑问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#base-%E7%90%86%E8%AE%BA"><span class="toc-text">
           BASE 理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7-%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">
           强一致性、弱一致性、最终一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#173-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">
           17.3 分布式事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2pc-%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-text">
           2PC 二阶段提交</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#xa"><span class="toc-text">
           XA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE"><span class="toc-text">
           二阶段提交协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5"><span class="toc-text">
           正常情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5"><span class="toc-text">
           异常情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-text">
           缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">
           使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcc-%E4%BA%8B%E5%8A%A1%E8%A1%A5%E5%81%BF%E5%9E%8B%E6%96%B9%E6%A1%88"><span class="toc-text">
           TCC - 事务补偿型方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">
           基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-text">
           实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">
           优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">
           缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">
           总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-text">
           使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1-%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5%E5%9E%8B%E6%96%B9%E6%A1%88"><span class="toc-text">
           可靠消息服务 - 最大努力通知型方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-2"><span class="toc-text">
           基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8"><span class="toc-text">
           本地消息表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E7%89%88%E6%9C%AC"><span class="toc-text">
           简化版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1"><span class="toc-text">
           独立消息服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rocketmq-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-text">
           RocketMQ 事务消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rabbitmq-%E7%9A%84%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4"><span class="toc-text">
           RabbitMQ 的消息确认</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">
           消息事务的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#at%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">
           AT（自动提交）模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-3"><span class="toc-text">
           基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%98%B6%E6%AE%B5"><span class="toc-text">
           一阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5-%E6%8F%90%E4%BA%A4"><span class="toc-text">
           二阶段 提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5-%E5%9B%9E%E6%BB%9A"><span class="toc-text">
           二阶段 回滚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">
           优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-text">
           几种模式对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#saga-%E6%A8%A1%E5%BC%8F"><span class="toc-text">
           Saga 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B"><span class="toc-text">
           基本模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">
           适用场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-text">
           优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-text">
           缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seata"><span class="toc-text">
           Seata</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">
           介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#seata-%E4%BA%A7%E5%93%81%E6%A8%A1%E5%9D%97"><span class="toc-text">
           Seata 产品模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#seata-%E8%AF%A6%E7%BB%86%E6%9E%B6%E6%9E%84%E5%92%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">
           Seata 详细架构和流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#seata-%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%85%B7%E4%BD%93%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">
           Seata 两个阶段具体工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#seata-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="toc-text">
           Seata 工作流程示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-text">
           场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E9%98%B6%E6%AE%B5-2"><span class="toc-text">
           一阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5-%E5%9B%9E%E6%BB%9A-2"><span class="toc-text">
           二阶段-回滚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5-%E6%8F%90%E4%BA%A4-2"><span class="toc-text">
           二阶段-提交</span></a></li></ol></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/author.png" alt="avatar"></div><p class="sidebar-ov-author__text">no code no life</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YUYUN-ZHAO" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="zyy18749810683" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1024462136" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:im.yuyunzhao@gmail.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gmail</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">153</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">40</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">40</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>yuyun zhao</span><span class="footer__devider">|</span><span>沪ICP备2022000458号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>