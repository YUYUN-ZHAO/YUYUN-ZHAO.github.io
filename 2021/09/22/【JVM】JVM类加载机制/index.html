<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="类加载器子系统概述           如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？  类加载器 执行引擎">
<meta property="og:type" content="article">
<meta property="og:title" content="【JVM】JVM 类加载机制">
<meta property="og:url" content="http://yuyun-zhao.github.io/2021/09/22/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="yuyun zhao&#39;s blog">
<meta property="og:description" content="类加载器子系统概述           如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？  类加载器 执行引擎">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/05e32da21f7e001e26951a21a6393db5.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/94f3ef5322aa4dd32f2478f49c98a7af.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f796f7574686c716c2f6c716c704076312e302e302f4a564d2f636861707465725f3030322f303030332e6a7067">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705081813409-1632296385072.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705081913538-1632294600690.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211014204209807.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/20201118115656.jpg">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705082601441-1632294600690.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705081813409-1632296385072.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211014204138998.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211014204209807.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211014204942607.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/20201118121444924.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211014205546184.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705084038680-1632294600690.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705090237078-1632294600690.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705090328171-1632294600690.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/df32a22e07108b9318c3a020d304c783.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/20201120091316.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/20201120100027.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/b7186181da1af4d40001c3ca25f8fefb.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211014213433097.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/9d1ee398a719d8c95024a6311be0d4d6.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/20201120104448.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/d47503a1999253a84256a94887e5cb79.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI3MTcwODM3NTM4LnBuZw">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI3MTcwOTE4MDM3LnBuZw">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211015211158127.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/d47503a1999253a84256a94887e5cb79.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705103516138-1632294600690.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/20201120104448.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211015145906637.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211015145400761.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211015152354574.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211015152829587.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705105151258-1632294600690.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211015152354574.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018103731245.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018103725540.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018103711336.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/20201120145148.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/34e48ebaa5bd451522c8039215636172.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/4afef5f16208076b038a6194447dcadb.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705105810107-1632294600691.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/61a081a966f66450d67c9615f11671a3.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018104311131.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018104404224.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018104435405.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018104641337.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018105345375.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018105552699.png">
<meta property="article:published_time" content="2021-09-22T06:55:36.000Z">
<meta property="article:modified_time" content="2021-10-18T03:06:45.041Z">
<meta property="article:author" content="yuyun zhao">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/05e32da21f7e001e26951a21a6393db5.png"><title>【JVM】JVM 类加载机制 | yuyun zhao's blog</title><link ref="canonical" href="http://yuyun-zhao.github.io/2021/09/22/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">文章</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">yuyun zhao's blog</div><div class="header-banner-info__subtitle">no code no life</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">【JVM】JVM 类加载机制</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-18</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">18.7k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">110分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h2 id="类加载器子系统概述"   >
          <a href="#类加载器子系统概述" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类加载器子系统概述"></a> 类加载器子系统概述</h2>
      
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/05e32da21f7e001e26951a21a6393db5.png" alt="img" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/94f3ef5322aa4dd32f2478f49c98a7af.png" alt="img" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f796f7574686c716c2f6c716c704076312e302e302f4a564d2f636861707465725f3030322f303030332e6a7067" alt="img" /></p>
<p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p>
<ul>
<li>类加载器</li>
<li>执行引擎</li>
</ul>
<span id="more"></span>

        <h2 id="类加载器子系统作用"   >
          <a href="#类加载器子系统作用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类加载器子系统作用"></a> 类加载器子系统作用</h2>
      
<p>类加载器子系统负责从文件系统或者网络中加载Class文件，.<code>class</code>文件在文件开头有特定的文件标识：<strong>魔数</strong> <code>CA FE BA BE</code>。类加载器<code>ClassLoader</code>只负责<code>.class</code>文件的加载，至于它是否可以运行，则由执行引擎E<code>xecution Engine</code>决定。</p>
<p>加载的类信息存放于一块称为<strong>方法区（Java 8.0称为元空间）<strong>的内存空间。除了类的信息外，方法区中还会存放</strong>运行时常量池</strong>信息，可能还包括<strong>字符串字面量</strong>和<strong>数字常量</strong>（这部分常量信息是Class文件中常量池部分的内存映射）</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705081813409-1632296385072.png" alt="image-20200705081813409" /></p>
<ul>
<li><code>.class</code> 文件存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM的方法区（JDK 8 的元空间）当中来根据这个文件实例化出n个一模一样的实例。</li>
<li><code>.class</code> 文件加载到JVM的方法区（JDK 8 的元空间）中，被称为DNA<strong>元数据模板</strong>。</li>
<li>在<code>.class</code>文件 -&gt; JVM -&gt; 最终成为<strong>元数据模板</strong>，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705081913538-1632294600690.png" alt="image-20200705081913538" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211014204209807.png" alt="image-20211014204209807" /></p>

        <h2 id="类的加载过程"   >
          <a href="#类的加载过程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类的加载过程"></a> 类的加载过程</h2>
      
<p>在Java中数据类型分为基本数据类型和引用数据类型。<strong>基本数据类型由虚拟机预先定义</strong>，引用数据类型则需要进行类的加载。即基本数据类型不需要类加载器来加载，在JVM启动时就已经预定义，下面讨论的加载过程都是针对引用类型对象而言。</p>
<p>例如下面的一段简单的代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我已经被加载啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>它的加载过程是怎么样的呢?</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/20201118115656.jpg" alt="img" /></p>
<p>完整的流程图如下所示：加载 --&gt; 链接（验证 --&gt; 准备 --&gt; 解析） --&gt; 初始化</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705082601441-1632294600690.png" alt="image-20200705082601441" /></p>
<p>下面按顺序分析该类的加载过程：</p>
<ul>
<li><strong>加载阶段 - Loading</strong>：将 <code>.class</code> 文件从硬盘/网络中读取加载到内存中</li>
<li><strong>链接阶段 - Linking</strong>
<ul>
<li><strong>验证 - Verify</strong>：校验文件是否合法</li>
<li><strong>准备 - Prepare</strong>：为类的静态成员变量初始化，赋零值</li>
<li><strong>解析 - Resolve</strong>：将常量池内的符号引用转换为直接引用</li>
</ul>
</li>
<li><strong>初始化阶段 - Initialization</strong>：为类的静态成员变量赋值。合并类的静态成员变量赋值语句和静态代码块中的语句组成 <code>&lt;clinit&gt;()</code> 方法，并按顺序执行为这些静态成员变量赋值。</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705081813409-1632296385072.png" alt="image-20200705081813409" /></p>
<p>按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下7个阶段：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211014204138998.png" alt="image-20211014204138998" /></p>

        <h2 id="加载阶段-loading"   >
          <a href="#加载阶段-loading" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#加载阶段-loading"></a> 加载阶段 - Loading</h2>
      
<p>所谓加载，就是将Java类的字节码文件加载到机器内存中，并在方法区中构建出Java类的原型——<strong>类模板信息</strong></p>
<blockquote>
<p>所谓类模板对象，其实就是Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用，见下图中方法区里的二进制数据表结构。反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。</p>
</blockquote>
<p>作用：加载阶段负责将<code>.class</code>文件从硬盘/网络中读取二进制字节流到内存中，交给链接阶段进行验证/准备/解析。</p>
<p>流程：</p>
<ol>
<li>通过一个类的全限定名获取定义此类的<strong>二进制字节流</strong></li>
<li>将这个二进制字节流所代表的静态存储结构转化为<strong>方法区内的运行时数据结构——类模板信息</strong></li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口（下图中代表Sample类的Class对象）</li>
</ol>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211014204209807.png" alt="image-20211014204209807" /></p>

        <h3 id="加载-class-文件的方式"   >
          <a href="#加载-class-文件的方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#加载-class-文件的方式"></a> 加载 .class 文件的方式</h3>
      
<ul>
<li>从本地系统中直接加载 <code>.class</code> 文件（最常见）</li>
<li>通过网络获取，典型场景：Web Applet</li>
<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>
<li>运行时计算生成，使用最多的是：动态代理技术</li>
<li>由其他文件生成，典型场景：JSP应用从专有数据库中提取<code>.class</code>文件，比较少见</li>
<li>从<strong>加密文件</strong>中获取，典型的防Class文件被反编译的保护措施</li>
</ul>

        <h3 id="类模型与-class-实例的位置"   >
          <a href="#类模型与-class-实例的位置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类模型与-class-实例的位置"></a> 类模型与 Class 实例的位置</h3>
      
<p>代表该类的类模板信息存储在方法区（JDK 8 以后的元空间）中，其对应的 Class 对象存储在堆区，并能访问到方法区中的类信息。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211014204942607.png" alt="image-20211014204942607" /></p>

        <h3 id="数组类的加载"   >
          <a href="#数组类的加载" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#数组类的加载"></a> 数组类的加载</h3>
      
<p>创建数组类的情况稍微有些特殊，<strong>因为数组类本身并不是由类加载器负责创建</strong>，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称A）的过程：</p>
<ul>
<li>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型</li>
<li>JVM使用指定的元素类型和数组维度来创建新的数组类。</li>
</ul>
<p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为public。</p>

        <h2 id="链接阶段-linking"   >
          <a href="#链接阶段-linking" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#链接阶段-linking"></a> 链接阶段 - Linking</h2>
      
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/20201118121444924.png" alt="img" /></p>

        <h3 id="验证-verify"   >
          <a href="#验证-verify" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#验证-verify"></a> 验证 - Verify</h3>
      
<p><strong>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</strong>。如果出现不合法的字节码文件，那么将会验证不通过。</p>
<p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211014205546184.png" alt="image-20211014205546184" /></p>
<p>说明：</p>
<ul>
<li>格式验证其实适合加载阶段一起进行的，只是为了分类才将其归纳到链接阶段。验证通过后，类加载器才会将类的二进制数据信息加载到方法区中。</li>
<li>格式验证之外的其他验证操作将会在方法区中进行。</li>
<li>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。</li>
</ul>
<blockquote>
<p>工具：Binary Viewer查看</p>
</blockquote>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705084038680-1632294600690.png" alt="image-20200705084038680" /></p>
<p>同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705090237078-1632294600690.png" alt="image-20200705090237078" /></p>
<p>安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705090328171-1632294600690.png" alt="image-20200705090328171" /></p>

        <h3 id="准备-prepare"   >
          <a href="#准备-prepare" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#准备-prepare"></a> 准备 - Prepare</h3>
      
<p>作用：为<strong>类的静态成员变量</strong>分配内存并且设置该类变量的<strong>默认零初始值</strong>，基本数据类型为零值，引用数据类型为<code>null</code>。</p>
<blockquote>
<p>准备阶段不会为 static 方法块中定义的静态成员进行初始化，其由初始化阶段完成</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上面的变量a在<strong>准备阶段</strong>会赋默认零初始值，<strong>但不是1，而是0</strong>。在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>这里不包含用<code>final</code>修饰的<code>static</code>，因为 <strong><code>final</code>在编译的时候就会分配了</strong>，可以在字节码文件中该Field的属性中查看到其值为1，说明在程序运行前就已经确定了该值，因此准备阶段时其值就已经是1了</li>
<li>这里<strong>不会为实例变量分配初始化</strong>，<strong>类的静态成员变量会分配在方法区中（JDK 8 中存储在堆中），而实例变量是会随着对象一起分配到堆中。</strong></li>
</ul>
<p>下面代码中，<code>num</code>在<code>static</code>方法块中先赋值再声明，看似顺序不合理，但是在准备阶段已经先声明了静态成员变量<code>num</code>并为赋值为0。在后续的初始化阶段，才会执行<code>static</code>代码块中赋值操作，此时已经声明了<code>num</code>变量。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br></pre></td></tr></table></div></figure>
<hr />
<p>注意：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般情况：static final修饰的基本数据类型、字符串类型字面量会在准备阶段赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="comment">// 特殊情况：static final修饰的引用类型不会在准备阶段赋值，而是在初始化阶段赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="keyword">new</span> String(<span class="string">&quot;Hello world&quot;</span>);</span><br></pre></td></tr></table></div></figure>
<p>结论：使用 <code>static + final</code> 修饰，且显式赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行，否则就是在初始化阶段进行。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;                                <span class="comment">// 在链接阶段的准备环节赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);                  <span class="comment">// 在初始化阶段clinit&gt;()中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;                                                  <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);     <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">100</span>);           <span class="comment">// 在初始化阶段&lt;clinit&gt;()中概值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">&quot;helloworld0&quot;</span>;                            <span class="comment">// 在链接阶段的准备环节赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld1&quot;</span>);                <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String s2 = <span class="string">&quot;hellowrold2&quot;</span>;                                  <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="解析-resolve"   >
          <a href="#解析-resolve" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#解析-resolve"></a> 解析 - Resolve</h3>
      
<p>作用：将常量池内的类、接口、字段和方法等<strong>符号引用转换为直接引用</strong>。</p>
<blockquote>
<p><code>.class</code>文件中只会保存常量池中信息（例如类信息、方法信息等）的<strong>符号引用</strong>，不需要直接引用这些信息，这样文件体积就会比较小，也能节省栈的空间，即栈帧里的动态链接部分只需要保存符号引用，而不需要保存直接引用，该转换由解析阶段完成。</p>
</blockquote>
<p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当 <code>println()</code> 方法被调用时，系统需要明确知道该方法的位置，因此需要在调用该方法前找到其真实地址。</p>
<p>使用 <code>javap</code> 命令解析 <code>.class</code> 文件后可以查看符号引用：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/df32a22e07108b9318c3a020d304c783.png" alt="img" /></p>
<p>以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析阶段，符号引用就可以转变为目标方法在类中方发表中的位置，从而使得方法被成功调用。</p>
<p>事实上，<strong>解析操作往往会伴随着JVM在执行完初始化之后再执行</strong>，只是将其分类到链接阶段而已。</p>
<p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的<code>class</code>文件格式中。<strong>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</strong></p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的<code>CONSTANT Class info</code>、<code>CONSTANT Fieldref info</code>、<code>CONSTANT Methodref info</code>等。</p>

        <h2 id="初始化阶段-initialization"   >
          <a href="#初始化阶段-initialization" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#初始化阶段-initialization"></a> 初始化阶段 - Initialization</h2>
      
<p>作用：初始化阶段就是执行<strong>类的静态属性初始化方法</strong><code>&lt;clinit&gt;()</code>的过程（class init）。</p>
<p><code>&lt;clinit&gt;()</code>方法不需显式定义，是javac编译器自动收集类中的<strong>所有类静态成员变量的赋值动作和静态代码块中的语句合并而来</strong>。也就是说，当我们代码中包含<code>static</code>变量的时候，就会自动生成<code>clinit()</code>方法。静态属性构造器方法中指令按语句在源文件中出现的顺序执行。</p>
<p><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕。</p>
<p>只有当我们代码中包含<code>static</code>成员变量或<code>static</code>代码块的时候，才会有<code>&lt;clinit&gt;()</code>方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/20201120091316.png" alt="img" /></p>

        <h3 id="clinit方法初始化顺序"   >
          <a href="#clinit方法初始化顺序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#clinit方法初始化顺序"></a> <code>&lt;clinit&gt;()</code>方法初始化顺序</h3>
      
<p><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        number = <span class="number">20</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(number);  <span class="comment">// 报错，非法的前向引用，但是不调用的话是不会有错的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassInitTest.num); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(ClassInitTest.number); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>静态变量 number 的值变化过程如下</p>
<ul>
<li>准备阶段时：默认初始化 0</li>
<li>执行静态代码块：20</li>
<li>执行静态变量初始化：10</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/20201120100027.png" alt="img" /></p>
<p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p>

        <h3 id="init-方法初始化顺序"   >
          <a href="#init-方法初始化顺序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#init-方法初始化顺序"></a> <code>&lt;init&gt;()</code> 方法初始化顺序</h3>
      
<p>类的构造器方法是虚拟机视角下的<code>&lt;init&gt;()</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任何一个类声明以后，内部至少存在一个类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClinitTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/b7186181da1af4d40001c3ca25f8fefb.png" alt="img" /></p>
<p>在构造器中：</p>
<ul>
<li>先将类变量 a 赋值为 10</li>
<li>再将局部变量赋值为 20</li>
</ul>
<p>关于涉及到父类时候的变量赋值过程</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Son.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上述代码，加载流程如下：</p>
<ul>
<li>首先，执行 <code>main()</code> 方法需要加载 <code>ClinitTest1</code>类</li>
<li>获取 <code>Son.b</code> 静态变量，需要加载 <code>Son</code> 类</li>
<li><code>Son</code>类的父类是 <code>Father</code>类，所以需要先执行 <code>Father</code>类的加载，再执行 <code>Son</code>类的加载</li>
</ul>
<p>输出结果为 2，也就是说首先加载<code>ClinitTest1</code>的时候，会找到<code>main()</code>方法，然后执行<code>Son</code>的初始化，但是<code>Son</code>继承了<code>Father</code>，因此还需要执行<code>Father</code>的初始化，同时将<code>A</code>赋值为2。我们通过反编译得到<code>Father</code>的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iconst_1</span><br><span class="line">putstatic <span class="comment">#2 &lt;com/zhao/java/chapter02/ClinitTest1$Father.A&gt;</span></span><br><span class="line">iconst_2</span><br><span class="line">putstatic <span class="comment">#2 &lt;com/zhao/java/chapter02/ClinitTest1$Father.A&gt;</span></span><br><span class="line"><span class="built_in">return</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="clinit-的线程安全性"   >
          <a href="#clinit-的线程安全性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#clinit-的线程安全性"></a> <code>&lt;clinit&gt;()</code> 的线程安全性</h3>
      
<p>对于<code>&lt;clinit&gt;()</code>方法的调用，也就是类的初始化，虚拟机会在内部确保其<strong>多线程环境中的安全性</strong>。</p>
<p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</p>
<p>因此，如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p>
<p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行<code>&lt;clinit&gt;()</code>方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。</p>
<p>代码演示死锁情况：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 线程t1开始&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> DeadThread();</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 线程t2开始&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> DeadThread();</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上面的代码，输出结果为</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程t1开始</span><br><span class="line">线程t2开始</span><br><span class="line">线程t2 初始化当前类</span><br></pre></td></tr></table></div></figure>
<p>程序卡死，分析原因：</p>
<ul>
<li>两个线程同时去加载 <code>DeadThread</code>类，而 <code>DeadThread</code>类中静态代码块中有一处死循环</li>
<li>先加载 <code>DeadThread</code>类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放</li>
<li>所以无论哪个线程先执行 <code>DeadThread</code> 类的加载，另外一个类也不会继续执行</li>
</ul>
<p>从上面可以看出初始化后，只能够执行一次初始化，这也就是<strong>同步加锁</strong>的过程</p>

        <h3 id="类的主动使用和被动使用"   >
          <a href="#类的主动使用和被动使用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类的主动使用和被动使用"></a> 类的主动使用和被动使用</h3>
      
<p>Java程序对类的使用方式分为：主动使用和被动使用。</p>

        <h4 id="主动使用"   >
          <a href="#主动使用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#主动使用"></a> 主动使用</h4>
      
<p>Class <strong>只有在必须要首次使用的时候才会被加载</strong>，Java虚拟机不会无条件地加载Class类型。即程序启动时并不会立即加载所有Class，而是会等待程序运行到需要使用该类时才会加载该类，但也不是都会执行初始化阶段，而是按需执行：需要用到时再初始化（即主动使用情况），不需要时不初始化。</p>
<p>并且每个类只会被加载一次，第二次使用该类时，不再需要加载初始化，可以直接从方法区中获取该类信息。</p>
<p>Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。</p>
<p>主动使用有下列七种情况：</p>
<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（比如：<code>Class.forName(&quot;com.zhao.Test&quot;)</code>）</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类（<code>main()</code> 方法所在类）</li>
<li>JDK 7开始提供的动态语言支持：</li>
<li><code>java.lang.invoke.MethodHandle</code>实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li>
</ul>
<p>下面逐个举例：</p>
<ol>
<li>创建类的实例：当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class Order implements Serializable &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order类的初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;order.dat&quot;</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> Order());</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;order.dat&quot;</span>));</span><br><span class="line">        Order order = ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>静态方法：当调用类的静态方法时，即当使用了字节码 <code>invokestatic</code> 指令。</li>
<li>静态字段：当使用类、接口的静态字段时（final修饰特殊考虑），比如，使用<code>getstatic</code>或者putstatic指令。（对应访问变量、赋值变量操作）</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(User.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User类的初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="4">
<li>反射：当使用<code>java.lang.reflect</code>包中的方法反射类的方法时。比如：<code>Class.forName(&quot;com.zhao.java.Test&quot;)</code></li>
<li>继承：当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
</ol>
<blockquote>
<p>当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是该规则并不适用于接口</p>
<ul>
<li>在初始化一个类时，并不会先初始化它所实现的接口</li>
<li>在初始化一个接口时，并不会先初始化它的父接口</li>
<li>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</li>
</ul>
</blockquote>
<ol start="6">
<li>default方法：如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Compare</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Compare接口的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="7">
<li><code>main()</code> 方法：当虚拟机启动时，用户需要指定一个要执行的主类（包含<code>main()</code>方法的那个类），虚拟机会先初始化这个主类。</li>
</ol>
<blockquote>
<p>JVM启动的时候通过引导类加载器加载一个初始类。这个类在调用<code>public static void main(String[])</code> 方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p>
</blockquote>
<ol start="8">
<li><code>MethodHandle</code>：当初次调用<code>MethodHandle</code>实例时，初始化该<code>MethodHandle</code>指向的方法所在的类。（涉及解析REF getStatic、REF_putStatic、REF invokeStatic方法句柄对应的类）</li>
</ol>

        <h4 id="被动使用"   >
          <a href="#被动使用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#被动使用"></a> 被动使用</h4>
      
<p>除了以上几种情况，<strong>其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的 <code>&lt;clinit&gt;()</code> 初始化</strong>。<strong>被动使用时，类会被加载，但是不会进行初始化。</strong></p>
<p>被动使用的举例：</p>
<ol>
<li>静态字段：当通过子类引用父类的静态变量，不会导致子类初始化，只有真正声明这个字段的类才会被初始化。</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassiveUse</span> </span>&#123;</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Child.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child类的初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent类的初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>数组定义：通过数组定义类引用，不会触发此类的初始化</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent[] parents= <span class="keyword">new</span> Parent[<span class="number">10</span>];</span><br><span class="line">System.out.println(parents.getClass()); </span><br><span class="line"><span class="comment">// new的话才会初始化</span></span><br><span class="line">parents[<span class="number">0</span>] = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></div></figure>
<ol start="3">
<li>引用常量：引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassiveUse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Serival.num);</span><br><span class="line">        <span class="comment">// 但引用其他类的话还是会初始化</span></span><br><span class="line">        System.out.println(Serival.num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Serival</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Serival初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">10</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="4">
<li>调用<code>loadClass()</code> 方法：调用<code>ClassLoader</code>某个子类的<code>loadClass()</code>方法加载一个类，并不是对类的主动使用，不会导致类的初始化（只会加载，连解析都不一定会执行，除非传入参数要求解析）。</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.test.java.Person&quot;</span>);</span><br></pre></td></tr></table></div></figure>
<p><strong>扩展</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+TraceClassLoading：追踪打印类的加载信息</span><br></pre></td></tr></table></div></figure>

        <h2 id="卸载阶段"   >
          <a href="#卸载阶段" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#卸载阶段"></a> 卸载阶段</h2>
      

        <h3 id="类-类的加载器-类的实例之间的引用关系"   >
          <a href="#类-类的加载器-类的实例之间的引用关系" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类-类的加载器-类的实例之间的引用关系"></a> 类、类的加载器、类的实例之间的引用关系</h3>
      
<p>在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的<code>getClassLoader()</code>方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。</p>
<p>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了<code>getClass()</code>方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的java类都有一个静态属性class，它引用代表这个类的Class对象。</p>

        <h3 id="类的生命周期"   >
          <a href="#类的生命周期" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类的生命周期"></a> 类的生命周期</h3>
      
<p>当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。</p>
<p><strong>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期</strong>。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211014213433097.png" alt="image-20211014213433097" /></p>
<p>loader1变量和obj变量间接应用代表Sample类的Class对象，而objClass变量则直接引用它。</p>
<p>如果程序运行过程中，将上图左侧三个引用变量都置为null，此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。</p>
<p>当再次有需要时，会检查Sample类的Class对象是否存在，如果存在会直接使用，不再重新加载；如果不存在Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表Sample类的Class实例（可以通过哈希码查看是否是同一个实例）</p>

        <h3 id="类的卸载"   >
          <a href="#类的卸载" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类的卸载"></a> 类的卸载</h3>
      
<ul>
<li>启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm和jls规范）</li>
<li>被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。</li>
<li>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）。</li>
</ul>
<p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p>

        <h2 id="类加载器"   >
          <a href="#类加载器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类加载器"></a> 类加载器</h2>
      

        <h3 id="类加载的方式"   >
          <a href="#类加载的方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类加载的方式"></a> 类加载的方式</h3>
      
<p>类加载的方式：<strong>显式加载</strong>与<strong>隐式加载</strong></p>
<p><code>.class</code>文件的显式加载与隐式加载的方式是指<strong>JVM加载<code>.class</code>文件到内存的方式</strong>。</p>
<ul>
<li>显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用<code>Class.forName(name)</code>或<code>this.getClass().getClassLoader().loadClass()</code>加载Class对象。</li>
<li>隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的<code>.class</code>文件时，该类的<code>.class</code>文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li>
</ul>
<p>在日常开发以上两种方式一般会混合使用。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式加载</span></span><br><span class="line">User user=<span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line"><span class="comment">//显式加载，并初始化</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">&quot;com.test.java.User&quot;</span>);</span><br><span class="line"><span class="comment">//显式加载，但不初始化</span></span><br><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.test.java.Parent&quot;</span>);</span><br></pre></td></tr></table></div></figure>
<p><code>Class.forName(name)</code>与<code>this.getClass().getClassLoader().loadClass()</code>加载Class对象的区别：</p>
<ul>
<li><code>Class.forName()</code>：是一个<strong>静态方法</strong>，最常用的是<code>Class.forName(String className);</code> 。其根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时，<strong>会执行类的初始化</strong>。</li>
<li><code>ClassLoader.loadClass()</code>：这是一个<strong>实例方法</strong>，需要一个ClassLoader对象来调用该方法。  该方法将Class文件加载到内存时，<strong>并不会执行类的初始化（默认情况下解析阶段也不会执行）</strong>，<strong>直到这个类第一次使用时才进行初始化</strong>（见后文源码分析，<code>loadClass()</code> 方法并没有初始化阶段的代码）。该方法因为需要得到一个ClassLoader对象，所以<strong>可以根据需要指定使用哪个类加载器</strong>。</li>
</ul>

        <h3 id="类加载器的必要性"   >
          <a href="#类加载器的必要性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类加载器的必要性"></a> 类加载器的必要性</h3>
      
<p>一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p>
<ul>
<li>避免在开发中遇到<code>java.lang.ClassNotFoundException</code>异常或<code>java.lang.NoClassDefFoundError</code>异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</li>
<li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li>
<li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li>
</ul>

        <h3 id="命名空间"   >
          <a href="#命名空间" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h3>
      
<p><strong>何为类的唯一性？</strong></p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。<strong>每一个类加载器都拥有一个独立的类名称空间</strong>。不同类加载器间的命名空间不同，相互不干扰。</p>
<p><strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<p><strong>命名空间</strong></p>
<ul>
<li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li>
<li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li>
<li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li>
</ul>
<p>在大型应用中，我们往往借助这一特性，来运行<strong>同一个类的不同版本</strong>。</p>

        <h3 id="类加载器的分类"   >
          <a href="#类加载器的分类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类加载器的分类"></a> 类加载器的分类</h3>
      
<p>JVM支持两种类型的类加载器 。分别为<strong>引导类加载器</strong>（Bootstrap ClassLoader）和<strong>自定义类加载器</strong>（User-Defined ClassLoader）。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将<strong>所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>。除了<strong>引导类加载器</strong>，其他类加载器都集成自抽象类<code>ClassLoader</code>，因此都属于自定义类加载器。</p>
<blockquote>
<p>启动类加载器通过C/C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被JDK开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器。<strong>自定义类型加载器是由引导类加载器所加载的</strong>，在JVM启动时，引导类加载器加载并调用Launcher类，创建出自定义类型加载器，<strong>并创建一个单独的Launcher线程</strong>。</p>
</blockquote>
<p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/9d1ee398a719d8c95024a6311be0d4d6.png" alt="img" /></p>
<p>这里的四者之间是<strong>包含关系</strong>，不是上层和下层，也不是子系统的继承关系。正是由于子类加载器中包含着父类加载器的引用，所以可以通过子类加载器的方法获取对应的父类加载器，这也是双亲委派机制实现的基础。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/20201120104448.png" alt="img" /></p>
<p>我们通过一个类，获取它不同的加载器：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取其上层的：扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 试图获取 根加载器</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取自定义加载器</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取String类型的加载器</span></span><br><span class="line">        ClassLoader classLoader1 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>得到的结果，从结果可以看出<strong>根加载器无法直接通过代码获取</strong>，同时目前用户代码所使用的加载器为<strong>系统类加载器</strong>。同时我们通过获取<code>String</code>类型的加载器，发现是<code>null</code>，那么说明<code>String</code>类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">null </span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/d47503a1999253a84256a94887e5cb79.png" alt="img" /></p>
<p><strong>说明：</strong></p>
<ul>
<li>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载器压根儿就不是一个Java类，因此在Java程序中只能打印出空值。</li>
<li>数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器来说，是通过<code>Class.getClassLoader()</code>返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的。</li>
</ul>

        <h3 id="启动类加载器引导类加载器bootstrap-classloader"   >
          <a href="#启动类加载器引导类加载器bootstrap-classloader" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#启动类加载器引导类加载器bootstrap-classloader"></a> 启动类加载器（引导类加载器，Bootstrap ClassLoader）</h3>
      
<ul>
<li>这个类加载使用<strong>C/C++语言实现</strong>的，嵌套在JVM内部。</li>
<li>它用来加载Java的核心库（<code>JAVAHOME/jre/1ib/rt.jar</code>、<code>resources.jar</code>或<code>sun.boot.class.path</code>路径下的内容），用于提供JVM自身需要的类</li>
<li>并不继承自<code>java.lang.ClassLoader</code>，没有父加载器。</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li>
</ul>

        <h3 id="扩展类加载器extension-classloader"   >
          <a href="#扩展类加载器extension-classloader" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#扩展类加载器extension-classloader"></a> 扩展类加载器（Extension ClassLoader）</h3>
      
<ul>
<li><strong>Java语言编写</strong>，由<code>sun.misc.Launcher$ExtClassLoader</code>实现，是Launcher类的<strong>内部类</strong>。</li>
<li>派生于<code>ClassLoader</code>类</li>
<li>用于加载Java后期版本不断扩展出的类</li>
<li>父类加载器为启动类加载器</li>
<li>从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或从JDK的安装目录的<code>jre/lib/ext</code>子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI3MTcwODM3NTM4LnBuZw" alt="img" /></p>

        <h3 id="应用程序类加载器系统类加载器appclassloader"   >
          <a href="#应用程序类加载器系统类加载器appclassloader" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#应用程序类加载器系统类加载器appclassloader"></a> 应用程序类加载器（系统类加载器，AppClassLoader）</h3>
      
<ul>
<li><strong>Java语言</strong>编写，由<code>sun.misc.Launchers$AppClassLoader</code>实现，是Launcher类的内部类</li>
<li>派生于<code>ClassLoader</code>类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量<code>classpath</code>或系统属性<code>java.class.path</code>指定路径下的类库（用户自定义的类都由该加载器加载）</li>
<li>该类加载是程序中<strong>默认的类加载器</strong>，一般来说，Java应用的类都是由它来完成加载</li>
<li>通过<code>classLoader#getSystemclassLoader()</code>方法可以获取到该类加载器</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI3MTcwOTE4MDM3LnBuZw" alt="img" /></p>

        <h3 id="用户自定义类加载器"   >
          <a href="#用户自定义类加载器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#用户自定义类加载器"></a> 用户自定义类加载器</h3>
      
<p><strong>用户自定义的类加载器的父类加载器<code>parent</code>是 AppClassLoader</strong>，见下图：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211015211158127.png" alt="image-20211015211158127" /></p>
<p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
<p>为什么要自定义类加载器？</p>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄漏</li>
</ul>
<p>体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</p>
<p>通过类加载器可以实现非常绝妙的<strong>插件机制</strong>，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种<strong>动态增加新功能的机制</strong>，这种机制无须重新打包发布应用程序就能实现。</p>
<p>同时，自定义加载器能够实现<strong>应用隔离</strong>。例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</p>
<p>自定义类加载器通常需要继承于<code>ClassLoader</code>。用户自定义类加载器实现步骤：</p>
<ul>
<li>开发人员可以通过继承抽象类<code>java.lang.ClassLoader</code>类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在JDK1.2之前，在自定义类加载器时，总会去继承<code>ClassLoader</code>类并重写<code>loadClass()</code>方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖<code>loadClass()</code>方法，而是建议把自定义的类加载逻辑写在<code>findClass()</code>方法中，这样就不会破坏默认<code>loadClass()</code>方法里的双亲委派机制逻辑。</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，<strong>可以直接继承<code>URIClassLoader</code>类</strong>，这样就可以避免自己去编写<code>findClass()</code>方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//defineClass和findClass搭配使用</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义流的获取方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassFromCustomPath(String name) &#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>, <span class="keyword">true</span>, customClassLoader);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="查看根加载器所能加载的目录"   >
          <a href="#查看根加载器所能加载的目录" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#查看根加载器所能加载的目录"></a> 查看根加载器所能加载的目录</h3>
      
<p>根加载器只能够加载 <code>java/lib</code>目录下的class，我们通过下面代码验证一下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*********启动类加载器************&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取BootstrapClassLoader 能够加载的API的路径</span></span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            System.out.println(url.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器</span></span><br><span class="line">        ClassLoader classLoader = Provider.class.getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>得到的结果</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*********启动类加载器************</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;lib&#x2F;resources.jar</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;lib&#x2F;rt.jar</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;lib&#x2F;sunrsasign.jar</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;lib&#x2F;jsse.jar</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;lib&#x2F;jce.jar</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;lib&#x2F;charsets.jar</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;lib&#x2F;jfr.jar</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;classes</span><br><span class="line">null</span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/d47503a1999253a84256a94887e5cb79.png" alt="img" /></p>

        <h2 id="classloader-源码解析"   >
          <a href="#classloader-源码解析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#classloader-源码解析"></a> ClassLoader 源码解析</h2>
      

        <h3 id="关于-classloader"   >
          <a href="#关于-classloader" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关于-classloader"></a> 关于 ClassLoader</h3>
      
<p><code>ClassLoader</code>类，它是一个<strong>抽象类</strong>，其后所有的类加载器都继承自<code>ClassLoader</code>（不包括启动类加载器）</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705103516138-1632294600690.png" alt="image-20200705103516138" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/20201120104448.png" alt="img" /></p>
<p>其中，<code>ExtClassLoader</code> 和 <code>AppClassLoader</code> 都是<code>sun.misc.Launcher</code> 类的<strong>内部类</strong>。</p>

        <h3 id="launcher"   >
          <a href="#launcher" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#launcher"></a> Launcher</h3>
      
<p><code>sun.misc.Launcher</code> 是Java虚拟机的入口应用（启动器），由该类负责设置当前程序的系统类加载器：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211015145906637.png" alt="image-20211015145906637" /></p>
<p>其中，创建扩展类加载器的细节：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211015145400761.png" alt="image-20211015145400761" /></p>
<p>获取<code>ClassLoader</code>的途径：</p>
<ul>
<li>获取当前<code>ClassLoader</code>：<code>clazz.getClassLoader()</code>（每个Class对象都保存有加载其的类加载器对象）</li>
<li>获取当前线程上下文的<code>ClassLoader</code>：<code>Thread.currentThread().getContextClassLoader()</code></li>
<li>获取系统的<code>ClassLoader</code>：<code>ClassLoader.getSystemClassLoader()</code></li>
<li>获取调用者的<code>ClassLoader</code>：<code>DriverManager.getCallerClassLoader()</code></li>
</ul>
<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类<code>java.lang.ClassLoader</code>，所有用户自定义的类加载器都应该继承<code>ClassLoader</code>类。</p>

        <h3 id="loadclass-源码"   >
          <a href="#loadclass-源码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#loadclass-源码"></a> loadClass() 源码</h3>
      
<p>当调用类加载器主动加载类时：<code>this.getClass().getClassLoader().loadClass()</code>，将经过以下过程：</p>
<ul>
<li><code>findLoadedClass(name)</code>：先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</li>
<li><code>loadClass(name)</code>：首先基于双亲委派机制，不断向上找父类加载器看是否能加载该类，一直找到引导类加载器；</li>
<li>如果父类不能加载，则尝试调用当前类加载器的 <code>findClass(name)</code> 方法进行加载</li>
<li><code>findClass(name)</code> 方法内将调用 <code>defineClass(name, res)</code> 方法（底层调用 native 本地方法），根据传入的类名称 <code>name</code> 和二进制流 <code>res</code> 将目标类进行加载，为其创建一个 Class 类型对象</li>
<li>此时才完成了类的加载阶段，但是注意还没有进行链接阶段和初始化阶段</li>
<li>如果 <code>loadClass(name, resolve)</code> 方法传入了参数 <code>resolve == true</code>，则将进行链接阶段：<code>resolveClass(c)</code></li>
<li><code>loadClass()</code> 方法并没有初始化阶段的代码，说明用这种方式加载类是不会初始化的，只有等到该类第一次被调用时才会执行<code>&lt;clinit&gt;()</code>初始化（区别于 <code>Class.forName(name)</code> 方式，该方式是会初始化的）。</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211015152354574.png" alt="image-20211015152354574" /></p>
<p><code>findClass(name)</code> 类由 <code>URLClassLoader</code>重写，在其内调用 <code>defineClass(name, res)</code> 真正进行加载Class。该方法由 <code>protected</code> 修饰，说明是被保护的，只能由其子类调用，外部程序无法访问该方法，这是JVM的一种类加载<strong>保护机制</strong>。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211015152829587.png" alt="image-20211015152829587" /></p>
<p>在 <code>defineClass(name, res)</code> 方法内，将根据传入的类名称 <code>name</code> 和二进制流 <code>res</code> 将目标类进行加载，为其创建一个 Class 类型对象，至此才即完成了类的加载，但是还没解析和初始化。</p>
<p>开发人员可以自定义类加载器继承<code>URIClassLoader</code>类，重写 <code>findClass()</code> 方法，在内编写自定义的加载流程，例如加密解密，但是必须最后在其内调用 <code>defineClass()</code> 方法加载类。</p>
<p><strong>注意不要重写 <code>loadClass()</code> 方法，因为开发人员自定义的 <code>loadClass()</code> 方法可能会破坏双亲委派机制</strong>。</p>

        <h2 id="双亲委派模型"   >
          <a href="#双亲委派模型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#双亲委派模型"></a> 双亲委派模型</h2>
      
<p>Java虚拟机对<code>.class</code>文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的<code>.class</code>文件加载到内存生成<code>Class</code>对象。而且加载某个类的<code>.class</code>文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>
<p>但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</p>
<ul>
<li><strong>可见性</strong>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>
<li><strong>单一性</strong>，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</li>
</ul>

        <h3 id="工作原理"   >
          <a href="#工作原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3>
      
<ul>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705105151258-1632294600690.png" alt="image-20200705105151258" /></p>

        <h3 id="源码支持"   >
          <a href="#源码支持" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#源码支持"></a> 源码支持</h3>
      
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211015152354574.png" alt="image-20211015152354574" /></p>
<p>双亲委派机制在<code>java.lang.ClassLoader.loadClass(String, boolean)</code>接口中体现。该接口的逻辑如下：</p>
<ul>
<li>先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</li>
<li>判断当前加载器的父加载器是否为空，如果不为空，则调用<code>parent.loadClass(name, false)</code>接口进行加载。</li>
<li>反之，如果当前加载器的父类加载器为空，则调用<code>findBootstrapClassorNull(name)</code>接口，让引导类加载器进行加载。</li>
<li>如果通过以上3条路径都没能成功加载，则调用<code>findClass(name)</code>接口进行加载。该接口最终会调用<code>java.lang.ClassLoader</code>接口的<code>defineClass()</code>系列的native接口加载目标Java类。</li>
</ul>
<p>双亲委派的模型就隐藏在这第2和第3步中。</p>
<p><strong>举例</strong></p>
<p>假设当前加载的是<code>java.lang.Object</code>这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当]VM准备加载<code>java.lang.Object</code>时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null，因此系统调用<code>findClass(String)</code>，最终通过引导类加载器进行加载。</p>
<hr />
<p>如果在自定义的类加载器中重写<code>java.lang.ClassLoader.loadClass(String)</code>或<code>java.lang.ClassLoader.loadclass(String, boolean)</code>方法，抹去其中的双亲委派机制，仅保留上面这4步中的第l步与第4步，那么是不是就能够加载核心类库了呢？</p>
<p>这也不行！因为JDK还为核心类库提供了一层<strong>保护机制</strong>。不管是自定义的类加载器，还是系统类加载器亦或扩展类加载器，最终都必须调用 <code>java.lang.ClassLoader.defineclass(String, byte[], int, int, ProtectionDomain)</code>方法，而该方法会执行<code>preDefineClass()</code>接口，该接口中<strong>提供了对JDK核心类库的保护</strong>。</p>
<hr />

        <h3 id="双亲委派模型的优势"   >
          <a href="#双亲委派模型的优势" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#双亲委派模型的优势"></a> 双亲委派模型的优势</h3>
      
<p>双亲机制可以：</p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改
<ul>
<li>自定义类：<code>java.lang.String</code></li>
<li>自定义类：<code>java.lang.ShkStart</code>（报错：阻止创建 <code>java.lang</code> 开头的类）</li>
</ul>
</li>
</ul>

        <h3 id="双亲委派模型的弊端"   >
          <a href="#双亲委派模型的弊端" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#双亲委派模型的弊端"></a> 双亲委派模型的弊端</h3>
      
<p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即<strong>顶层的ClassLoader无法访问底层的ClassLoader所加载的类</strong>。</p>
<p>通常情况下，引导类加载器加载的类为系统核心类，包括一些重要的系统接口，而系统类加载器加载的为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是<strong>系统类访问应用类就会出现问题</strong>。比如在系统类中提供了一个接口，<strong>该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中</strong>（例如JDBC）。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。（引导类加载器向加载该类时，发现接口实现方法和工厂方法都在必须由系统类加载器加载，自己无法加载）</p>
<blockquote>
<p>总结上面的情况：引导类加载器负责加载比较基础的类，但如果有时这些比较基础的类又要回调回其子类实现的方法（用户的代码），则由于双亲委派模型的限制，无法处理这种情况</p>
</blockquote>
<p>一个典型的例子便是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/study-everyday/p/6723313.html" >JNDI服务</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（Java Naming and Directory Interface，<strong>命名与目录接口</strong>），JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到<code>rt.jar</code>的），肯定属于Java中很基础的类型了。</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://jiges.github.io/2017/12/08/JNDI%E6%98%AF%E4%BB%80%E4%B9%88/" >https://jiges.github.io/2017/12/08/JNDI是什么/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ，<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/wanxiaoderen/article/details/106638603" >https://blog.csdn.net/wanxiaoderen/article/details/106638603</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>但<strong>JNDI存在的目的就是对资源进行查找和集中管理</strong>，它需要调用由其他厂商实现并部署在应用程序的<code>ClassPath</code>下的JNDI<strong>服务提供者接口</strong>（Service Provider Interface，SPI）的代码。现在问题来了，启动类加载器是绝不可能认识、加载这些代码的（SPI：在Java平台中，通常把核心类<code>rt.jar</code>中提供外部服务、可由应用层自行实现的接口称为SPI，例如JDBC）。</p>
<p>解决方案：使用<strong>上下文类加载管理器。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码</strong></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018103731245.png" alt="image-20211018103731245" /></p>
<blockquote>
<p>上图中rt.jar中有要实现的SPI核心类的基础接口，在加载它的接口时需要调用实现类中的方法，但引导类加载器无法加载其实现类，只能交给线程上下文类加载器。</p>
</blockquote>
<p><strong>结论</strong></p>
<p><strong>Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已</strong>。比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</p>

        <h3 id="破坏双亲委派机制"   >
          <a href="#破坏双亲委派机制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#破坏双亲委派机制"></a> 破坏双亲委派机制</h3>
      
<p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到<strong>Java模块化</strong>出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>

        <h4 id="第一次破坏双亲委派机制重写-loadclass-方法"   >
          <a href="#第一次破坏双亲委派机制重写-loadclass-方法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#第一次破坏双亲委派机制重写-loadclass-方法"></a> 第一次破坏双亲委派机制：重写 loadClass() 方法</h4>
      
<p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一——即JDK1.2面世以前的“远古”时代。</p>
<p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类<code>java.lang.ClassLoader</code>则在Java的第一个版本中就已经存在，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，<strong>为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性</strong>，只能在JDK1.2之后的<code>java.lang.ClassLoader</code>中添加一个新的protected方法<code>findClass()</code>，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在<code>loadClass()</code>中编写代码。</p>
<p>上文我们已经分析过<code>loadClass()</code>方法，双亲委派的具体逻辑就实现在这里面，按照<code>loadClass()</code>方法的逻辑，如果父类加载失败，会自动调用自己的<code>findClass()</code>方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>

        <h4 id="第二次破坏双亲委派机制线程上下文类加载器"   >
          <a href="#第二次破坏双亲委派机制线程上下文类加载器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#第二次破坏双亲委派机制线程上下文类加载器"></a> 第二次破坏双亲委派机制：线程上下文类加载器</h4>
      
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的类加载器加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础的类又要回调回其子类实现的方法（用户的代码），该怎么办呢？</p>
<p>一个典型的例子便是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/study-everyday/p/6723313.html" >JNDI服务</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（Java Naming and Directory Interface，<strong>命名与目录接口</strong>），JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到<code>rt.jar</code>的），肯定属于Java中很基础的类型了。但<strong>JNDI存在的目的就是对资源进行查找和集中管理</strong>，它需要调用由其他厂商实现并部署在应用程序的<code>ClassPath</code>下的JNDI<strong>服务提供者接口</strong>（Service Provider Interface，SPI）的代码。现在问题来了，启动类加载器是绝不可能认识、加载这些代码的（SPI：在Java平台中，通常把核心类<code>rt.jar</code>中提供外部服务、可由应用层自行实现的接口称为SPI，例如JDBC）。</p>
<p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（<code>ThreadContextClassLoader</code>）。这个类加载器可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器<strong>默认就是应用程序类加载器</strong>。</p>
<p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。<strong>JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码</strong>，<strong>这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则</strong>。但这也是无可奈何的事情。 例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了<code>java.util.ServiceLoader</code>类，以<code>META-INF/services</code>中的配置信息，辅以<strong>责任链模式</strong>（类似于Spring Boot里的自动配置原理），这才算是给SPI的加载提供了一种相对合理的解决方案。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018103725540.png" alt="image-20211018103725540" /></p>
<p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p>

        <h4 id="第三次破坏双亲委派机制代码热替换"   >
          <a href="#第三次破坏双亲委派机制代码热替换" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#第三次破坏双亲委派机制代码热替换"></a> 第三次破坏双亲委派机制：代码热替换</h4>
      
<p>双亲委派模型的第三次“被破坏”是由于用户对<strong>程序动态性</strong>的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等（即修改了本地<code>.class</code>文件后，程序可以热修改，无需重新启动加载）</p>
<p>IBM公司主导的JSR-291（即OSGiR4.2）实现模块化热部署的关键是<strong>它自定义的类加载器机制的实现</strong>，<strong>每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换</strong>。<strong>在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构</strong>。</p>
<p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<ul>
<li><strong>将以 <code>java.*</code> 开头的类委派给父类加载器加载</strong></li>
<li><strong>否则，将委派列表名单内的类给父类加载器加载</strong></li>
<li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bund1e的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ul>
<p>说明：只有开头两点仍然符合双亲委派模型的原则，<strong>其余的类查找都是在平级的类加载器中进行的</strong></p>
<p><strong>小结</strong>：这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p>
<p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。</strong></p>

        <h3 id="热替换的实现"   >
          <a href="#热替换的实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#热替换的实现"></a> 热替换的实现</h3>
      
<p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。<strong>热替换的关键需求在于服务不能中断，修改必须立即表现在正在运行的系统之中</strong>。基本上大部分<strong>脚本语言</strong>都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p>
<p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p>
<p>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018103711336.png" alt="image-20211018103711336" /></p>
<p>因为每次热替换时都创建了新的自定义 ClassLoader 实例，所以其加载的类都是不同的，就可以实现热替换的效果。</p>

        <h3 id="双亲委派机制举例"   >
          <a href="#双亲委派机制举例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#双亲委派机制举例"></a> 双亲委派机制举例</h3>
      
<p>示例一：我们自己定义一个<code>java.lang</code>包，在其下面定义一个<code>String</code>类，里面声明了静态代码块</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/20201120145148.png" alt="img" /></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在一个测试类中加载String类，看看加载的String类是JDK自带的，还是我们自己编写的</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> java.lang.String();</span><br><span class="line">        System.out.println(<span class="string">&quot;你好，世界&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>结果：程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 <code>String</code>类</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/34e48ebaa5bd451522c8039215636172.png" alt="img" /></p>
<p>示例二：在我们自己定义的 String 类中整个 <code>main()</code> 方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/4afef5f16208076b038a6194447dcadb.png" alt="img" /></p>
<p>原因：由于双亲委派机制，我们的<code>String</code>类是由引导类加载器加载的，而引导类加载器并没有<code>main()</code>方法，所以会报错。</p>
<p>示例三：当我们加载 <code>jdbc.jar</code> 用于实现数据库连接的时候，首先我们需要知道的是 <code>jdbc.jar</code> 是基于SPI接口进行实现的，所以在加载的时候，<strong>会进行双亲委派，最终从根加载器中加载SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 <code>jdbc.jar</code> 的加载</strong>。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20200705105810107-1632294600691.png" alt="image-20200705105810107" /></p>
<p>示例四：在<code>java.lang</code>包下自定义类，发现出于保护机制，不允许我们自定义类。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShkStart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/61a081a966f66450d67c9615f11671a3.png" alt="img" /></p>

        <h2 id="沙箱安全机制"   >
          <a href="#沙箱安全机制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#沙箱安全机制"></a> 沙箱安全机制</h2>
      
<p>自定义<code>String</code>类，但是在加载自定义<code>String</code>类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（<code>rt.jar</code>包中<code>java\lang\String.class</code>），报错信息说没有<code>main()</code>方法，就是因为加载的是<code>rt.jar</code>包中的<code>String</code>类。</p>
<p>这样<strong>可以保证对java核心源代码的保护</strong>，这就是沙箱安全机制。</p>
<p>沙箱安全机制：</p>
<ul>
<li><strong>保证程序安全</strong></li>
<li><strong>保护Java原生的JDK代码</strong></li>
</ul>
<p><strong>Java安全模型的核心就是Java沙箱</strong>（sandbox）。什么是沙箱？<strong>沙箱是一个限制程序运行的环境</strong>。</p>
<p>沙箱机制就是<strong>将Java代码限定在虚拟机特定的运行范围内，并且严格限制代码对本地系统资源访问</strong>。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。</p>
<p>沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p>

        <h3 id="jdk-10-时期"   >
          <a href="#jdk-10-时期" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jdk-10-时期"></a> JDK 1.0 时期</h3>
      
<p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于<strong>沙箱（Sandbox）机制</strong>。如下图所示JDK 1.0安全模型：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018104311131.png" alt="image-20211018104311131" /></p>

        <h3 id="jdk-11-时期"   >
          <a href="#jdk-11-时期" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jdk-11-时期"></a> JDK 1.1 时期</h3>
      
<p>JDK 1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p>
<p>因此在后续的JDK 1.1版本中，针对安全机制做了改进，增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018104404224.png" alt="image-20211018104404224" /></p>

        <h3 id="jdk-12-时期"   >
          <a href="#jdk-12-时期" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jdk-12-时期"></a> JDK 1.2 时期</h3>
      
<p>在JDK 1.2版本中，再次改进了安全机制，增加了<strong>代码签名</strong>。<strong>不论本地代码或是远程代码，都会按照用户的安全策略设定</strong>，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018104435405.png" alt="image-20211018104435405" /></p>

        <h3 id="jdk-16-时期"   >
          <a href="#jdk-16-时期" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jdk-16-时期"></a> JDK 1.6 时期</h3>
      
<p>当前最新的安全机制实现，则引入了**域（Domain）**的概念。</p>
<p>虚拟机会把所有代码加载到不同的系统域和应用域。<strong>系统域部分专门负责与关键资源进行交互</strong>，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。</p>
<blockquote>
<p>思想类似于操作系统里的核心态和用户态，用户态想访问系统资源时必须转为核心态</p>
</blockquote>
<p>存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018104641337.png" alt="image-20211018104641337" /></p>

        <h2 id="自定义类的加载器"   >
          <a href="#自定义类的加载器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#自定义类的加载器"></a> 自定义类的加载器</h2>
      

        <h3 id="为什么要自定义类加载器"   >
          <a href="#为什么要自定义类加载器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#为什么要自定义类加载器"></a> 为什么要自定义类加载器？</h3>
      
<ul>
<li><strong>隔离加载类</strong>：在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如：<strong>Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序</strong>。</li>
<li><strong>修改类加载方式</strong>：类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</li>
<li><strong>扩展加载源</strong>：比如从数据库、网络、甚至是电视机机顶盒进行加载</li>
<li><strong>防止源码泄漏</strong>：Java代码容易被编译和篡改，可以进行<strong>编译加密</strong>。那么类加载也需要自定义，<strong>还原加密的字节码</strong>。</li>
</ul>
<p><strong>常见的场景</strong></p>
<ul>
<li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是JavaEE和OSGI、JPMS等框架。</li>
<li>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</li>
</ul>
<p><strong>注意</strong></p>
<p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。<strong>在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常</strong>。</p>

        <h3 id="实现方式"   >
          <a href="#实现方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#实现方式"></a> 实现方式</h3>
      
<p>Java提供了抽象类<code>java.lang.ClassLoader</code>，所有用户自定义的类加载器都应该继承<code>ClassLoader</code>类。</p>
<p>在自定义<code>ClassLoader</code>的子类时候，我们常见的会有两种做法:</p>
<ul>
<li>方式一：重写<code>loadClass()</code>方法</li>
<li>方式二：重写<code>findclass()</code>方法</li>
</ul>
<p><strong>对比</strong></p>
<ul>
<li>这两种方法本质上差不多，毕竟<code>loadClass()</code>也会调用<code>findClass()</code>，但是从逻辑上讲我们最好不要直接修改<code>loadClass()</code>的内部逻辑。建议的做法是只在<code>findClass()</code>里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</li>
<li><code>loadClass()</code>这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。</li>
<li>同时，也避免了自己重写<code>loadClass()</code>方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</li>
<li>当编写好自定义类加载器后，便可以在程序中调用<code>loadClass()</code>方法来实现类加载操作。</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>其父类加载器是<strong>系统类加载器</strong></li>
<li>JVM中的所有类加载都会使用<code>java.lang.ClassLoader.loadClass(String)</code>接口(自定义类加载器并重写<code>java.lang.ClassLoader.loadClass(String)</code>接口的除外)，连JDK的核心类库也不能例外。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//defineClass和findClass搭配使用</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义流的获取方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassFromCustomPath(String name) &#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>, <span class="keyword">true</span>, customClassLoader);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="java-9-新特性"   >
          <a href="#java-9-新特性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java-9-新特性"></a> Java 9 新特性</h2>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/u21195183/jvm/mrgsug#9eca4c5f" >https://www.yuque.com/u21195183/jvm/mrgsug#9eca4c5f</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>
<ul>
<li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(platform class loader)。可以通过classLoader的新方法<code>getPlatformClassLoader()</code>来获取。<br />
JDK9时基于模块化进行构建（原来的rt.jar和tools.jar被拆分成数十个JMOD文件），其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。</li>
<li>平台类加载器和应用程序类加载器都不再继承自<code>java.net.URLClassLoader</code>。现在启动类加载器、平台类加载器、应用程序类加载器全都继承于<code>jdk.internal.loader.BuiltinClassLoader</code>。</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018105345375.png" alt="image-20211018105345375" /></p>
<p>如果有程序直接依赖了这种继承关系，或者依赖了<code>URLClassLoader</code>类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。</p>
<ul>
<li>在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过<code>getName()</code>方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</li>
<li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到<code>BootClassLoader</code>实例。</li>
<li>类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20211018105552699.png" alt="image-20211018105552699" /></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent().getParent());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">        <span class="comment">//获取平台类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getPlatformClassLoader());</span><br><span class="line">        <span class="comment">//获取类的加载器的名称</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="其它"   >
          <a href="#其它" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#其它"></a> 其它</h2>
      

        <h3 id="如何判断两个-class-对象是否相同"   >
          <a href="#如何判断两个-class-对象是否相同" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#如何判断两个-class-对象是否相同"></a> 如何判断两个 class 对象是否相同</h3>
      
<p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名。</li>
<li><strong>加载这个类的<code>ClassLoader</code>（指ClassLoader实例对象）必须相同</strong>。</li>
</ul>
<p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的<code>ClassLoader</code>实例对象不同，那么这两个类对象也是不相等的。</p>
<p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>

        <h2 id="相关面试题"   >
          <a href="#相关面试题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#相关面试题"></a> 相关面试题</h2>
      
<p>蚂蚁金服：</p>
<ul>
<li>描述一下JVM加载Class文件的原理机制？</li>
<li>一面：类加载过程</li>
</ul>
<p>百度：</p>
<ul>
<li>类加载的时机</li>
<li>java类加载过程？</li>
<li>简述java类加载机制？</li>
</ul>
<p>腾讯：</p>
<ul>
<li>JVM中类加载机制，类加载过程？</li>
</ul>
<p>滴滴：</p>
<ul>
<li>JVM类加载机制</li>
</ul>
<p>美团：</p>
<ul>
<li>Java类加载过程</li>
<li>描述一下jvm加载class文件的原理机制</li>
</ul>
<p>京东：</p>
<ul>
<li>什么是类的加载？</li>
<li>哪些情况会触发类的加载？</li>
<li>讲一下JVM加载一个类的过程JVM的类加载机制是什么？</li>
</ul>
<p>蚂蚁金服：</p>
<ul>
<li>深入分析ClassLoader，双亲委派机制</li>
<li>类加载器的双亲委派模型是什么？一面：双亲委派机制及使用原因</li>
</ul>
<p>百度：</p>
<ul>
<li>都有哪些类加载器，这些类加载器都加载哪些文件？</li>
<li>手写一个类加载器Demo</li>
<li><code>Class.forName(“java.lang.String”)</code>和<code>Class.getClassLoader().loadClass(“java.lang.String)</code>有什么区别？</li>
</ul>
<p>腾讯：</p>
<ul>
<li>什么是双亲委派模型？</li>
<li>类加载器有哪些？</li>
</ul>
<p>小米：</p>
<ul>
<li>双亲委派模型介绍一下</li>
</ul>
<p>滴滴：</p>
<ul>
<li>简单说说你了解的类加载器</li>
<li>一面：讲一下双亲委派模型，以及其优点</li>
</ul>
<p>字节跳动：</p>
<ul>
<li>什么是类加载器，类加载器有哪些？</li>
</ul>
<p>京东：</p>
<ul>
<li>类加载器的双亲委派模型是什么？</li>
<li>双亲委派机制可以打破吗？为什么</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://yuyun-zhao.github.io">yuyun zhao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://yuyun-zhao.github.io/2021/09/22/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">http://yuyun-zhao.github.io/2021/09/22/%E3%80%90JVM%E3%80%91JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.github.io/tags/JVM/">JVM</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/09/22/%E3%80%90JVM%E3%80%91JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">【JVM】JVM 运行时数据区</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/09/20/%E3%80%90JVM%E3%80%91JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86/"><span class="paginator-prev__text">【JVM】JVM 字节码指令集</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-text">
           类加载器子系统概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BD%9C%E7%94%A8"><span class="toc-text">
           类加载器子系统作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">
           类的加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5-loading"><span class="toc-text">
           加载阶段 - Loading</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-class-%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">
           加载 .class 文件的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%B8%8E-class-%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">
           类模型与 Class 实例的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">
           数组类的加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5-linking"><span class="toc-text">
           链接阶段 - Linking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81-verify"><span class="toc-text">
           验证 - Verify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87-prepare"><span class="toc-text">
           准备 - Prepare</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-resolve"><span class="toc-text">
           解析 - Resolve</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5-initialization"><span class="toc-text">
           初始化阶段 - Initialization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#clinit%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-text">
           &lt;clinit&gt;()方法初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init-%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-text">
           &lt;init&gt;() 方法初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clinit-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">
           &lt;clinit&gt;() 的线程安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-text">
           类的主动使用和被动使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-text">
           主动使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-text">
           被动使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-text">
           卸载阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-text">
           类、类的加载器、类的实例之间的引用关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">
           类的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="toc-text">
           类的卸载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">
           类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">
           类加载的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-text">
           类加载器的必要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">
           命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">
           类加载器的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8bootstrap-classloader"><span class="toc-text">
           启动类加载器（引导类加载器，Bootstrap ClassLoader）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8extension-classloader"><span class="toc-text">
           扩展类加载器（Extension ClassLoader）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8appclassloader"><span class="toc-text">
           应用程序类加载器（系统类加载器，AppClassLoader）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">
           用户自定义类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%A0%B9%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%89%80%E8%83%BD%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-text">
           查看根加载器所能加载的目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#classloader-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">
           ClassLoader 源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-classloader"><span class="toc-text">
           关于 ClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#launcher"><span class="toc-text">
           Launcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loadclass-%E6%BA%90%E7%A0%81"><span class="toc-text">
           loadClass() 源码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">
           双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">
           工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E6%94%AF%E6%8C%81"><span class="toc-text">
           源码支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">
           双亲委派模型的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-text">
           双亲委派模型的弊端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">
           破坏双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E9%87%8D%E5%86%99-loadclass-%E6%96%B9%E6%B3%95"><span class="toc-text">
           第一次破坏双亲委派机制：重写 loadClass() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">
           第二次破坏双亲委派机制：线程上下文类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E7%83%AD%E6%9B%BF%E6%8D%A2"><span class="toc-text">
           第三次破坏双亲委派机制：代码热替换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E6%9B%BF%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">
           热替换的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E4%B8%BE%E4%BE%8B"><span class="toc-text">
           双亲委派机制举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-text">
           沙箱安全机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk-10-%E6%97%B6%E6%9C%9F"><span class="toc-text">
           JDK 1.0 时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk-11-%E6%97%B6%E6%9C%9F"><span class="toc-text">
           JDK 1.1 时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk-12-%E6%97%B6%E6%9C%9F"><span class="toc-text">
           JDK 1.2 时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk-16-%E6%97%B6%E6%9C%9F"><span class="toc-text">
           JDK 1.6 时期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">
           自定义类的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">
           为什么要自定义类加载器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">
           实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-9-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">
           Java 9 新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-text">
           其它</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA-class-%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C"><span class="toc-text">
           如何判断两个 class 对象是否相同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">
           相关面试题</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/author.png" alt="avatar"></div><p class="sidebar-ov-author__text">no code no life</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YUYUN-ZHAO" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="zyy18749810683" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1024462136" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:im.yuyunzhao@gmail.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gmail</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">140</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">39</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">39</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>yuyun zhao</span><span class="footer__devider">|</span><span>沪ICP备2022000458号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>