<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="本文首先介绍内存泄漏的常见案例并详细分析四种OOM案例下的排查方案，然后介绍一些JVM的调优实战案例，并演示JVM常见监控与诊断工具的使用。                      Java 内存泄露的 8 种情况        严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM">
<meta property="og:type" content="article">
<meta property="og:title" content="【JVM】JVM 调优实战案例">
<meta property="og:url" content="http://yuyun-zhao.github.io/2021/10/19/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/index.html">
<meta property="og:site_name" content="yuyun zhao&#39;s blog">
<meta property="og:description" content="本文首先介绍内存泄漏的常见案例并详细分析四种OOM案例下的排查方案，然后介绍一些JVM的调优实战案例，并演示JVM常见监控与诊断工具的使用。                      Java 内存泄露的 8 种情况        严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20200712195158470.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211019200416595.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20210520194055109.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20210520211835353.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211019202508227.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211019202528238.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211019202604985.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20210520214827223.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021202816470.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021202917101.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021203044271.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021203309218.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021203949345.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021204650402.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021204534884.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021205142061.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022190629659.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021213540629.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021213006851.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021213232807.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021214225726.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022115128142.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022094909679.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022095110080.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022095526532.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022104627351.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022104727014.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022104828175.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022104950763.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022105050210.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023100312067.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023134101136.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/%7BD6923547-8F8E-AF96-2ED5-5DC4197F0994%7D.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023100620829.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/%7BD004F3A8-BA30-BE0D-03E1-1FC18FE913CC%7D.jpg">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023102515646.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023102838831.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023143332988.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023143422165.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023164346392.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025094508183.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025095004147.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025095401459.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025095747754.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025143122524.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025143250556.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025143305762.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025143339575.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025143359293.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025143413295.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025144209223.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025144315086.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025144532203.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025144843498.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025144930791.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025145515800.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025151418354.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025151446184.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025151608283.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025151657880.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025151701558.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E6%A1%88%E4%BE%8B7%EF%BC%9A%E6%97%A5%E5%9D%87%E7%99%BE%E4%B8%87%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9FJVM%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE.png">
<meta property="article:published_time" content="2021-10-19T11:35:22.000Z">
<meta property="article:modified_time" content="2021-10-25T12:21:00.732Z">
<meta property="article:author" content="yuyun zhao">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20200712195158470.png"><title>【JVM】JVM 调优实战案例 | yuyun zhao's blog</title><link ref="canonical" href="http://yuyun-zhao.github.io/2021/10/19/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">文章</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">yuyun zhao's blog</div><div class="header-banner-info__subtitle">no code no life</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">【JVM】JVM 调优实战案例</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-25</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">16.8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">108分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><p>本文首先介绍内存泄漏的常见案例并详细分析四种OOM案例下的排查方案，然后介绍一些JVM的调优实战案例，并演示JVM常见监控与诊断工具的使用。</p>

        <h2 id="java-内存泄露的-8-种情况"   >
          <a href="#java-内存泄露的-8-种情况" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java-内存泄露的-8-种情况"></a> Java 内存泄露的 8 种情况</h2>
      
<p>严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏</strong>。但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20200712195158470.png" alt="image-20200712195158470" /></p>
<p>如下图，当Y生命周期结束的时候，X依然引用着Y，这时候，垃圾回收器是不会回收对象Y的；如果对象X还引用着生命周期比较短的A、B、C，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211019200416595.png" alt="image-20211019200416595" /></p>
<p>申请了内存用完了不释放，比如一共有1024M的内存，分配了512M的内存一直不回收，那么可以用的内存只有512M了，仿佛泄露掉了一部分。</p>
<span id="more"></span>

        <h3 id="内存泄漏的常见情况"   >
          <a href="#内存泄漏的常见情况" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存泄漏的常见情况"></a> 内存泄漏的常见情况</h3>
      
<ul>
<li>代码中有死循环</li>
<li>使用了静态集合类，在其内添加了过多的对象，一直无法被回收</li>
<li>使用了过多的单例对象，其内引用了其他外部对象，导致这些对象一直无法被回收</li>
<li>各种连接忘记关闭</li>
<li>变量作用域不合理</li>
<li>缓存泄漏：缓存数据过多，无法及时清理</li>
</ul>
<p>解决方案：</p>
<ul>
<li>尽量减少静态集合类的使用，或者在不使用集合内的对象后，及时设置为 null 进行清理</li>
<li>减少单例对象使用，尽量不引用外部对象</li>
<li>及时关闭连接</li>
<li>尽量使用局部变量，减少使用没必要的类成员变量</li>
<li>缓存数据使用 <code>WeakHashMap</code>，在其内对象失去其他引用后就自动清理</li>
</ul>

        <h3 id="静态集合类"   >
          <a href="#静态集合类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#静态集合类"></a> 静态集合类</h3>
      
<p>静态集合类，如<code>HashMap</code>、<code>LinkedList</code>等等。如果这些容器为<strong>静态</strong>的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>
<p>典型例子：在静态数组中不断添加对象，由于静态对象不会随着实例对象的回收而回收，因此其添加的对象就会造成内存泄漏：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尽管这个局部变量Object生命周期非常短</span></span><br><span class="line"><span class="comment">     * 但是它被生命周期非常长的静态列表引用</span></span><br><span class="line"><span class="comment">     * 所以不会被GC回收 发生内存溢出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oomTests</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object(); <span class="comment">//局部变量</span></span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>类卸载的条件非常苛刻,这个静态列表生命周期基本与JVM一样长</p>

        <h3 id="单例模式"   >
          <a href="#单例模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h3>
      
<p>单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</p>
<p><strong>饿汉式单例模式</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;not create instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>饿汉式的单例模式也是被静态变量引用，即使不需要使用这个单例对象了，GC也不会回收</p>

        <h3 id="非静态内部类持有外部类"   >
          <a href="#非静态内部类持有外部类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#非静态内部类持有外部类"></a> 非静态内部类持有外部类</h3>
      
<p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="function">new <span class="title">InnerClass</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InnerClass innerInstance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            InnerClassTest innerClassTest = <span class="keyword">new</span> InnerClassTest();</span><br><span class="line">            innerInstance = innerClassTest.getInnerInstance();</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;========= 外部实例对象内存布局 =========&quot;</span>);</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(innerClassTest).toPrintable());</span><br><span class="line">            System.out.println(<span class="string">&quot;========= 内部实例对象内存布局 =========&quot;</span>);</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(innerInstance).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>当调用外部类实例方法通过外部实例对象返回一个内部实例对象时（调用代码中的<code>getInnerInstance()</code>方法），外部实例对象不需要使用了，但内部实例对象被长期使用，会导致这个外部实例对象生命周期变长。</p>
<p><strong>因为内部实例对象隐藏了一个指针指向（引用）创建它的外部实例对象</strong></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20210520194055109.png" alt="img" /></p>

        <h3 id="各种连接如数据库连接-网络连接和-io-连接等"   >
          <a href="#各种连接如数据库连接-网络连接和-io-连接等" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#各种连接如数据库连接-网络连接和-io-连接等"></a> 各种连接，如数据库连接、网络连接和 IO 连接等</h3>
      
<p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用<code>close()</code>方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对<code>Connection</code>、<code>Statement</code>或<code>ResultSet</code>不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Connection conn =<span class="keyword">null</span>;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        conn =DriverManager.getConnection(<span class="string">&quot;url&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        Statement stmt =conn.createStatement();</span><br><span class="line">        ResultSet rs =stmt.executeQuery(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>（Exception e）&#123;</span><br><span class="line">        <span class="comment">// 异常日志</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 1．关闭结果集 Statement</span></span><br><span class="line">        <span class="comment">// 2．关闭声明的对象 ResultSet</span></span><br><span class="line">        <span class="comment">// 3．关闭连接 Connection</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="变量不合理的作用域"   >
          <a href="#变量不合理的作用域" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#变量不合理的作用域"></a> 变量不合理的作用域</h3>
      
<p>一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        readFromNet();  <span class="comment">// 从网络中接受数据保存到msg中</span></span><br><span class="line">        saveDB();       <span class="comment">// 把msg保存到数据库中</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 应该在使用完后手动 msg = null;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如上面这个伪代码，通过<code>readFromNet()</code>方法把接受的消息保存在变量msg中，然后调用<code>saveDB()</code>方法把msg的内容保存到数据库中，此时msg已经就没用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因此造成了内存泄漏。实际上这个msg变量可以放在<code>receiveMsg()</code>方法内部，当方法使用完，那么msg的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完msg后，<strong>把msg设置为nul</strong>l，这样垃圾回收器也会回收msg的内存空间。</p>

        <h3 id="改变哈希值"   >
          <a href="#改变哈希值" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#改变哈希值"></a> 改变哈希值</h3>
      
<p>改变哈希值，当一个对象被存储进<code>HashSet</code>集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。否则，对象修改后的哈希值与最初存储进<code>HashSet</code>集合中时的哈希值就不同了，在这种情况下，即使在<code>contains()</code>方法使用该对象的当前引用作为的参数去<code>HashSet</code>集合中检索对象，也将返回找不到对象的结果，这也会导致无法从<code>HashSet</code>集合中单独删除当前对象，造成内存泄漏。</p>
<p>这也是 String 为什么被设置成了不可变类型，我们可以放心地把 String 存入 <code>HashSet</code>，或者把String 当做 <code>HashMap</code> 的 key 值；</p>
<p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的 <code>hashCode</code> 不可变。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line"></span><br><span class="line">        p1.name = <span class="string">&quot;CC&quot;</span>; <span class="comment">// 导致了内存的泄漏</span></span><br><span class="line">        set.remove(p1); <span class="comment">// 删除失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != person.id) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(person.name) : person.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">            <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>所以说对象当作Key存入散列表时，该对象最好是逻辑不可变对象，不能在外界改变它的关键域，从而无法改变哈希值：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20210520211835353.png" alt="image-20210520211835353" /></p>
<p>将关键域设置为final，只能在实例代码块中初始化或构造器中。如果关键域是引用类型,可以用final修饰后，对外不提供改变该引用关键域的方法，从而让外界无法修改引用关键域中的值 (如同String类型，所以String常常用来当作散列表的Key)</p>

        <h3 id="缓存泄露"   >
          <a href="#缓存泄露" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#缓存泄露"></a> 缓存泄露</h3>
      
<p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如：之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存（内存）中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p>
<p>对于这个问题，可以使用<code>WeakHashMap</code>代表缓存（其内的 <code>Entry</code>是弱引用），此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p>
<blockquote>
<p><code>WeakHashMap</code> 内部的<code>Entry</code>是弱引用，当它的Key不再使用时，下次垃圾回收就会回收掉，不会发生内存泄漏</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map wMap = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line">    <span class="keyword">static</span> Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        testWeakHashMap();</span><br><span class="line">        testHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String ref1 = <span class="keyword">new</span> String(<span class="string">&quot;obejct1&quot;</span>);</span><br><span class="line">        String ref2 = <span class="keyword">new</span> String(<span class="string">&quot;obejct2&quot;</span>);</span><br><span class="line">        String ref3 = <span class="keyword">new</span> String(<span class="string">&quot;obejct3&quot;</span>);</span><br><span class="line">        String ref4 = <span class="keyword">new</span> String(<span class="string">&quot;obejct4&quot;</span>);</span><br><span class="line">        wMap.put(ref1, <span class="string">&quot;cacheObject1&quot;</span>);</span><br><span class="line">        wMap.put(ref2, <span class="string">&quot;cacheObject2&quot;</span>);</span><br><span class="line">        map.put(ref3, <span class="string">&quot;cacheObject3&quot;</span>);</span><br><span class="line">        map.put(ref4, <span class="string">&quot;cacheObject4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;String引用ref1，ref2，ref3，ref4 消失&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WeakHashMap GC之前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;WeakHashMap GC之后&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap GC之前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap GC之后&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上面代码和图示主演演示<code>WeakHashMap</code>如何自动释放缓存对象，当<code>init()</code>函数执行完成后，局部变量字符串引用weakd1，weakd2，d1，d2都会消失，此时只有静态map中保存着对字符串对象的引用，可以看到，调用gc之后，<code>HashMap</code>的没有被回收，而<code>WeakHashMap</code>里面的缓存被回收了。</p>

        <h3 id="监听器和其他回调"   >
          <a href="#监听器和其他回调" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#监听器和其他回调"></a> 监听器和其他回调</h3>
      
<p>如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。</p>
<p>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为<code>WeakHashMap</code>中的键。</p>

        <h3 id="内存泄露案例分析"   >
          <a href="#内存泄露案例分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存泄露案例分析"></a> 内存泄露案例分析</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123; <span class="comment">// 入栈</span></span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="comment">// 出栈</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上述程序并没有明显的错误，但是这段程序有一个内存泄漏，随着GC活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄漏，但是这种失败情况相对较少。</p>
<p>代码的主要问题在<code>pop()</code>函数，下面通过这张图示展现。假设这个栈一直增长，增长后如下图所示：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211019202508227.png" alt="image-20211019202508227" /></p>
<p>当进行大量的<code>pop()</code>操作时，由于引用未进行置空，gc是不会释放的，如下图所示：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211019202528238.png" alt="image-20211019202528238" /></p>
<p>从上图中看以看出，如果栈先增长，再收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些队象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称过期引用，这个内存泄露很隐蔽。</p>
<p>将代码中的<code>pop()</code>方法变成如下方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    Object result = elements[--size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>一旦引用过期，清空这些引用，将引用置空。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211019202604985.png" alt="image-20211019202604985" /></p>
<p>动态数组<code>ArrayList</code>中<code>remove()</code>操作会改变size的同时将删除位置置空，从而不再引用元素,避免内存泄漏：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20210520214827223.png" alt="img" /></p>

        <h2 id="oom-出现的原因"   >
          <a href="#oom-出现的原因" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#oom-出现的原因"></a> OOM 出现的原因</h2>
      
<p>主要分为四类：</p>
<ul>
<li>堆溢出：<code>java.lang.OutOfMemoryError: Java heap space</code>，原因为对象数量过多（最常见）</li>
<li>元空间溢出： <code>java.lang.OutOfMemoryError: Metaspace</code>，原因为基于<strong>反射</strong>原理动态加载过多的类</li>
<li>超出 GC 开销限制：<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>，原因为<strong>超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常</strong>。本质是一个<strong>预判性</strong>的异常，抛出该异常时系统没有真正的内存溢出，而是<strong>预判到马上就要溢出了</strong>。</li>
<li>线程栈溢出：<code>java.lang.OutOfMemoryError : unable to create new native Thread</code>，原因为线程数量超出限制或超出操作系统上限</li>
</ul>
<blockquote>
<p>如果某一个线程栈所占用的内存空间大于了其设置值，报的是 <code>StackOverflowError</code></p>
</blockquote>

        <h2 id="oom-案例一堆溢出"   >
          <a href="#oom-案例一堆溢出" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#oom-案例一堆溢出"></a> OOM 案例一：堆溢出</h2>
      

        <h3 id="案例模拟"   >
          <a href="#案例模拟" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#案例模拟"></a> 案例模拟</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryTestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userSevice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 案例1：模拟线上环境OOM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;add&quot;</span> + userSevice);</span><br><span class="line">        ArrayList&lt;User&gt; people = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            people.add(<span class="keyword">new</span> User());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>JVM 参数：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:MetaspaceSize&#x3D;64m -XX:+HeapDumpOnOutOfMemoryError </span><br><span class="line">-XX:HeapDumpPath&#x3D;heap&#x2F;heapdump.hprof -XX:+PrintGCDateStamps</span><br><span class="line">-Xms50M  -Xmx50M  -Xloggc:log&#x2F;gc-oomHeap.log  </span><br></pre></td></tr></table></div></figure>
<p>运行结果：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210) ~[na:1.8.0_131] at java.util.Arrays.copyOf(Arrays.java:3181) ~[na:1.8.0_131] at java.util.ArrayList.grow(ArrayList.java:261) ~[na:1.8.0_131] at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235) ~[na:1.8.0_131] at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227) ~[na:1.8.0_131] 运行程序得到 heapdump.hprof 文件。</span><br></pre></td></tr></table></div></figure>
<p>报错信息：<code>java.lang.OutOfMemoryError: Java heap space</code></p>

        <h3 id="原因及解决方案"   >
          <a href="#原因及解决方案" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#原因及解决方案"></a> 原因及解决方案</h3>
      
<p>原因：</p>
<ul>
<li>代码中可能存在大对象分配</li>
<li>可能存在内存泄漏，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。</li>
</ul>
<p>解决方法：</p>
<ul>
<li>检查是否存在大对象的分配，最有可能的是大数组分配</li>
<li>通过<code>jmap</code>命令，把堆内存dump下来，使用MAT等工具分析一下，检查是否存在内存泄漏的问题</li>
<li>如果没有找到明显的内存泄漏，使用 <code>-Xmx</code> 加大堆内存</li>
<li>还有一点容易被忽略，检查是否有大量的自定义的 <code>Finalizable</code> 对象（这些自定义对象很可能会“复活”），也有可能是框架内部提供的，考虑其存在的必要性</li>
</ul>

        <h3 id="jvisual-vm-排查"   >
          <a href="#jvisual-vm-排查" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jvisual-vm-排查"></a> JVisual VM 排查</h3>
      
<p>通过jvisualvm工具查看，<strong>占用最多实例的类是哪个</strong>，这样就可以定位到我们的问题所在。</p>
<p>排查流程：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021202816470.png" alt="image-20211021202816470" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021202917101.png" alt="image-20211021202917101" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021203044271.png" alt="image-20211021203044271" /></p>
<p>分析对象情况，发现有大量的 User 对象：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021203309218.png" alt="image-20211021203309218" /></p>

        <h3 id="mat-排查"   >
          <a href="#mat-排查" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mat-排查"></a> MAT 排查</h3>
      
<p>使用MAT工具查看，能找到对应的线程及相应线程中对应实例的位置和代码：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021203949345.png" alt="image-20211021203949345" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021204650402.png" alt="image-20211021204650402" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021204534884.png" alt="image-20211021204534884" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021205142061.png" alt="image-20211021205142061" /></p>

        <h3 id="gceasy-查看"   >
          <a href="#gceasy-查看" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#gceasy-查看"></a> GCeasy 查看</h3>
      
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022190629659.png" alt="image-20211022190629659" /></p>
<p>可以看到每次 Full GC 后，堆空间大小都基本不变，并且也接近上限，说明有大量的内存泄漏。</p>

        <h2 id="oom-案例二元空间溢出"   >
          <a href="#oom-案例二元空间溢出" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#oom-案例二元空间溢出"></a> OOM 案例二：元空间溢出</h2>
      

        <h3 id="案例模拟-2"   >
          <a href="#案例模拟-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#案例模拟-2"></a> 案例模拟</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 案例2:模拟元空间OOM溢出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/metaSpaceOom&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">metaSpaceOom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassLoadingMXBean classLoadingMXBean = ManagementFactory.getClassLoadingMXBean();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(User.class);</span><br><span class="line">        <span class="comment">//            enhancer.setUseCache(false);</span></span><br><span class="line">        enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">        enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是加强类，输出print之前的加强方法&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> methodProxy.invokeSuper(o,objects);</span><br><span class="line">        &#125;);</span><br><span class="line">        User user = (User)enhancer.create();</span><br><span class="line">        user.print();</span><br><span class="line">        System.out.println(user.getClass());</span><br><span class="line">        System.out.println(<span class="string">&quot;totalClass:&quot;</span> + classLoadingMXBean.getTotalLoadedClassCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;activeClass:&quot;</span> + classLoadingMXBean.getLoadedClassCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;unloadedClass:&quot;</span> + classLoadingMXBean.getUnloadedClassCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>JVM 参数：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xms60M  -Xmx60M -XX:MetaspaceSize&#x3D;60m -XX:MaxMetaspaceSize&#x3D;60m -Xss512K</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;heap&#x2F;heapdumpMeta.hprof </span><br><span class="line">-XX:SurvivorRatio&#x3D;8 -XX:+TraceClassLoading -XX:+TraceClassUnloading </span><br><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:log&#x2F;gc-oomMeta.log</span><br></pre></td></tr></table></div></figure>
<p>报错信息：<code>java.lang.OutOfMemoryError: Metaspace</code></p>

        <h3 id="原因及解决方案-2"   >
          <a href="#原因及解决方案-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#原因及解决方案-2"></a> 原因及解决方案</h3>
      
<p>JDK 8 后，元空间替换了永久代，元空间使用的是本地内存，原因：</p>
<ul>
<li>运行期间生成了大量的代理类，导致方法区被撑爆，无法卸载</li>
<li>应用长时间运行，没有重启</li>
<li>元空间内存设置过小</li>
</ul>
<p>解决方法：</p>
<ul>
<li>检查是否永久代空间或者元空间设置的过小</li>
<li>检查代码中是否存在大量的<strong>反射</strong>操作</li>
<li>dump之后通过MAT检查是否存在<strong>大量由于反射生成的代理类</strong></li>
</ul>
<p>本案例的具体解决方案：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enhancer.setUseCache(<span class="keyword">false</span>); <span class="comment">// 开启缓存</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="命令行查看-gc-情况"   >
          <a href="#命令行查看-gc-情况" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#命令行查看-gc-情况"></a> 命令行查看 GC 情况</h3>
      
<p>可以使用 jstat 命令查看堆空间和元空间的内存情况：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc pid 1000 10</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>每隔 1000 ms 打印一次 GC 情况，共打印 10 次</p>
</blockquote>
<p>打印结果：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021213540629.png" alt="image-20211021213540629" /></p>
<p>可以看到元空间几乎被占满了，并且出现了大量的 Full GC 。那么我们接下来分析到底是什么数据占用了大量的方法区。</p>

        <h3 id="jvisual-vm-排查-2"   >
          <a href="#jvisual-vm-排查-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jvisual-vm-排查-2"></a> JVisual VM 排查</h3>
      
<p>通过jvisualvm工具查看元空间的内存情况，请求访问前：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021213006851.png" alt="image-20211021213006851" /></p>
<p>访问该请求后，动态加载大量类，可以看到元空间占用明显增加，直至造成OOM：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021213232807.png" alt="image-20211021213232807" /></p>
<p>接着查看方法栈情况，找到自己包下的方法栈：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211021214225726.png" alt="image-20211021214225726" /></p>
<p>根据方法栈信息，找到代码中的相应位置，是因为创建了大量的类：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = (User)enhancer.create();</span><br></pre></td></tr></table></div></figure>

        <h3 id="mat-排查-2"   >
          <a href="#mat-排查-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mat-排查-2"></a> MAT 排查</h3>
      
<p>首先我们先确定是哪里的代码发生了问题，首先可以通过线程来确定，因为在实际生产环境中，有时候是无法确定是哪块代码引起的OOM，那么我们就需要先定位问题线程，然后定位代码，如下图所示：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022115128142.png" alt="image-20211022115128142" /></p>
<p>从上图可以看到出现异常的方法栈位置在自己代码的第50行。</p>
<p>定位到代码以后，发现有使用到<strong>cglib动态代理</strong>，那么我们猜想一下问题是不是由于产生了很多代理类，接下来，我们可以通过包看一下我们的类加载情况：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022094909679.png" alt="image-20211022094909679" /></p>
<p>这里发现Method类的实例非常多，查看with outgoing references发现了很多的User类在调用相关的方法。由于我们的代码是代理的User类，所以我们直接打开User类所在的包，打开如下图所示：可以看到确实加载了很多的代理类（<code>User$$EnhancerByCGLIB</code>）：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022095110080.png" alt="image-20211022095110080" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022095526532.png" alt="image-20211022095526532" /></p>
<p>最终找到了原因：动态加载了大量的类导致元空间OOM</p>

        <h2 id="oom-案例三gc-overhead-limit-exceeded"   >
          <a href="#oom-案例三gc-overhead-limit-exceeded" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#oom-案例三gc-overhead-limit-exceeded"></a> OOM 案例三：GC overhead limit exceeded</h2>
      

        <h3 id="案例模拟-3"   >
          <a href="#案例模拟-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#案例模拟-3"></a> 案例模拟</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 案例3：测试 GC overhead limit exceeded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">        <span class="comment">//test2();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().intern());</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;************i: &quot;</span> + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Integer i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                str += UUID.randomUUID();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;************i: &quot;</span> + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>JVM 配置：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails  -XX:+HeapDumpOnOutOfMemoryError </span><br><span class="line">-XX:HeapDumpPath&#x3D;heap&#x2F;dumpExceeded.hprof </span><br><span class="line">-XX:+PrintGCDateStamps  -Xms10M  -Xmx10M </span><br><span class="line">-Xloggc:log&#x2F;gc-oomExceeded.log</span><br></pre></td></tr></table></div></figure>
<p>报错信息：<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code></p>
<p>GC 日志：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7110K-&gt;7095K(7168K)] 9158K-&gt;9143K(9728K), </span><br><span class="line">[Metaspace: 3177K-&gt;3177K(1056768K)], 0.0479640 secs] [Times: user&#x3D;0.23 sys&#x3D;0.01, real&#x3D;0.05 secs] </span><br><span class="line">java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7114K-&gt;7096K(7168K)] 9162K-&gt;9144K(9728K), </span><br><span class="line">[Metaspace: 3198K-&gt;3198K(1056768K)], 0.0408506 secs] [Times: user&#x3D;0.22 sys&#x3D;0.01, real&#x3D;0.04 secs]  </span><br></pre></td></tr></table></div></figure>
<p>通过查看GC日志可以发现，系统在频繁性的做Full GC，但是却没有回收掉多少空间，那么引起的原因可能是因为内存不足，也可能是存在内存泄漏的情况，接下来我们要根据堆dump文件来具体分析。</p>

        <h3 id="原因与解决方案"   >
          <a href="#原因与解决方案" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#原因与解决方案"></a> 原因与解决方案</h3>
      
<p>原因分析：这个是 JDK 6 新加的错误类型，一般都是<strong>堆太小</strong>导致的。Sun 官方对此的定义：<strong>超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常</strong>。本质是一个<strong>预判性</strong>的异常，抛出该异常时系统没有真正的内存溢出，而是<strong>预判到马上就要溢出了</strong>。</p>
<p><strong>第一段代码</strong>：运行期间将内容放入常量池的典型案例 。<code>intern()</code> 方法：</p>
<ul>
<li>如果字符串常量池里面已经包含了等于字符串X的字符串，那么就返回常量池中这个字符串的引用；</li>
<li>如果常量池中不存在，那么就会把当前字符串添加到常量池并返回这个字符串的引用</li>
</ul>
<p><strong>第二段代码</strong>：不停的追加字符串 str 你可能会疑惑，看似 demo 也没有差太多，为什么第二个没有报 <code>GC overhead limit exceeded</code> 呢？以上两个demo的区别在于：</p>
<ul>
<li><code>Java heap space</code> 的 demo 每次都能回收大部分的对象（中间产生的UUID），只不过有一个对象是无法回收的，慢慢长大（字符串长度越来越大），直到内存溢出</li>
<li><code>GC overhead limit exceeded</code> 的 demo 由于每个字符串都在被list引用，所以无法回收，很快就用完内存，触发不断回收的机制。</li>
</ul>
<p>解决方案：</p>
<p>根据业务来修改是否需要死循环。</p>
<ul>
<li>检查项目中是否有大量的死循环或有使用大内存的代码，优化代码。</li>
<li>添加参数 <code>-XX:-UseGCOverheadLimit</code> 禁用这个检查，其实这个参数解决不了内存问题，只是把错误的信息延后，最终出现 <code>java.lang.OutOfMemoryError: Java heap space</code>。</li>
<li>dump内存，检查是否存在内存泄漏，如果没有，<strong>加大内存</strong>。</li>
</ul>

        <h3 id="jvisual-vm-排查-3"   >
          <a href="#jvisual-vm-排查-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jvisual-vm-排查-3"></a> JVisual VM 排查</h3>
      
<p>定位到了具体的线程中具体出现问题的代码的位置，进而进行优化即可</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022104627351.png" alt="image-20211022104627351" /></p>

        <h3 id="mat-排查-3"   >
          <a href="#mat-排查-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mat-排查-3"></a> MAT 排查</h3>
      
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022104727014.png" alt="image-20211022104727014" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022104828175.png" alt="image-20211022104828175" /></p>
<p>上图中找到我们自己线程出现异常的方法栈位置，在26行，在代码中看到是因为进行了死循环，不停的往 <code>ArrayList</code>存放字符串常量（JDK1.8以后，字符串常量池移到了堆中存储，所以最终导致内存不足发生了OOM）</p>
<p>同时从上图中可以看到我们自己线程下的局部变量 <code>java.util.ArrayList</code> 的深堆对象占用大量内存，分析其 outgoing reference，发现其内存储了大量的 String 对象：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022104950763.png" alt="image-20211022104950763" /></p>
<p>接着分析dump文件直方图，打开Histogram，可以看到，String类型的字符串占用了大概8M的空间，几乎把堆占满，但是还没有占满，所以这也符合Sun官方对此的定义：超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常，本质是一个预判性的异常，抛出该异常时系统没有真正的内存溢出。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211022105050210.png" alt="image-20211022105050210" /></p>

        <h2 id="oom-案例四线程栈溢出"   >
          <a href="#oom-案例四线程栈溢出" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#oom-案例四线程栈溢出"></a> OOM 案例四：线程栈溢出</h2>
      

        <h3 id="案例模拟-4"   >
          <a href="#案例模拟-4" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#案例模拟-4"></a> 案例模拟</h3>
      
<blockquote>
<p>不添加 -Xss 参数</p>
</blockquote>
<p>在主程序中，不断创建新的线程，直到报异常：<code>java.lang.OutOfMemoryError : unable to create new native Thread</code>。同时操作系统失去响应，需要重新启动。</p>
<p>出现这种异常，基本上都是<strong>创建了大量的线程</strong>导致的，超出了系统的资源上限。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 15241 </span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread </span><br><span class="line">at java.lang.Thread.start0(Native Method)</span><br><span class="line">at java.lang.Thread.start(Thread.java:717)</span><br><span class="line">at TestNativeOutOfMemoryError.main(TestNativeOutOfMemoryError.java:9)</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>添加 -Xss 参数，设置<strong>每个</strong>线程栈的大小</p>
</blockquote>
<p>在 Linux 下运行 Java 程序，并添加 JVM 参数设置线程栈大小：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss512k TestNativeOutOfMemory</span><br></pre></td></tr></table></div></figure>
<p>发现同样在 15241 左右次迭代时出现 OOM，似乎这个参数不起作用？</p>

        <h3 id="原因"   >
          <a href="#原因" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#原因"></a> 原因</h3>
      
<p>通过 <code>-Xss</code> 可以设置<strong>每个</strong>线程栈大小的容量。</p>
<ul>
<li>JDK 5.0 以后每个线程堆栈大小为1M，</li>
<li>JDK 5.0 以前每个线程堆栈大小为256K。</li>
</ul>
<blockquote>
<p>如果一个线程栈的大小超出 -Xss 设置的值，就会报 SOF：Stack Over Flow</p>
</blockquote>
<p>正常情况下，在相同物理内存下，减小这个值能生成更多的线程。但是<strong>操作系统</strong>对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 能创建的线程数的具体计算公式如下：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(MaxProcessMemory - JVMMemory - ReservedOsMemory) &#x2F; (ThreadStackSize) &#x3D; Number of threads</span><br></pre></td></tr></table></div></figure>
<ul>
<li><code>MaxProcessMemory</code>：进程可寻址的最大空间</li>
<li><code>JVMMemory</code>：JVM内存</li>
<li><code>ReservedOsMemory</code>：保留的操作系统内存</li>
<li><code>ThreadStackSize</code>：线程栈的大小</li>
</ul>
<p>在Java语言里， 当你创建一个线程的时候，虚拟机会在JVM内存创建一个Thread对象同时创建一个操作系统线程，而这个系统线程的内存用的不是JVMMemory，而是系统中剩下的内存<code>(MaxProcessMemory - JVMMemory - ReservedOsMemory)</code>。</p>
<p>由公式得出结论：<strong>你给JVM内存越多，那么你能创建的线程越少</strong>，越容易发生<code>java.lang.OutOfMemoryError: unable to create new native thread</code>。 综上，在生产环境下如果需要更多的线程数量，建议使用64位操作系统，如果必须使用32位操作系统，可以通过调整<code>-Xss</code>的大小来控制线程数量。</p>
<p>而之所以出现上面设不设置参数，结果都一样的原因是：64 位操作系统的<code>MaxProcessMemory</code>值非常非常大，可以理解为正无穷，所以就算分母除以的参数是默认的1M还是512K，算出来的线程数都特别特别多大，早就已经超出了操作系统的上限</p>
<p>因为受到系统上限的影响，设不设置，可以出关键的线程数都达到了上限 15000+。因此两个案例启示都是在超出操作系统资源上限时OOM的，并没有达到这个公式里的理论值。</p>

        <h3 id="补充"   >
          <a href="#补充" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#补充"></a> 补充</h3>
      
<p>线程总数也受到系统空闲内存和操作系统的限制，检查是否该系统下有此限制：</p>
<ul>
<li>/proc/sys/kernel/pid_max：系统最大pid值，在大型系统里可适当调大</li>
<li>/proc/sys/kernel/threads-max：系统允许的最大线程数</li>
<li>maxuserprocess（ulimit -u）：系统限制某用户下最多可以运行多少进程或线程</li>
<li>/proc/sys/vm/max_map_count：max_map_count文件包含限制一个进程可以拥有的VMA（虚拟内存区域）的数量。虚拟内存区域是一个连续的虚拟地址空间区域。</li>
</ul>
<p>在进程的生命周期中，每当程序尝试在内存中映射文件，链接到共享内存段，或者分配堆空间的时候，这些区域将被创建。调优这个值将限制进程可拥有VMA的数量。限制一个进程拥有VMA的总数可能导致应用程序出错，因为当进程达到了VMA上线但又只能释放少量的内存给其他的内核进程使用时，操作系统会抛出内存不足的错误。如果你的操作系统在NORMAL区域仅占用少量的内存，那么调低这个值可以帮助释放内存给内核用。</p>

        <h2 id="jvm-调优概述"   >
          <a href="#jvm-调优概述" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jvm-调优概述"></a> JVM 调优概述</h2>
      

        <h3 id="为什么要调优"   >
          <a href="#为什么要调优" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#为什么要调优"></a> 为什么要调优？</h3>
      
<ul>
<li>防止出现 OOM，进行 JVM 规划和<strong>预</strong>调优（例如在上线前先压测）</li>
<li>解决程序<strong>运行中</strong>各种 OOM（运行时及时排查出OOM原因）</li>
<li>减少 Full GC 出现的频率，解决运行慢、卡顿问题</li>
</ul>
<p>总结：预防 OOM，减少 Full GC。</p>

        <h3 id="调优的大方向"   >
          <a href="#调优的大方向" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调优的大方向"></a> 调优的大方向</h3>
      
<ul>
<li>合理地编写代码</li>
<li>充分并合理的使用硬件资源</li>
<li>合理地进行JVM调优</li>
</ul>

        <h3 id="调优监控的依据"   >
          <a href="#调优监控的依据" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调优监控的依据"></a> 调优监控的依据</h3>
      
<ul>
<li>运行日志</li>
<li>异常堆栈</li>
<li>GC日志</li>
<li>线程快照</li>
<li>堆转储快照</li>
</ul>

        <h3 id="性能优化的步骤"   >
          <a href="#性能优化的步骤" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#性能优化的步骤"></a> 性能优化的步骤</h3>
      
<ul>
<li>第1步：熟悉业务场景</li>
<li>第2步（发现问题）：性能监控
<ul>
<li>GC 频繁</li>
<li>CPUload过高</li>
<li>OOM</li>
<li>内存泄漏（可能导致OOM）</li>
<li>死锁（可能导致CPU负载过高）</li>
<li>程序响应时间较长（说明频繁GC）</li>
</ul>
</li>
<li>第3步（排查问题）：性能分析
<ul>
<li>打印GC日志，通过GCviewer或者 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://gceasy.xn--io-403c94fkt1ad0as3zz3cdl" >http://gceasy.io来分析日志信息</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>灵活运用命令行工具，jstack，jmap，jinfo等</li>
<li>dump出堆文件，使用内存分析工具MAT分析文件</li>
<li>使用阿里Arthas，或jconsole，JVisualVM来实时查看JVM状态</li>
<li>jstack查看堆栈信息</li>
</ul>
</li>
<li>第4步（解决问题）：性能调优
<ul>
<li>适当<strong>增加内存</strong>，根据业务背景选择合适的垃圾回收器</li>
<li>优化代码，控制内存使用</li>
<li><strong>增加机器</strong>，分散节点压力</li>
<li>合理设置<strong>线程池</strong>线程数量</li>
<li>使用<strong>中间件</strong>提高程序效率，比如缓存，消息队列等</li>
</ul>
</li>
</ul>

        <h3 id="性能评价测试指标"   >
          <a href="#性能评价测试指标" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#性能评价测试指标"></a> 性能评价/测试指标</h3>
      
<ul>
<li><strong>停顿时间</strong>（或响应时间）</li>
<li><strong>吞吐量</strong></li>
<li>并发数</li>
<li>内存占用</li>
<li>相互间的关系</li>
</ul>

        <h2 id="调优案例一调整堆大小提升服务的吞吐量"   >
          <a href="#调优案例一调整堆大小提升服务的吞吐量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调优案例一调整堆大小提升服务的吞吐量"></a> 调优案例一：调整堆大小提升服务的吞吐量</h2>
      
<p>本案例演示在不同堆大小的配置下，对比服务的吞吐量与GC情况。</p>
<p>首先需要配置 Linux 下 Tomcat 的堆内存大小。</p>
<p>生产环境下，Tomcat并不建议直接在<code>catalina.sh</code>里配置变量，而是写在与catalina同级目录（bin目录）下的<code>setenv.sh</code>里。 所以如果我们想要修改jvm的内存配置，那么我们就需要修改<code>setenv.sh</code>文件（默认没有，需新建一个<code>setenv.sh</code>）。</p>

        <h3 id="初始配置堆内存较小"   >
          <a href="#初始配置堆内存较小" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#初始配置堆内存较小"></a> 初始配置：堆内存较小</h3>
      
<p>初始配置（堆内存设置较小）：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xms20m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:SurvivorRatio&#x3D;8&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xmx20m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+UseParallelGC&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+PrintGCDetails&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:MetaspaceSize&#x3D;64m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+PrintGCDateStamps&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xloggc:&#x2F;opt&#x2F;tomcat8.5&#x2F;logs&#x2F;gc.log&quot; </span><br></pre></td></tr></table></div></figure>
<hr />
<p>-Xms 和 -Xmx 两个参数设置相同的值，目的是为了能够在每次GC后不需要再重新计算堆区要分配的大小，从而提高性能。</p>
<p>如果二者设置不相同，则每次GC后，会根据当前GC的效果动态调整堆区的大小：回收效果好 -&gt; 减小堆区大小；回收效果差 -&gt; 增大堆区大小</p>
<hr />
<p>使用 JMeter 进行压测，发送50 * 1000个请求：观察吞吐量与GC情况。</p>
<p>吞吐量：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023100312067.png" alt="image-20211023100312067" /></p>
<p>使用 <code>jstat -gc pid 1000 5</code> 查看压测前GC情况：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023134101136.png" alt="image-20211023134101136" /></p>
<p>压测后GC情况：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/%7BD6923547-8F8E-AF96-2ED5-5DC4197F0994%7D.png" alt="img" /></p>
<p>可以看出，在压测后，出现了大量的 Full GC，这正是因为堆区内存过小导致的，严重拖慢了系统效率。并且从 GC 日志文件中也可以看到大量的 Full GC：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2021-10-23T09:58:50.445+0800: 129.233: [Full GC (Ergonomics) [PSYoungGen: 5632K-&gt;0K(6144K)] [ParOldGen: 12061K-&gt;12061K(13824K)] 17693K-&gt;12061K(19968K),[Metaspace: 20418K-&gt;20418K(1069056K)], 0.0134114 secs] [Times: user&#x3D;0.03 sys&#x3D;0.01, real&#x3D;0.02 secs]</span><br><span class="line">2021-10-23T09:58:50.547+0800: 129.335: [Full GC (Ergonomics) [PSYoungGen: 5632K-&gt;0K(6144K)] [ParOldGen: 12061K-&gt;12062K(13824K)] 17693K-&gt;12062K(19968K), [Metaspace: 20418K-&gt;20418K(1069056K)], 0.0137774 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.02 secs]</span><br><span class="line">2021-10-23T09:58:50.648+0800: 129.436: [Full GC (Ergonomics) [PSYoungGen: 5632K-&gt;0K(6144K)] [ParOldGen: 12062K-&gt;12062K(13824K)] 17694K-&gt;12062K(19968K), [Metaspace: 20418K-&gt;20418K(1069056K)], 0.0149746 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.01 secs]</span><br></pre></td></tr></table></div></figure>

        <h3 id="优化配置堆内存增大"   >
          <a href="#优化配置堆内存增大" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优化配置堆内存增大"></a> 优化配置：堆内存增大</h3>
      
<p>现在增加堆内存空间大小：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xms120m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:SurvivorRatio&#x3D;8&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xmx120m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+UseParallelGC&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+PrintGCDetails&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:MetaspaceSize&#x3D;64m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+PrintGCDateStamps&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xloggc:&#x2F;opt&#x2F;tomcat8.5&#x2F;logs&#x2F;gc.log&quot; </span><br></pre></td></tr></table></div></figure>
<p>再进行 50 * 1000 次压测，观察吞吐量与GC情况与之前的区别。</p>
<p>吞吐量：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023100620829.png" alt="image-20211023100620829" /></p>
<p>压测前后GC情况：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/%7BD004F3A8-BA30-BE0D-03E1-1FC18FE913CC%7D.jpg" alt="img" /></p>
<p>这次可以看到，压测前后 Full GC 数量没有增加，只进行了少量了 Young GC，同时吞吐量也提升了，说明增大堆内存空间的确能够有效提高系统吞吐量。</p>

        <h2 id="调优案例二逃逸分析"   >
          <a href="#调优案例二逃逸分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调优案例二逃逸分析"></a> 调优案例二：逃逸分析</h2>
      

        <h3 id="逃逸分析简介"   >
          <a href="#逃逸分析简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#逃逸分析简介"></a> 逃逸分析简介</h3>
      
<p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
<p>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围，从而决定是否要将这个对象分配到堆上。 逃逸分析的基本行为就是分析对象<strong>动态作用域</strong>：当一个对象在方法中被定义后，<strong>对象只在方法内部使用，则认为没有发生逃逸</strong>。当一个对象在方法中被定义后，<strong>它被外部方法所引用，则认为发生逃逸</strong>。没有发生逃逸的对象，则<strong>可以分配到栈上</strong>，随着方法执行的结束，栈空间就被移除。</p>
<p>JIT 编译器在开启逃逸分析后即可实现以下功能：</p>
<ul>
<li>标量替换：用标量值代替聚合对象的属性值</li>
<li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li>
<li>同步消除：清除同步操作，通常指消除没必要的<code>synchronized</code></li>
</ul>
<p>注意：</p>
<ul>
<li>逃逸分析只有在 JIT 及时编译阶段才会对代码进行优化，在字节码文件里还是原样代码，并不会在前期编译就做优化。</li>
<li>Hotspot 并没有真正实现将对象存储在栈上，而是使用标量替换的形式将对象拆解成标量后存储在栈上，而不是直接将引用类型变量存储在栈上。<strong>即 Hotspot 中的栈上分配是通过标量替换实现的</strong>。</li>
</ul>

        <h3 id="逃逸分析示例"   >
          <a href="#逃逸分析示例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#逃逸分析示例"></a> 逃逸分析示例</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span>? <span class="keyword">new</span> EscapeAnalysis() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思考：如果当前的obj引用声明为static的，会发生逃逸吗？会！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 也发生了逃逸</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">(EscapeAnalysis e)</span></span>&#123;</span><br><span class="line">        <span class="comment">// e</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="优化一栈上分配"   >
          <a href="#优化一栈上分配" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优化一栈上分配"></a> 优化一：栈上分配</h3>
      
<blockquote>
<p>Hotspot 中的栈上分配是通过标量替换实现的，具体分析见后文。</p>
</blockquote>
<p>首先测试开启栈上分配与不开启的区别，开启栈上分配在开启逃逸分析后即可开启。</p>

        <h4 id="开启逃逸分析"   >
          <a href="#开启逃逸分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#开启逃逸分析"></a> 开启逃逸分析</h4>
      
<p><strong>默认情况下即开启了逃逸分析</strong>，无需再手动指明 <code>-XX:+DoEscapeAnalysis</code>。</p>
<p>只要开启了逃逸分析，就会判断方法中的变量是否发生了逃逸。如果没有发生逃逸，则会使用栈上分配，提高程序性能。</p>
<p>案例代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配测试</span></span><br><span class="line"><span class="comment"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只要开启了逃逸分析，就会判断方法中的变量是否发生了逃逸。如果没有发生逃逸，则会使用栈上分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(); <span class="comment">// 是否发生逃逸？ 没有！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>JVM 参数：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></div></figure>
<p>开启了逃逸分析后，因为启动了栈上分配技术，所以运行速度极快，程序循环部分只耗时了 4 ms。并且通过 jvisualvm 观察内存情况，发现内存中并没有大量的 User 对象：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023102515646.png" alt="image-20211023102515646" /></p>

        <h4 id="关闭逃逸分析"   >
          <a href="#关闭逃逸分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关闭逃逸分析"></a> 关闭逃逸分析</h4>
      
<p>通过参数 <code>-XX:-DoEscapeAnalysis</code> 可以关闭逃逸分析。</p>
<p>JVM 参数：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></div></figure>
<p>关闭逃逸分析后，同样的程序耗时了 85 ms。并且通过 jvisualvm 观察内存情况，发现内存中有大量的 User 对象：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023102838831.png" alt="image-20211023102838831" /></p>

        <h3 id="优化二标量替换"   >
          <a href="#优化二标量替换" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优化二标量替换"></a> 优化二：标量替换</h3>
      
<p>Hotspot 中的栈上分配是通过标量替换实现的，标量替换是 Hotspot 虚拟机逃逸分析的基础。</p>
<p>案例代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标量替换测试</span></span><br><span class="line"><span class="comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  结论：Java中的逃逸分析，其实优化的点就在于对栈上分配的对象进行标量替换。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScalarReplace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User(); <span class="comment">// 未发生逃逸</span></span><br><span class="line">        u.id = <span class="number">5</span>;</span><br><span class="line">        u.name = <span class="string">&quot;www.xxx.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="开启标量替换"   >
          <a href="#开启标量替换" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#开启标量替换"></a> 开启标量替换</h4>
      
<p><strong>标量替换默认情况下就是开启的</strong>，可以手动开启/关闭。并且标量替换若想开启，必须先开启逃逸分析：<code>-XX:+DoEscapeAnalysis</code>：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis -XX:+EliminateAllocations</span><br></pre></td></tr></table></div></figure>
<p>首先开启标量替换，JVM参数：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:-EliminateAllocations</span><br></pre></td></tr></table></div></figure>
<p>此时程序耗时大概 4 ms。</p>

        <h4 id="关闭标量替换"   >
          <a href="#关闭标量替换" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关闭标量替换"></a> 关闭标量替换</h4>
      
<p>首先开启标量替换，JVM参数：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+EliminateAllocations</span><br></pre></td></tr></table></div></figure>
<p>此时程序耗时大概 48 ms。</p>
<p><strong>注意</strong>：此时即可看出一些端倪。本程序在不开启标量替换的情况下，JVM参数设置和栈上分配案例一样，同样都开启了<code>-XX:+DoEscapeAnalysis</code>，理应运行时间也只有几毫秒，但是本例却耗费了几十毫秒的时间，而不是像开启栈上分配案例一样只有 4ms。<strong>这说明了栈上分配的就是通过标量替换才实现的，不开启标量替换，栈上分配就无从谈起</strong>。</p>

        <h4 id="对比"   >
          <a href="#对比" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对比"></a> 对比</h4>
      
<p>最后对比两种情况下打印的堆空间情况。</p>
<p>开启时：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023143332988.png" alt="image-20211023143332988" /></p>
<p>关闭时：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023143422165.png" alt="image-20211023143422165" /></p>
<p>可以看到开启标量替换后，伊甸园区的大小明显减小，说明的确将大量的对象拆解成了标量，存储在了栈上。</p>

        <h3 id="优化三同步消除省略"   >
          <a href="#优化三同步消除省略" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优化三同步消除省略"></a> 优化三：同步消除（省略）</h3>
      
<p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。 线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
<p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，</span></span><br><span class="line"><span class="comment">        * 并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 问题：字节码文件中会去掉hollis吗？：答：不会，只有在编译阶段才会去掉</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">            System.out.println(hollis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 优化后；</span></span><br><span class="line"><span class="comment">        * Object hollis = new Object();</span></span><br><span class="line"><span class="comment">        * System.out.println(hollis);</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="逃逸分析小结"   >
          <a href="#逃逸分析小结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#逃逸分析小结"></a> 逃逸分析小结</h3>
      
<p>逃逸分析并不成熟。关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。其根本原因就是无法保证非逃逸分析的性能消耗一定能高于他的消耗。</p>
<p>虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。一个极端的例子，<strong>就是经过逃逸分析之后，发现没有一个对象是不逃逸的，那这个逃逸分析的过程就白白浪费掉了</strong>。</p>
<p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。目前很多书籍还是基于JDK 7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p>

        <h2 id="调优案例三合理配置堆内存"   >
          <a href="#调优案例三合理配置堆内存" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调优案例三合理配置堆内存"></a> 调优案例三：合理配置堆内存</h2>
      
<p>在案例一中我们讲到了增加内存可以提高系统的性能而且效果显著，那么随之带来的一个问题就是，我们增加多少内存比较合适？</p>
<ul>
<li>如果内存过大，那么产生Full GC时，GC时间会相对比较长（因为遍历堆空间耗时增加了）</li>
<li>如果内存较小，那么就会频繁触发GC</li>
</ul>
<p>在这种情况下，我们该如何合理的适配堆内存大小呢？</p>

        <h3 id="官方推荐配置"   >
          <a href="#官方推荐配置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#官方推荐配置"></a> 官方推荐配置</h3>
      
<p>我们可以根据Java虚拟机规范里 Java Performance 里面的推荐公式来进行设置：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211023164346392.png" alt="image-20211023164346392" /></p>
<p>翻译：</p>
<ul>
<li>Java整个堆大小：<code>-Xmx</code> 和 <code>-Xms</code> 设置为<strong>老年代存活对象</strong>的 <strong>3 - 4</strong> 倍，即Full GC之后的老年代内存占用的3-4倍。并且二者设置相同，避免动态调整堆大小造成性能损耗</li>
<li>方法区（永久代或元空间）大小：设置为老年代存活对象的 <strong>1.2 - 1.5</strong> 倍</li>
<li>年轻代大小：<code>-Xmn</code> 设置为老年代存活对象的 <strong>1 - 1.5</strong> 倍</li>
<li>老年代大小：设置为老年代存活对象的 <strong>2 - 3</strong> 倍（大小为<code>-Xmx</code>大小减去<code>-Xmn</code>大小）</li>
</ul>
<p>但是，上面的说法也不是绝对的，也就是说这给的是一个<strong>参考值</strong>，根据多种调优之后得出的一个结论，可以根据这个值来设置一下我们的初始化内存，在保证程序正常运行的情况下，我们还要去查看GC的回收率，GC停顿耗时，内存里的实际数据来判断，Full GC是基本上不能有的，如果有就要做内存Dump分析，然后再去做一个合理的内存分配。</p>
<p>我们还要注意到一点就是，上面说的老年代存活对象怎么去判定。</p>

        <h3 id="如何计算老年代存活对象"   >
          <a href="#如何计算老年代存活对象" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#如何计算老年代存活对象"></a> 如何计算老年代存活对象</h3>
      
<p>要么在运行时在命令行打印的日志里观察，要么直接dump一次，强制做一次GC，然后分析GC日志。</p>

        <h4 id="方式一查看日志推荐"   >
          <a href="#方式一查看日志推荐" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方式一查看日志推荐"></a> 方式一：查看日志（推荐）</h4>
      
<p>JVM参数中添加<strong>GC日志</strong>（<code>-XX:+PrintGCDetails</code>），GC日志中会记录每次Full GC之后各代的内存大小，观察老年代GC之后的空间大小。可观察一段时间内（比如2天）Full GC之后的内存情况，根据多次的Full GC之后的老年代的空间大小数据来预估Full GC之后老年代的存活对象大小（可根据多次Full GC之后的内存大小取平均值）。</p>

        <h4 id="方式二强制触发fullgc"   >
          <a href="#方式二强制触发fullgc" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方式二强制触发fullgc"></a> 方式二：强制触发FullGC</h4>
      
<p><strong>会影响线上服务，慎用！</strong></p>
<p>方式一比较可行，但需要更改JVM参数，并分析日志。同时，在使用CMS回收器的时候，有可能不能触发Full GC（因为运行中CMS的一次Full GC很可能会使用老年代串行Serial Old GC，它的速度是极慢的），或者程序上线后一直没有GC过，所以没有打印过日志，即日志中并没有记录Full GC的日志，这在分析的时候就比较难处理。 所以，有时候需要<strong>强制触发</strong>一次Full GC，来观察FullGC之后的老年代存活对象大小。</p>
<p>注：强制触发Full GC，会造成线上服务停顿（STW），要谨慎！建议的操作方式为：<strong>在强制Full GC前先把服务节点摘除，Full GC之后再将服务挂回可用节点，对外提供服务</strong>，在<strong>不同时间段</strong>触发Full GC，根据多次Full GC之后的老年代内存情况来预估Full GC之后的老年代存活对象大小。</p>
<blockquote>
<p>线上服务进行压测比强制Full GC影响更大，会导致极大的STW，谨慎使用。</p>
</blockquote>
<p>如何强制触发Full GC？</p>
<ul>
<li><code>jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</code>：将当前的存活对象dump到文件，此时会触发FullGC。会<strong>顺带触发一次Full GC</strong>。</li>
<li><code>jmap -histo:live &lt;pid&gt;</code>：打印每个class的实例数目、内存占用、类全名信息。.live子参数加上后，只统计活的对象数量。此时会<strong>顺带触发一次Full GC</strong>。</li>
<li>在性能测试环境，可以通过Java监控工具来触发Full GC，比如使用VisualVM和JConsole，VisualVM集成了JConsole，VisualVM或者JConsole上面有一个触发GC的按钮。</li>
</ul>
<blockquote>
<p>生成 dump 文件时都会顺便触发一次 Full GC</p>
</blockquote>

        <h3 id="案例演示"   >
          <a href="#案例演示" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#案例演示"></a> 案例演示</h3>
      
<p>将内存初始化为1024M。JVM配置参数：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize&#x3D;64m -Xss512K -Xms1024M  -Xmx1024M </span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;heap&#x2F;heapdump3.hprof  </span><br><span class="line">-XX:SurvivorRatio&#x3D;8  -XX:+PrintGCDetails -XX:+PrintGCDateStamps  </span><br><span class="line">-Xloggc:log&#x2F;gc-oom3.log</span><br></pre></td></tr></table></div></figure>
<p>编写代码，每次请求都从数据库中查询指令，模拟真实业务：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getData&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;User&gt; userList = userSevice.getUserList();</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="数据分析"   >
          <a href="#数据分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#数据分析"></a> 数据分析</h3>
      

        <h4 id="初始情况"   >
          <a href="#初始情况" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#初始情况"></a> 初始情况</h4>
      
<p>项目启动，通过jmeter访问10000次（主要是看项目是否可以正常运行）之后，查看GC状态：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc pid</span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025094508183.png" alt="image-20211025094508183" /></p>
<ul>
<li>YGC 平均耗时： 0.12s * 1000 / 7 = 17.14ms</li>
<li>FGC 未产生</li>
</ul>
<p>看起来似乎不错，YGC触发的频率不高，FGC也没有产生，但这样的内存设置是否还可以继续优化呢？是不是有一些空间是浪费的呢。</p>

        <h4 id="查看老年代存活对象大小"   >
          <a href="#查看老年代存活对象大小" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#查看老年代存活对象大小"></a> 查看老年代存活对象大小</h4>
      
<p>为了快速看数据，我们使用了方式2，通过命令 <code>jmap -histo:live pid</code> 产生几次Full GC，Full GC之后，使用的 <code>jmap -heap</code> 来看的当前的堆内存情况。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap pid</span><br></pre></td></tr></table></div></figure>
<p>观察老年代存活对象大小：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025095004147.png" alt="image-20211025095004147" /></p>
<p>可以看到存活对象占用内存空间大概13.36M，老年代的内存占用为683M左右，这说明大量的老年代空间都是冗余的，这无疑会降低每次GC时的耗时。 按照整个堆大小是老年代 Full GC 之后剩余内存大小的3 - 4倍计算的话，设置堆内存情况如下：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx &#x3D; 14 * 3 &#x3D; 42M  至  14 * 4 &#x3D; 56M 之间</span><br></pre></td></tr></table></div></figure>

        <h3 id="优化配置修改堆内存大小"   >
          <a href="#优化配置修改堆内存大小" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优化配置修改堆内存大小"></a> 优化配置：修改堆内存大小</h3>
      
<p>我们修改堆内存状态如下：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:MetaspaceSize&#x3D;64m -Xss512K </span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;heap&#x2F;heapdump.hprof </span><br><span class="line">-XX:SurvivorRatio&#x3D;8  -XX:+PrintGCDateStamps  </span><br><span class="line">-Xms60M  -Xmx60M -Xloggc:log&#x2F;gc-oom.log</span><br></pre></td></tr></table></div></figure>
<p>修改完之后，再次进行压测后查看一下GC状态：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025095401459.png" alt="image-20211025095401459" /></p>
<ul>
<li>YGC平均耗时： 0.195s * 1000 / 68 = 2.87ms</li>
<li>FGC未产生</li>
</ul>
<p>对比优化前后的GC日志，可以看出：</p>
<ul>
<li>GC频率比优化前要多了一些，这是因为堆内存空间变小了</li>
<li>但是YGC的平均耗时却明显减少</li>
<li>同时依然未产生Full GC</li>
</ul>
<p>所以我们内存设置为60M也是比较合理的，相对之前节省了很大一块内存空间，并且平均YGC也较小。</p>
<p>依然手动触发Full GC，查看堆内存结构：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025095747754.png" alt="image-20211025095747754" /></p>
<p>可以看到还有很多冗余空间，不会导致Full GC</p>

        <h3 id="结论"   >
          <a href="#结论" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#结论"></a> 结论</h3>
      
<p>在内存相对紧张的情况下，可以按照上述的方式来进行内存的调优， 找到一个在GC频率和GC耗时上都可接受的一个内存设置，可以用较小的内存满足当前的服务需要。</p>
<p>但当内存相对宽裕的时候，可以相对给服务多增加一点内存，可以减少GC的频率，GC的耗时相应会增加一些。 一般要求低延时的可以考虑多设置一点内存， 对延时要求不高的，可以按照上述方式设置较小内存。</p>
<p>如果在垃圾回收日志中观察到<code>OutOfMemoryError</code>，尝试把Java堆的大小扩大到物理内存的80%~90%。尤其需要注意的是堆空间导致的<code>OutOfMemoryError</code>以及一定要增加空间。</p>
<ul>
<li>比如说，增加<code>-Xms</code>和<code>-Xmx</code>的值来解决Old代的<code>OutOfMemoryError</code></li>
<li>增加<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>来解决Metaspace引起的<code>OutOfMemoryError</code>（jdk8之后）</li>
</ul>
<p>记住一点，Java堆能够使用的容量受限于硬件以及是否使用64位的JVM。在扩大了Java堆的大小之后，再检查垃圾回收日志，直到没有<code>OutOfMemoryError</code>为止。如果应用运行在稳定状态下没有<code>OutOfMemoryError</code>就可以进入下一步了：计算活动对象的大小。</p>

        <h3 id="补充问题你会估算-gc-频率吗"   >
          <a href="#补充问题你会估算-gc-频率吗" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#补充问题你会估算-gc-频率吗"></a> 补充问题：你会估算 GC 频率吗？</h3>
      
<p>正常情况我们应该根据我们的系统来进行一个内存的估算，这个我们可以在测试环境进行测试，最开始可以将内存设置的大一些，比如4G这样，当然这也可以根据业务系统估算来的。</p>
<p>比如从数据库获取一条数据占用128个字节，需要获取1000条数据，那么一次读取到内存的大小就是（128 B/1024 Kb/1024M）* 1000 = 0.122M ，那么我们程序可能需要并发读取，比如每秒读取100次，那么内存占用就是0.122 * 100 = 12.2M  ，如果堆内存设置1个G，那么年轻代大小大约就是333M，那么333M * 80% / 12.2M  =21.84s ，也就是说我们的程序几乎每分钟进行两到三次youngGC。这样可以让我们对系统有一个大致的估算。</p>
<ul>
<li>0.122M * 100 = 12.2M /秒  —Eden区</li>
<li>1024M * 1/3 * 80% = 273M</li>
<li>273 / 12.2M = 22.38s —&gt; YGC  每分钟2-3次YGC</li>
</ul>

        <h3 id="特殊问题新生代与老年代的比例"   >
          <a href="#特殊问题新生代与老年代的比例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#特殊问题新生代与老年代的比例"></a> 特殊问题：新生代与老年代的比例</h3>
      

        <h4 id="参数设置"   >
          <a href="#参数设置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数设置"></a> 参数设置</h4>
      
<p>JVM 参数设置为：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails   -XX:+PrintGCDateStamps  </span><br><span class="line">-Xms300M  -Xmx300M -Xloggc:log&#x2F;gc.log</span><br></pre></td></tr></table></div></figure>
<p>新生代 ( Young ) 与老年代 ( Old ) 的比例为 1:2。所以，内存分配应该是新生代100M，老年代 200M。我们可以先用命令查看一下堆内存分配是怎么样的：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看进程ID</span><br><span class="line">jps -l</span><br><span class="line"></span><br><span class="line"># 查看对应的进程ID的堆内存分配</span><br><span class="line">jmap -heap 3725</span><br></pre></td></tr></table></div></figure>
<p>结果看到：虽然默认配置的SurvivorRatio= 8，但是内存分配却不是8:1:1，这是为什么呢？</p>

        <h4 id="adaptivesizepolicy-参数"   >
          <a href="#adaptivesizepolicy-参数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#adaptivesizepolicy-参数"></a> AdaptiveSizePolicy 参数</h4>
      
<p>这是因为JDK 1.8 默认使用 Parallel 垃圾回收器，<strong>该垃圾回收器默认启动了 AdaptiveSizePolicy</strong>（可以选择关闭该参数），会根据GC的情况自动计算计算 Eden、From 和 To 区的大小；所以这是由于JDK 1.8的自适应大小策略导致的，除此之外，我们下面观察GC日志发现有很多类似这样的FULL GC（Ergonomics），也是一样的原因。</p>
<p>我们可以在JVM参数中配置开启和关闭该配置：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 开启：</span><br><span class="line">-XX:+UseAdaptiveSizePolicy</span><br><span class="line"></span><br><span class="line"># 关闭</span><br><span class="line">-XX:-UseAdaptiveSizePolicy</span><br></pre></td></tr></table></div></figure>
<p>注意事项：</p>
<ul>
<li>在 JDK 1.8 中，如果使用 <strong>CMS</strong>，无论 <code>UseAdaptiveSizePolicy</code> 如何设置，都会将 <code>UseAdaptiveSizePolicy</code> 设置为 false；不过不同版本的JDK存在差异；</li>
<li><code>UseAdaptiveSizePolicy</code>不要和<code>SurvivorRatio</code>参数显示设置搭配使用，一起使用会导致参数失效；</li>
<li>由于<code>UseAdaptiveSizePolicy</code>会动态调整 Eden、Survivor 的大小，有些情况存在Survivor被自动调为很小，比如十几MB甚至几MB的可能，这个时候YGC回收掉Eden区后，还存活的对象进入Survivor 装不下，就会直接晋升到老年代，导致老年代占用空间逐渐增加，从而触发FULL GC，如果一次FULL GC的耗时很长（比如到达几百毫秒），那么在要求高响应的系统就是不可取的。</li>
</ul>
<blockquote>
<p>对于面向外部的<strong>大流量</strong>、<strong>低延迟</strong>系统，不建议启用此参数，因为动态调整很可能降低系统的延迟性。</p>
</blockquote>
<p>如果不想动态调整内存大小，以下是解决方案：</p>
<ul>
<li>保持使用 UseParallelGC，显式设置 <code>-XX:SurvivorRatio=8</code>。</li>
<li>使用 CMS 垃圾回收器。CMS 默认关闭 <code>AdaptiveSizePolicy</code>。配置参数 <code>-XX:+UseConcMarkSweepGC</code></li>
</ul>

        <h2 id="调优案例四cpu-占用很高排查方案"   >
          <a href="#调优案例四cpu-占用很高排查方案" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调优案例四cpu-占用很高排查方案"></a> 调优案例四：CPU 占用很高排查方案</h2>
      

        <h3 id="案例模拟-5"   >
          <a href="#案例模拟-5" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#案例模拟-5"></a> 案例模拟</h3>
      
<p>死锁案例</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JstackDeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须有两个可以被加锁的对象才能产生死锁，只有一个不会产生死锁问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> JstackDeadLockDemo().testDeadlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testDeadlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; calLock_Obj1_First());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; calLock_Obj2_First());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先synchronized  obj1，再synchronized  obj2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calLock_Obj1_First</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">            sleep();</span><br><span class="line">            System.out.println(<span class="string">&quot;已经拿到obj1的对象锁，接下来等待obj2的对象锁&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">                sleep();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先synchronized  obj2，再synchronized  obj1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calLock_Obj2_First</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">            sleep();</span><br><span class="line">            System.out.println(<span class="string">&quot;已经拿到obj2的对象锁，接下来等待obj1的对象锁&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">                sleep();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了便于让两个线程分别锁住其中一个对象，</span></span><br><span class="line"><span class="comment">     * 一个线程锁住obj1，然后一直等待obj2，</span></span><br><span class="line"><span class="comment">     * 另一个线程锁住obj2，然后一直等待obj1，</span></span><br><span class="line"><span class="comment">     * 然后就是一直等待，死锁产生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="问题呈现"   >
          <a href="#问题呈现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题呈现"></a> 问题呈现</h3>
      
<p>将上述代码运行在Linux服务器上：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025143122524.png" alt="image-20211025143122524" /></p>
<p>可以看到，程序依然处于运行状态。现在我们知道是线程死锁造成的问题。</p>

        <h3 id="问题分析"   >
          <a href="#问题分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h3>
      
<p>那么如果是生产环境的话，是怎么样才能发现目前程序有问题呢？我们可以推导一下，如果线程死锁，那么线程一直在占用CPU，这样就会导致CPU一直处于一个比较高的占用率。所示我们解决问题的思路应该是：</p>
<ul>
<li>首先查看java进程ID</li>
<li>根据进程 ID 检查当前使用<strong>异常线程</strong>的pid</li>
<li>把线程pid变为16进制如 31695 -&gt; 7bcf  然后得到 0x7bcf</li>
<li><code>jstack pid | grep -A20 0x7bcf</code>  得到相关进程的代码 （鉴于我们当前代码量比较小，线程也比较少，所以我们就把所有的信息全部导出来）</li>
</ul>
<blockquote>
<p>-A20：after 20，显示目标行后的20行内容</p>
</blockquote>
<p>接下来是我们的实现上面逻辑的步骤，如下所示：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有java进程 ID</span><br><span class="line">jps -l</span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025143250556.png" alt="image-20211025143250556" /></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 根据进程 ID 检查当前使用异常线程的pid</span><br><span class="line">top -Hp 1456</span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025143305762.png" alt="image-20211025143305762" /></p>
<p>从上图可以看出来，当前占用cpu比较高的线程 ID 是1465。把线程 PID 转换为16进制为：0x5b9</p>
<p>最后我们把线程信息打印出来：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025143339575.png" alt="image-20211025143339575" /></p>
<p>所有的准备工作已经完成，我们接下来分析日志中的信息，来定位问题出在哪里。</p>
<p>打开<code>jstack.log</code>文件  查找一下刚刚我们转换完的16进制ID是否存在：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025143359293.png" alt="image-20211025143359293" /></p>
<p>jstack命令生成的thread dump信息包含了JVM中所有存活的线程，里面确实是存在我们定位到的线程 ID ，在thread dump中每个线程都有一个nid，在nid=0x5b9的线程调用栈中，我们发现两个线程在互相等待对方释放资源</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025143413295.png" alt="image-20211025143413295" /></p>
<p>到此就可以检查对应的代码是否有问题，也就定位到我们的死锁问题。</p>

        <h3 id="解决方案"   >
          <a href="#解决方案" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h3>
      
<ul>
<li>调整锁的顺序，保持一致</li>
<li>或者采用<strong>定时锁</strong>，一段时间后，如果还不能获取到锁就释放自身持有的所有锁。</li>
</ul>

        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
      
<ul>
<li><code>ps aux | grep java</code>  查看到当前java进程使用cpu、内存、磁盘的情况获取使用量异常的进程</li>
<li><code>top -Hp pid</code>  检查当前使用异常线程的pid</li>
<li>把线程pid变为16进制如 31695 -&gt; 7bcf  然后得到0x7bcf</li>
<li><code>jstack pid | grep -A20 0x7bcf</code>  得到相关进程的代码</li>
</ul>

        <h2 id="调优案例五g1-并发标记线程数对性能的影响"   >
          <a href="#调优案例五g1-并发标记线程数对性能的影响" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调优案例五g1-并发标记线程数对性能的影响"></a> 调优案例五：G1 并发标记线程数对性能的影响</h2>
      

        <h3 id="配置信息"   >
          <a href="#配置信息" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#配置信息"></a> 配置信息</h3>
      
<p>硬件配置：8核 Linux</p>
<p>JVM参数设置：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+UseG1GC&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xms30m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xmx30m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+PrintGCDetails&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:MetaspaceSize&#x3D;64m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+PrintGCDateStamps&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xloggc:&#x2F;opt&#x2F;tomcat8.5&#x2F;logs&#x2F;gc.log&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:ConcGCThreads&#x3D;1&quot;</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>说明：最后一个参数可以在使用G1 GC测试初始并发GCThreads之后再加上。并且初始化内存和最大内存调整小一些，目的发生 FullGC，关注GC时间。</p>
</blockquote>
<p>关注点是：GC次数，GC时间，以及Jmeter的平均响应时间。</p>

        <h3 id="初始状态"   >
          <a href="#初始状态" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#初始状态"></a> 初始状态</h3>
      
<p>1、启动Tomcat，查看进程默认的并发线程数：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag ConcGCThreads pid</span><br><span class="line">-XX:ConcGCThreads&#x3D;1</span><br></pre></td></tr></table></div></figure>
<p>没有配置的情况下：并发标记线程数是1。</p>
<p>2、查看线程状态：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025144209223.png" alt="image-20211025144209223" /></p>
<ul>
<li>YGC：Young GC 次数是 1259 次</li>
<li>FGC：Full GC 次数是 6 次</li>
<li>GCT：GC 总时间是 5.556 s</li>
</ul>
<p>3、Jmeter 压测之后的GC状态：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025144315086.png" alt="image-20211025144315086" /></p>
<ul>
<li>YGC：Young GC 次数是 1600 次</li>
<li>FGC：Full GC 次数是 18 次</li>
<li>GCT：GC 总时间是 7.919 s</li>
</ul>
<p>由此我们可以计算出来压测过程中，发生的GC次数和GC时间差。</p>
<hr />
<p>整个压测过程中 GC 状态：</p>
<ul>
<li>YGC：Young GC 次数是 1600 - 1259 = 341 次</li>
<li>FGC：Full GC 次数是 18 - 6 = 12 次</li>
<li>GCT：GC 总时间是 7.919 - 5.556 = 2.363 s</li>
</ul>
<p>Jmeter压测结果，主要关注响应时间：</p>
<ul>
<li>95% 的请求响应时间为：16ms</li>
<li>99% 的请求响应时间为：28ms</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025144532203.png" alt="image-20211025144532203" /></p>
<hr />

        <h3 id="优化之后"   >
          <a href="#优化之后" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优化之后"></a> 优化之后</h3>
      
<p>增加并发线程配置（建议设置为CPU核数的1/4，太大也没有意义，反而抢占了并发用户线程）：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:ConcGCThreads&#x3D;2&quot;</span><br></pre></td></tr></table></div></figure>
<p>1、Tomcat启动之后的初始化GC状态：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025144843498.png" alt="image-20211025144843498" /></p>
<ul>
<li>YGC：Young GC 次数是 1134 次</li>
<li>FGC：Full GC 次数是 5 次</li>
<li>GCT：GC 总时间是 5.234 s</li>
</ul>
<p>2、Jmeter 压测之后的GC状态：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025144930791.png" alt="image-20211025144930791" /></p>
<ul>
<li>YGC：Young GC 次数是 1347 次</li>
<li>FGC：Full GC 次数是 16 次</li>
<li>GCT：GC 总时间是 7.149 s</li>
</ul>
<p>由此我们可以计算出来压测过程中，发生的GC次数和GC时间差</p>
<hr />
<p>压测过程GC状态：</p>
<ul>
<li>YGC：Young GC 次数是 1347 - 1134 = 213 次</li>
<li>FGC：Full GC 次数是 16 - 5 = 13 次</li>
<li><strong>GCT：GC 总时间是 7.149 - 5.234 = 1.915 s</strong></li>
</ul>
<p>对比优化后的GCT时间，发现比单线程时时间更短。这说明增大并发标记线程数，使得GC时间降低了。</p>
<p>Jmeter压测结果，主要关注响应时间：</p>
<ul>
<li>95%的请求响应时间为：15ms</li>
<li>99%的请求响应时间为：22ms</li>
</ul>
<p>请求响应时间确实比优化前单线程更低了。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025145515800.png" alt="image-20211025145515800" /></p>
<hr />

        <h3 id="总结-2"   >
          <a href="#总结-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3>
      
<p>配置完线程数之后，我们的请求的平均响应时间和GC时间都有一个明显的减少了，仅从效果上来看，我们这次的优化是有一定效果的。在工作中对于线上项目进行优化的时候，可以考虑到这方面的优化。</p>
<p>结论：<strong>增大并发标记线程数可以减小响应延迟时间</strong>。并且并发标记线程数设置太大也没更明显变化，反而因为抢占用户线程而导致。<strong>经验：并发标记线程数设置为CPU核数的 1/4 即可</strong>。</p>

        <h2 id="调优案例六调整垃圾回收器提高服务的吞吐量"   >
          <a href="#调优案例六调整垃圾回收器提高服务的吞吐量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调优案例六调整垃圾回收器提高服务的吞吐量"></a> 调优案例六：调整垃圾回收器提高服务的吞吐量</h2>
      

        <h3 id="初始配置"   >
          <a href="#初始配置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#初始配置"></a> 初始配置</h3>
      
<p>初始系统配置是单核CPU，我们看到日志，显示<code>DefNew</code>，说明我们用的是串行收集器：SerialGC</p>

        <h3 id="优化配置一"   >
          <a href="#优化配置一" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优化配置一"></a> 优化配置一</h3>
      
<p>那么就考虑切换一下并行收集器是否可以提高性能，增加配置如下：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xms60m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xmx60m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+UseParallelGC&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+PrintGCDetails&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:MetaspaceSize&#x3D;64m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+PrintGCDateStamps&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xloggc:&#x2F;opt&#x2F;tomcat8.5&#x2F;logs&#x2F;gc6.log&quot;</span><br></pre></td></tr></table></div></figure>
<p>进行压测后查看GC状态：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025151418354.png" alt="image-20211025151418354" /></p>
<p>发生3次Full GC，可以接受。</p>
<p>查看吞吐量：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025151446184.png" alt="image-20211025151446184" /></p>
<p>发现吞吐量并没有明显变化，我们究其原因，本身UseParallelGC是并行收集器，但是我们的服务器是单核，所以变化不大。</p>

        <h3 id="优化配置二"   >
          <a href="#优化配置二" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优化配置二"></a> 优化配置二</h3>
      
<p>接下来我们把服务器改为8核。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025151608283.png" alt="image-20211025151608283" /></p>
<p>8核状态下的性能表现如下，吞吐量大幅提升，甚至翻了一倍，这说明我们<strong>在多核机器上面采用并行收集器对于系统的吞吐量有一个显著的效果</strong>。</p>

        <h3 id="优化配置三"   >
          <a href="#优化配置三" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优化配置三"></a> 优化配置三</h3>
      
<p>接下来我们改为G1收集器看看效果</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+UseG1GC&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xms60m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xmx60m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+PrintGCDetails&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:MetaspaceSize&#x3D;64m&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -XX:+PrintGCDateStamps&quot;</span><br><span class="line">export CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS -Xloggc:&#x2F;opt&#x2F;tomcat8.5&#x2F;logs&#x2F;gc6.log&quot;</span><br></pre></td></tr></table></div></figure>
<p>查看GC状态：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025151657880.png" alt="image-20211025151657880" /></p>
<p>没有产生Full GC，效果较之前有提升。</p>
<p>查看压测效果，吞吐量也是比串行收集器效果更佳，而且没有了Full GC。此次优化较为成功。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/image-20211025151701558.png" alt="image-20211025151701558" /></p>

        <h3 id="总结-3"   >
          <a href="#总结-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h3>
      
<p>在多核CPU上，使用并行垃圾收集器的效果要好于串行垃圾收集器（体现在吞吐量上），并且G1更能提高服务的吞吐量。</p>

        <h2 id="调优案例七日均百万级订单交易系统如何设置-jvm-参数"   >
          <a href="#调优案例七日均百万级订单交易系统如何设置-jvm-参数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调优案例七日均百万级订单交易系统如何设置-jvm-参数"></a> 调优案例七：日均百万级订单交易系统如何设置 JVM 参数</h2>
      
<p>首先针对<strong>吞吐量</strong>进行分析：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E6%A1%88%E4%BE%8B7%EF%BC%9A%E6%97%A5%E5%9D%87%E7%99%BE%E4%B8%87%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9FJVM%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE.png" alt="" /></p>

        <h3 id="正常数据量情况"   >
          <a href="#正常数据量情况" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#正常数据量情况"></a> 正常数据量情况</h3>
      
<p>正常数据量情况下的分析步骤：</p>
<ul>
<li>首先计算一秒的订单量，从而估算出一秒有多少kb数据</li>
<li>将该数据量扩大20倍，以加上其他业务信息</li>
<li>计算出正常情况下每秒在伊甸园区创建2M对象，从而算出11分钟会让伊甸园区占满。</li>
</ul>
<p>十几分钟处于可以接受的范围。</p>
<p>我们可以继续优化：<strong>提高新生代所占比例</strong>。因为大量的订单都是临时数据，不需要将他们放到老年代，否则会增加Full GC。</p>

        <h3 id="业务暴增情况"   >
          <a href="#业务暴增情况" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#业务暴增情况"></a> 业务暴增情况</h3>
      
<p>业务量暴增时数据量可能增加几十倍，此时的处理方案：<strong>水平扩容</strong>，多增加一些服务器，分摊压力。</p>
<p>然而如果不扩容机器，则会有两种因素导致系统性能降低：</p>
<ul>
<li>订单数量暴增，新生代每秒新增对象增加到几十兆</li>
<li>同时，由于系统压力，一个订单几秒到几十秒才可生成，所以新生代的订单对象可能存活几秒到几十秒（生命周期变长）</li>
</ul>
<p>这两个因素共同导致每二三十秒就会发生一次Minor GC，导致过多对象进入老年代，直到Full GC，这无疑会增加系统的延迟响应时间，降低性能。</p>
<p>优化思路：<strong>增大年轻代的内存空间</strong>，尽量让大量对象都在新生代，减少Full GC</p>
<p>上述分析过程的几个影响因素：</p>
<ul>
<li>机器的配置、水平扩容的配置</li>
<li>每秒的订单数量</li>
<li>年轻代的内存大小</li>
</ul>

        <h3 id="总结-4"   >
          <a href="#总结-4" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结-4"></a> 总结</h3>
      
<p>针对日均百万级订单交易系统，可以进行的一些优化设置：</p>
<ul>
<li>水平扩容，增加服务器数量，增加硬件性能</li>
<li>提高JVM内存空间大小，尤其是新生代的大小，让大量临时订单对象停留在新生代，不让其进入老年代</li>
<li>使用 G1 垃圾回收器，增加服务吞吐量</li>
<li>增大 G1 GC 中并发GC线程数量，设置为系统CPU核数的1/4</li>
</ul>
<hr />
<p>扩展：问如何进行服务器配置只是第一个层面的问题！第二个层面问题：如果要求<strong>响应时间控制在100ms如何实现</strong>？</p>
<p>思路：使用G1垃圾回收器，通过参数 <code>-XX:MaxGCPauseMillis</code> 设置暂停时间（设置该参数无法保证高吞吐量）。同时在上线前进行压测，根据延迟时间对JVM参数进行调整，并且关注GC频率与吞吐量，通过反复压测调整参数的方式，控制响应时间。</p>
<hr />

        <h2 id="面试题"   >
          <a href="#面试题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#面试题"></a> 面试题</h2>
      
<p>1、12306遭遇春节大规模抢票如何支撑？</p>
<p>普通电商订单–&gt;  下单 --&gt; 订单系统（IO）减库存 —&gt; 等待用户付款</p>
<p>12306一种可能的模型：下单 --&gt; 减库存和订单（redis、kafka）同时异步进行 --&gt; 等付款<br />
但减库存最后还会把压力压到一台服务器上。如何？</p>
<p><strong>分布式本地库存</strong> + <strong>单独服务器做库存均衡</strong>！</p>
<p>2、有一个50万PV的资料类网站（从磁盘提取文档到内存）原服务器是32位的，1.5G的堆，用户反馈网站比较缓慢。因此公司决定升级，新的服务器为64位，16G的堆内存，结果用户反馈卡顿十分严重，反而比以前效率更低了！</p>
<ol>
<li>为什么原网站慢？频繁的GC，STW时间比较长，响应时间慢！</li>
<li>为什么会更卡顿？内存空间越大，FGC时间更长，延迟时间更长</li>
<li>怎么解决？</li>
</ol>
<blockquote>
<p>垃圾回收器：parallel GC ;  ParNew + CMS ; G1<br />
配置GC参数：-XX:MaxGCPauseMillis 、 -XX:ConcGCThreads<br />
根据log日志、dump文件分析，优化内存空间的比例<br />
jstat   jinfo  jstack  jmap</p>
</blockquote>
<p>3、系统CPU经常100%，如何调优？（面试高频）</p>
<p>CPU100%的话，一定是有线程占用系统资源。具体步骤前面已经讲过。</p>
<blockquote>
<p>注意： 工作中有时候是工作线程100%占用了CPU，还有可能是垃圾回收线程占用了100%</p>
</blockquote>
<p>4、系统内存飙高，如何查找问题？（面试高频）</p>
<ul>
<li>一方面：jmap -heap 、jstat 、… ; gc日志情况</li>
<li>另一方面：dump文件分析</li>
</ul>
<p>5、如何监控 JVM</p>
<blockquote>
<p>命令行工具<br />
图形化界面工具</p>
</blockquote>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://yuyun-zhao.github.io">yuyun zhao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://yuyun-zhao.github.io/2021/10/19/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/">http://yuyun-zhao.github.io/2021/10/19/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.github.io/tags/JVM/">JVM</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/10/21/%E3%80%90JUC%E3%80%91i%E5%8A%A0%E5%8A%A0%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">【JUC】i++ 源码详解</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/10/18/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/"><span class="paginator-prev__text">【JVM】JVM 监控及诊断工具</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84-8-%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-text">
           Java 内存泄露的 8 种情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5"><span class="toc-text">
           内存泄漏的常见情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-text">
           静态集合类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">
           单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E6%8C%81%E6%9C%89%E5%A4%96%E9%83%A8%E7%B1%BB"><span class="toc-text">
           非静态内部类持有外部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E8%BF%9E%E6%8E%A5%E5%A6%82%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%92%8C-io-%E8%BF%9E%E6%8E%A5%E7%AD%89"><span class="toc-text">
           各种连接，如数据库连接、网络连接和 IO 连接等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8D%E5%90%88%E7%90%86%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">
           变量不合理的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-text">
           改变哈希值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">
           缓存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E5%92%8C%E5%85%B6%E4%BB%96%E5%9B%9E%E8%B0%83"><span class="toc-text">
           监听器和其他回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">
           内存泄露案例分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oom-%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">
           OOM 出现的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oom-%E6%A1%88%E4%BE%8B%E4%B8%80%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="toc-text">
           OOM 案例一：堆溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%A8%A1%E6%8B%9F"><span class="toc-text">
           案例模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">
           原因及解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvisual-vm-%E6%8E%92%E6%9F%A5"><span class="toc-text">
           JVisual VM 排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mat-%E6%8E%92%E6%9F%A5"><span class="toc-text">
           MAT 排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gceasy-%E6%9F%A5%E7%9C%8B"><span class="toc-text">
           GCeasy 查看</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oom-%E6%A1%88%E4%BE%8B%E4%BA%8C%E5%85%83%E7%A9%BA%E9%97%B4%E6%BA%A2%E5%87%BA"><span class="toc-text">
           OOM 案例二：元空间溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%A8%A1%E6%8B%9F-2"><span class="toc-text">
           案例模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="toc-text">
           原因及解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9F%A5%E7%9C%8B-gc-%E6%83%85%E5%86%B5"><span class="toc-text">
           命令行查看 GC 情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvisual-vm-%E6%8E%92%E6%9F%A5-2"><span class="toc-text">
           JVisual VM 排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mat-%E6%8E%92%E6%9F%A5-2"><span class="toc-text">
           MAT 排查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oom-%E6%A1%88%E4%BE%8B%E4%B8%89gc-overhead-limit-exceeded"><span class="toc-text">
           OOM 案例三：GC overhead limit exceeded</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%A8%A1%E6%8B%9F-3"><span class="toc-text">
           案例模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">
           原因与解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvisual-vm-%E6%8E%92%E6%9F%A5-3"><span class="toc-text">
           JVisual VM 排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mat-%E6%8E%92%E6%9F%A5-3"><span class="toc-text">
           MAT 排查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oom-%E6%A1%88%E4%BE%8B%E5%9B%9B%E7%BA%BF%E7%A8%8B%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-text">
           OOM 案例四：线程栈溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%A8%A1%E6%8B%9F-4"><span class="toc-text">
           案例模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-text">
           原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">
           补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm-%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0"><span class="toc-text">
           JVM 调优概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B0%83%E4%BC%98"><span class="toc-text">
           为什么要调优？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E7%9A%84%E5%A4%A7%E6%96%B9%E5%90%91"><span class="toc-text">
           调优的大方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E7%9B%91%E6%8E%A7%E7%9A%84%E4%BE%9D%E6%8D%AE"><span class="toc-text">
           调优监控的依据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">
           性能优化的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%E6%B5%8B%E8%AF%95%E6%8C%87%E6%A0%87"><span class="toc-text">
           性能评价&#x2F;测试指标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E4%B8%80%E8%B0%83%E6%95%B4%E5%A0%86%E5%A4%A7%E5%B0%8F%E6%8F%90%E5%8D%87%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-text">
           调优案例一：调整堆大小提升服务的吞吐量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E8%BE%83%E5%B0%8F"><span class="toc-text">
           初始配置：堆内存较小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A2%9E%E5%A4%A7"><span class="toc-text">
           优化配置：堆内存增大</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E4%BA%8C%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">
           调优案例二：逃逸分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%AE%80%E4%BB%8B"><span class="toc-text">
           逃逸分析简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%A4%BA%E4%BE%8B"><span class="toc-text">
           逃逸分析示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%B8%80%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="toc-text">
           优化一：栈上分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">
           开启逃逸分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">
           关闭逃逸分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%BA%8C%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-text">
           优化二：标量替换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-text">
           开启标量替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-text">
           关闭标量替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">
           对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%B8%89%E5%90%8C%E6%AD%A5%E6%B6%88%E9%99%A4%E7%9C%81%E7%95%A5"><span class="toc-text">
           优化三：同步消除（省略）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%B0%8F%E7%BB%93"><span class="toc-text">
           逃逸分析小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E4%B8%89%E5%90%88%E7%90%86%E9%85%8D%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-text">
           调优案例三：合理配置堆内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E9%85%8D%E7%BD%AE"><span class="toc-text">
           官方推荐配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E8%80%81%E5%B9%B4%E4%BB%A3%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">
           如何计算老年代存活对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E6%8E%A8%E8%8D%90"><span class="toc-text">
           方式一：查看日志（推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%E5%BC%BA%E5%88%B6%E8%A7%A6%E5%8F%91fullgc"><span class="toc-text">
           方式二：强制触发FullGC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-text">
           案例演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90"><span class="toc-text">
           数据分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%83%85%E5%86%B5"><span class="toc-text">
           初始情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%80%81%E5%B9%B4%E4%BB%A3%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F"><span class="toc-text">
           查看老年代存活对象大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="toc-text">
           优化配置：修改堆内存大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">
           结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E9%97%AE%E9%A2%98%E4%BD%A0%E4%BC%9A%E4%BC%B0%E7%AE%97-gc-%E9%A2%91%E7%8E%87%E5%90%97"><span class="toc-text">
           补充问题：你会估算 GC 频率吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E9%97%AE%E9%A2%98%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E6%AF%94%E4%BE%8B"><span class="toc-text">
           特殊问题：新生代与老年代的比例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-text">
           参数设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#adaptivesizepolicy-%E5%8F%82%E6%95%B0"><span class="toc-text">
           AdaptiveSizePolicy 参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%9B%9Bcpu-%E5%8D%A0%E7%94%A8%E5%BE%88%E9%AB%98%E6%8E%92%E6%9F%A5%E6%96%B9%E6%A1%88"><span class="toc-text">
           调优案例四：CPU 占用很高排查方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%A8%A1%E6%8B%9F-5"><span class="toc-text">
           案例模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%91%88%E7%8E%B0"><span class="toc-text">
           问题呈现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">
           问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">
           解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">
           总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E4%BA%94g1-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">
           调优案例五：G1 并发标记线程数对性能的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-text">
           配置信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81"><span class="toc-text">
           初始状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%8E"><span class="toc-text">
           优化之后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">
           总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%85%AD%E8%B0%83%E6%95%B4%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-text">
           调优案例六：调整垃圾回收器提高服务的吞吐量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE"><span class="toc-text">
           初始配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E4%B8%80"><span class="toc-text">
           优化配置一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E4%BA%8C"><span class="toc-text">
           优化配置二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E4%B8%89"><span class="toc-text">
           优化配置三</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">
           总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E4%B8%83%E6%97%A5%E5%9D%87%E7%99%BE%E4%B8%87%E7%BA%A7%E8%AE%A2%E5%8D%95%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE-jvm-%E5%8F%82%E6%95%B0"><span class="toc-text">
           调优案例七：日均百万级订单交易系统如何设置 JVM 参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E6%95%B0%E6%8D%AE%E9%87%8F%E6%83%85%E5%86%B5"><span class="toc-text">
           正常数据量情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%9A%B4%E5%A2%9E%E6%83%85%E5%86%B5"><span class="toc-text">
           业务暴增情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">
           总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">
           面试题</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/author.png" alt="avatar"></div><p class="sidebar-ov-author__text">no code no life</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YUYUN-ZHAO" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="zyy1024462136" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1024462136" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:im.yuyunzhao@gmail.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gmail</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">115</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">35</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">35</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>yuyun zhao</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.xml"></script></body></html>