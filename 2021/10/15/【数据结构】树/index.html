<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="二叉树的遍历        二叉树的前序、中序、后序遍历本质上就是将打印语句放到 “第一次来到该节点、第二次回到该节点、第三次回到该节点” 的位置。 1234567891011121314151617181920212223242526public static void traversal(Node head) &amp;#123;    if (head &#x3D;&#x3D; null) &amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="【数据结构】树">
<meta property="og:url" content="http://yuyun-zhao.github.io/2021/10/15/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/index.html">
<meta property="og:site_name" content="yuyun zhao&#39;s blog">
<meta property="og:description" content="二叉树的遍历        二叉树的前序、中序、后序遍历本质上就是将打印语句放到 “第一次来到该节点、第二次回到该节点、第三次回到该节点” 的位置。 1234567891011121314151617181920212223242526public static void traversal(Node head) &amp;#123;    if (head &#x3D;&#x3D; null) &amp;#">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211206145926473.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211218190011688.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211202163945003.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211202163956413.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211202164003355.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211206135410908.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211206135831549.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/%E5%B9%BB%E7%81%AF%E7%89%871-1634725344405.PNG">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/%E5%B9%BB%E7%81%AF%E7%89%872.PNG">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211026100602967.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211027144627113.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/20171113195048032">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/251730074203156.jpg">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211223101721124.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211206145926473.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211214214247676.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/%E5%B9%BB%E7%81%AF%E7%89%871-1634726617676.PNG">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/ebf894b723530a89cc9a1fe099f36c57c584d4987b080f625b33e228c0a02bec-Picture1.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211202111942469.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/27d9f65b79ae4982fb58835d468c2a23ec2ac399ba5f38138f49538537264d03-Picture1.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211210110655646.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211218190011688.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211218190051540.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211210212721807.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/recover1.jpg">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211203151542500.png">
<meta property="article:published_time" content="2021-10-15T05:06:33.000Z">
<meta property="article:modified_time" content="2022-01-09T02:20:16.528Z">
<meta property="article:author" content="yuyun zhao">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yuyun-zhao.github.io/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211206145926473.png"><title>【数据结构】树 | yuyun zhao's blog</title><link ref="canonical" href="http://yuyun-zhao.github.io/2021/10/15/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">文章</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">yuyun zhao's blog</div><div class="header-banner-info__subtitle">no code no life</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">【数据结构】树</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-01-09</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">26.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">181分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h2 id="二叉树的遍历"   >
          <a href="#二叉树的遍历" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二叉树的遍历"></a> 二叉树的遍历</h2>
      
<p>二叉树的前序、中序、后序遍历本质上就是将打印语句放到 “第一次来到该节点、第二次回到该节点、第三次回到该节点” 的位置。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------</span></span><br><span class="line">    <span class="comment">// 第一次来到该节点, 对应前序</span></span><br><span class="line">    <span class="comment">// 访问其左右子树前, 就会来到这里</span></span><br><span class="line">    <span class="comment">// --------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    traversal(head.left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------</span></span><br><span class="line">    <span class="comment">// 第二次回到该节点, 对应中序</span></span><br><span class="line">    <span class="comment">// 访问完其整个左子树后, 才会来到这里</span></span><br><span class="line">    <span class="comment">// --------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    traversal(head.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------</span></span><br><span class="line">    <span class="comment">// 第三次回到该节点, 对应后序</span></span><br><span class="line">    <span class="comment">// 访问完其整个右子树后, 才会来到这里</span></span><br><span class="line">    <span class="comment">// --------------------------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="前序遍历"   >
          <a href="#前序遍历" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#前序遍历"></a> 前序遍历</h3>
      
<p>前序遍历：头 -&gt; 左 -&gt; 右</p>

        <h4 id="递归方式"   >
          <a href="#递归方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#递归方式"></a> 递归方式</h4>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="非递归方式借助一个栈结构"   >
          <a href="#非递归方式借助一个栈结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#非递归方式借助一个栈结构"></a> 非递归方式：借助一个栈结构</h4>
      
<blockquote>
<p>后序遍历的非递归方式需要借助两个栈，步骤和前序遍历相似，只不过将一个栈中的元素压入到另一个栈后再统一出栈打印</p>
</blockquote>
<p>非递归的前序遍历，需要使用一个栈结构。</p>
<p>先将根节点入栈，然后不断循环，按照 “弹栈打印 -&gt; 右孩子入栈 -&gt; 左孩子入栈” 的顺序遍历，即可实现前序遍历。</p>
<p>因为每次都将右孩子先入栈，同时弹出左孩子时就立刻再次压入其右孩子和左孩子，所以某个节点的右子树会堆积在栈底，一直到其左子树都弹栈后才会再遍历，从而达到了先序遍历的效果。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    1. 首先, 树的根结点先入栈,</span></span><br><span class="line"><span class="comment">//       while (栈不空) &#123;</span></span><br><span class="line"><span class="comment">//    2.    弹出栈顶节点并打印</span></span><br><span class="line"><span class="comment">//    3.    先将右孩子入栈, 再将左孩子入栈 (注意先后顺序要先右再左, 这样弹栈时就会先弹左再弹右)</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">// 因为每次都将右孩子先入栈，同时弹出左孩子时就立刻再次压入其右孩子和左孩子，所以某个节点的右子树</span></span><br><span class="line"><span class="comment">// 会堆积在栈底，一直到其左子树都弹栈后才会再遍历，从而达到了先序遍历的效果</span></span><br><span class="line"><span class="comment">// 总结: 先弹顶 -&gt; 压左 -&gt; 压右 -&gt; 弹栈 -&gt; 压左 -&gt; 压右</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历的效果: 先把根结点的左子树上的所有节点遍历后才会遍历右子树</span></span><br><span class="line"><span class="comment">//                并且每个子树都遵循该效果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderUnRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(head);</span><br><span class="line">        Node curr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            curr = stack.pop();</span><br><span class="line">            System.out.print(curr.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(curr.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(curr.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<span id="more"></span>

        <h3 id="中序遍历"   >
          <a href="#中序遍历" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h3>
      
<p>中序遍历：左 -&gt; 头 -&gt; 右</p>

        <h4 id="递归方式-2"   >
          <a href="#递归方式-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#递归方式-2"></a> 递归方式</h4>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderRecur(head.left);</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    inOrderRecur(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="非递归方式借助一个栈结构-2"   >
          <a href="#非递归方式借助一个栈结构-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#非递归方式借助一个栈结构-2"></a> 非递归方式：借助一个栈结构</h4>
      
<p>思路：把整棵树<strong>按照左边界进行分解</strong>，同时右孩子节点也按照左边界分解，将右子树的节点也依次左孩子节点入栈。即每打印一个节点后就<strong>把右子树的节点也依次左孩子节点入栈</strong>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直将当前节点的所有左孩子都入栈，直到当前节点没有了左孩子，</span></span><br><span class="line"><span class="comment">//则将当前节点弹栈并打印，同时将当前节点的右孩子节点的所有左孩子节点都入栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历到某个叶子节点时, 其左右孩子节点都是 null</span></span><br><span class="line"><span class="comment">//  先 if 发现是 null , 进入 else 弹出并打印该叶子节点，然后再获取右孩子, 又是 null</span></span><br><span class="line"><span class="comment">//  再进一次  while  发现还是走 else，弹出了其父节点, 然后打印</span></span><br><span class="line"><span class="comment">// 所以连起来看就是 左 -&gt; 头 -&gt; 右</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为左边界是按照先入头再入左的顺序, 因此弹栈时就是先左再头</span></span><br><span class="line"><span class="comment">// 每次都是先左再头, 然后再让其右子树进行先左再头, 周而复始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 思想: 把整棵树按照左边界进行分解, 同时右孩子节点也按照左边界分解,</span></span><br><span class="line"><span class="comment">// 将右子树的节点也依次左孩子节点入栈</span></span><br><span class="line"><span class="comment">// 左 -&gt; 头 -&gt; 右(左 -&gt; 头 -&gt; 右(左 -&gt; 头 -&gt; 右(...)))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderUnRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 注意: 一开始不需要入根结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意循环终止条件需要加上 head != null</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次循环到这里, 栈顶保存着当前 head 的父节点</span></span><br><span class="line">            <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 一直将当前节点入栈, 每次压栈后栈顶保存的都是父节点, 也就是 头</span></span><br><span class="line">                stack.push(head);</span><br><span class="line">                <span class="comment">// 注意是先压栈, 再指向左孩子, 这样在进入 else 时,</span></span><br><span class="line">                <span class="comment">// 栈顶节点保存的就是当前父节点, 从而在弹出栈顶节点后, 就可以获取到其右孩子</span></span><br><span class="line">                head = head.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 弹出当前栈顶节点, 引入入栈时是先入的左, 再入的头</span></span><br><span class="line">                <span class="comment">// 所以这里弹出时先弹出的是左, 然后才是头,</span></span><br><span class="line">                <span class="comment">// 接着将右子树进行分解, 再进行一次左边界的递归入栈</span></span><br><span class="line">                head = stack.pop();</span><br><span class="line">                System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="comment">// 一个节点弹出时, 再让其右子树进行一次左边界的递归入栈:</span></span><br><span class="line">                <span class="comment">// 令 head 指向当前节点的右孩子, 从而在接下来进入 if 判断后,</span></span><br><span class="line">                <span class="comment">// 将当前节点的右孩子(已经变为了head)的所有左孩子节点入 栈</span></span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="后序遍历"   >
          <a href="#后序遍历" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#后序遍历"></a> 后序遍历</h3>
      
<p>后序遍历：左 -&gt; 右 -&gt; 头</p>

        <h4 id="递归方式-3"   >
          <a href="#递归方式-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#递归方式-3"></a> 递归方式</h4>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    posOrderRecur(head.left);</span><br><span class="line">    posOrderRecur(head.right);</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="非递归方式借助两个栈结构"   >
          <a href="#非递归方式借助两个栈结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#非递归方式借助两个栈结构"></a> 非递归方式：借助两个栈结构</h4>
      
<blockquote>
<p>后序遍历的非递归方式需要借助两个栈，步骤和前序遍历相似，只不过将一个栈中的元素压入到另一个栈后再统一出栈打印。</p>
</blockquote>
<p>非递归的后序遍历，需要使用两个栈结构，另一个栈用于存储第一个栈弹出的节点</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先, 按照 先弹顶并压入栈2 -&gt; 压左 -&gt; 压右 的顺序执行</span></span><br><span class="line"><span class="comment">// 然后依次弹出栈2中的节点并打印, 这样第二个栈再弹出时打印的顺序就是 左右头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   (头在最后打印的原因时, 入第一个栈时, 在压当前节点的左右孩子节点前先将当前节点弹出并压到了栈2</span></span><br><span class="line"><span class="comment">//   然后弹其右孩子节点时就会存放到了当前节点的上面, 最后才是压入其左孩子节点</span></span><br><span class="line"><span class="comment">//   所以从栈2弹出时的顺序就是  左 -&gt; 右 -&gt; 头)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   流程:</span></span><br><span class="line"><span class="comment">//    1. 首先, 树的根结点先入栈,</span></span><br><span class="line"><span class="comment">//       while (栈1不空) &#123;</span></span><br><span class="line"><span class="comment">//    2.    弹出栈1的顶节点并压入栈2(不打印)</span></span><br><span class="line"><span class="comment">//    3.    先将左孩子入栈, 再将右孩子入栈 (注意先后顺序和前序相反)</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//    4. 依次弹出栈2的每个节点并打印</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderUnRecur1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node curr = head;</span><br><span class="line">        stack1.push(head);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">            curr = stack1.pop();</span><br><span class="line">            stack2.push(curr);</span><br><span class="line">            <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack1.push(curr.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack1.push(curr.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次弹出栈2的节点</span></span><br><span class="line">        <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">            System.out.print(stack2.pop().value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="前序-中序-后序遍历在数组中的体现"   >
          <a href="#前序-中序-后序遍历在数组中的体现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#前序-中序-后序遍历在数组中的体现"></a> 前序、中序、后序遍历在数组中的体现</h3>
      
<ul>
<li>知道<strong>前序</strong>遍历序列和<strong>中序</strong>遍历序列，可以唯一确定一颗二叉树</li>
<li>知道后序遍历序列和<strong>中序</strong>遍历序列，可以唯一确定一颗二叉树</li>
</ul>
<p>但是只知道后序和前序无法唯一确定一棵二叉树，因为<strong>需要中序序列中定位到根节点的位置</strong>才可以进行左右侧划分，否则不知道前序或后序序列中<strong>左右子树的划分边界</strong></p>
<p>根节点位置：</p>
<ul>
<li>前序遍历：在数组的<strong>第一个</strong>位置</li>
<li>中序遍历：在数组的<strong>中间某个</strong>位置（第一个位置为整棵树最左侧的节点）</li>
<li>后序遍历：在数组的<strong>最后一个</strong>位置</li>
</ul>
<p>左右子树的分布特点：</p>
<ul>
<li>前序遍历：根 -&gt; 左 -&gt; 右</li>
<li>中序遍历：左 -&gt; 根 -&gt; 右</li>
<li>后序遍历：左 -&gt; 右 -&gt; 根</li>
</ul>
<p>具体分布可见下图：</p>
<img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211206145926473.png" alt="image-20211206145926473"  />
<img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211218190011688.png" alt="image-20211218190011688"  />
<p>相关题目可见：<a href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">重建二叉树</a>与<a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97">二叉搜索树的后续遍历序列</a>。</p>

        <h3 id="层次遍历"   >
          <a href="#层次遍历" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#层次遍历"></a> 层次遍历</h3>
      
<p>层次遍历常用于和<strong>树的宽度</strong>相关或<strong>需要知道当前节点所在层信息</strong>的题目，例如求树的最大宽度，或者判断完全二叉树。</p>
<p><strong>层次遍历常常与队列一起组合出现</strong>，因为使用队列先进先出的特点才能保证做到层次遍历，如果是栈结构的先进后出，就无法做到层次遍历。</p>
<p>层次遍历的一个技巧，可以在进入每层后，首先获取队列中节点的个数，其就代表了当前层的节点数目，那么就可以在开启一个内层 while 循环，一次性遍历当前层的所有节点。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="comment">// 依次遍历当前层内所有节点</span></span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node curr = queue.poll();</span><br><span class="line">            System.out.println(curr.value);</span><br><span class="line">            <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(curr.left);</span><br><span class="line">            <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(curr.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="按照之字形进行层次遍历"   >
          <a href="#按照之字形进行层次遍历" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#按照之字形进行层次遍历"></a> 按照之字形进行层次遍历</h4>
      
<p>之字形遍历即要求奇数层从左往右打印，偶数层从右往左打印。要实现该功能，有三种思路：</p>
<ul>
<li>仍然采用传统的层次遍历，只不过在最后对偶数层集合进行<strong>逆序</strong>；或在偶数层添加元素时从后往前加入到结果集合 <code>LinkedList&lt;&gt;#addLast()</code> 中</li>
<li>使用<strong>两个栈结构</strong>。一个栈存储奇数层的节点，一个栈存储偶数层的节点
<ul>
<li>遍历奇数层时，向偶数栈中压入当前层的孩子；先左后右</li>
<li>遍历偶数层时，向奇数栈中压入当前层的孩子；先右后左</li>
</ul>
</li>
<li>使用<strong>一个双端队列</strong>结构。每次不止遍历两层，而是先遍历奇数层，再遍历偶数层
<ul>
<li>奇数层是从头出，从尾入；先左后右</li>
<li>偶数层是从尾出，从头入；先右后左</li>
<li>注意：出和入的方向肯定是相反的，不然就会导致刚入的，就要出了</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 两个栈，一个栈存储奇数层的，一个栈存储偶数层的</span></span><br><span class="line">    <span class="comment">// 遍历奇数层时，向偶数栈中压入当前层的孩子；先左后右</span></span><br><span class="line">    <span class="comment">// 遍历偶数层时，向奇数栈中压入当前层的孩子；先右后左</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 双端队列，每次不止遍历两层，而是先遍历奇数层，再遍历偶数层</span></span><br><span class="line">    <span class="comment">// 奇数层是从头出，从尾入；先左后右</span></span><br><span class="line">    <span class="comment">// 偶数层是从尾出，从头入；先右后左</span></span><br><span class="line">    <span class="comment">// 注意：出和入的方向肯定是相反的，不然就会导致刚入的，就要出了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> levelOrderDeque(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 双栈</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderTwoStack(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stackOdd = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stackEven = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stackOdd.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个栈分别存储奇数层和偶数层的元素</span></span><br><span class="line">    <span class="comment">// 如果同时为空，说明遍历完了</span></span><br><span class="line">    <span class="keyword">while</span> (!stackOdd.isEmpty() || !stackEven.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 刚来到新的一层时只会有一个栈不为空</span></span><br><span class="line">        <span class="keyword">if</span> (!stackOdd.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 如果奇数层栈不为空，则当前是奇数层</span></span><br><span class="line">            <span class="comment">// 奇数层先入左孩子，再入右孩子</span></span><br><span class="line">            <span class="keyword">while</span> (!stackOdd.isEmpty()) &#123;</span><br><span class="line">                root = stackOdd.pop();</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stackEven.push(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stackEven.push(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则当前就是偶数层</span></span><br><span class="line">            <span class="comment">// 偶数层先入右孩子，再入左孩子</span></span><br><span class="line">            <span class="keyword">while</span> (!stackEven.isEmpty()) &#123;</span><br><span class="line">                root = stackEven.pop();</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stackOdd.push(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stackOdd.push(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 双端队列</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderDeque(TreeNode root) &#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    queue.addFirst(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();    </span><br><span class="line">        <span class="comment">// 先遍历奇数层，然后紧接着判断是否还有偶数层，如果有就接着遍历</span></span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 奇：从头出，从尾入；先左后右</span></span><br><span class="line">            root = queue.removeFirst();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.addLast(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.addLast(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理过奇数层，立刻处理偶数层</span></span><br><span class="line">        <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            size = queue.size();</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();    </span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 偶：从尾出，从头入；先右后左</span></span><br><span class="line">                root = queue.removeLast();</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                <span class="comment">// 每次都是先右后左的顺序入队头，这样就会导致奇数层可以做到从左往右遍历</span></span><br><span class="line">                <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.addFirst(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.addFirst(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h3 id="morris-遍历"   >
          <a href="#morris-遍历" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#morris-遍历"></a> Morris 遍历</h3>
      

        <h4 id="实现流程"   >
          <a href="#实现流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#实现流程"></a> 实现流程</h4>
      
<p>假设来到当前节点 curr，开始时 curr 在头节点位置</p>
<ul>
<li>如果 curr 没有左孩子，则 curr 向右移动 <code>cur = cur.right</code>（这里会因为事先建立的线索而再次回到上层节点）</li>
<li>如果 curr 有左孩子，找到 curr 的左子树上的最右侧节点 <code>mostRight</code>：
<ul>
<li>如果 <code>mostRight</code> 的右指针指向空（说明是第一次到该节点，还没建立线索），让其指向 curr（<code>mostRight.right = curr</code>），此时建立了当前节点左子树最右节点与当前节点间的<strong>线索</strong>。然后 curr 向左移动 <code>curr = curr.left</code>，<strong>开始向左子树遍历</strong></li>
<li>如果 <code>mostRight</code> 的右指针指向 curr（说明是第二次到该节点，之前就建立过线索了），让其指向 null（取消线索），断开了之前建立的线索，恢复了最右节点的原始结构。然后 curr 向右移动 <code>cur = cur.right</code>。<strong>开始向右子树遍历</strong></li>
</ul>
</li>
<li>curr 为 null 时遍历停止</li>
</ul>
<p>上述流程可分为三个阶段：</p>
<ul>
<li><strong>线索化</strong>：第一次来到某节点 A，寻找其 mostRight 并赋值 <code>mostRight.right = A</code>。借助于该线索才能在访问过节点 A 的<strong>左子树的全部节点</strong>后再次回到节点 A。如果不线索化，访问了底层节点后就不能再回到节点 A 了。接着 <code>curr = curr.left</code>，即开始<strong>向左子树遍历</strong></li>
<li><strong>遍历左子树</strong>：A 完成线索化后，开始向左子树遍历。当遍历到刚才的 mostRight 时，将通过之前创建的<strong>线索</strong>进行回溯，重新回到 A：<code>curr = curr.right</code></li>
<li><strong>取消线索化</strong>：<strong>第二次</strong>回到节点 A 时，寻找其 mostRight 并赋值 <code>mostRight.right = null</code>。此时是第二次回到节点 A，其左子树上的全部节点都已经遍历完毕了，接着该向其<strong>右子树</strong>进行遍历了。因此 <code>curr = curr.right</code></li>
</ul>
<p>上述三个阶段的图示：</p>
<p><img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211202163945003.png" alt="image-20211202163945003" /></p>
<p><img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211202163956413.png" alt="image-20211202163956413" /></p>
<p><img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211202164003355.png" alt="image-20211202164003355" /></p>
<p>建立线索——消除线索的过程：</p>
<ul>
<li>开始时所有子树的最右节点的 right 都是 null，此时还没建立起线索</li>
<li>接着<strong>第一次</strong>来到某个节点 A 时，若其左子树的最右节点存在，则会<strong>建立该最右节点与当前节点的线索</strong>，具体方法是：<code>mostRight.right = A</code>。然后当前节点继续向左移动：<code>curr = A.left</code>。注意：这里建立的线索将会在后续遍历到 mostRight 节点时，执行 <code>curr = mostRight.right</code> 语句来再次回到节点 A</li>
<li>当 curr 在向左子树不断遍历的过程中来到刚才建立线索的最右节点 mostRight 时，会执行  <code>curr = mostRight.right</code> 语句重新回到其线索指向的祖先节点 A，从而做到了<strong>第二次</strong>回到节点 A</li>
<li>第二次回到节点 A 后，继续寻找其左子树上的最右节点 mostRight，然后取消线索化：<code>mostRight.right = null</code>，从而恢复其原始结构</li>
</ul>
<p><strong>线索化的目的</strong>：在访问了底层节点后，依旧能借助该线索再次回到上层的节点，从而继续向右侧迭代遍历。如果不线索化，访问了底层节点后就不能再回到上层节点了。</p>
<p>左子树上的线索化结果图示：</p>
<img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211206135410908.png" alt="image-20211206135410908" style="zoom:67%;" />

        <h4 id="算法复杂度"   >
          <a href="#算法复杂度" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#算法复杂度"></a> 算法复杂度</h4>
      
<p>没有左孩子的节点只会被遍历一次（因为找不到 mostRight，没有能回溯的线索）；有左孩子的节点会被遍历两次（第二次是通过线索回溯到的）：</p>
<ul>
<li>有左孩子，则该节点会被访问两次
<ul>
<li>第一次访问时，其<strong>左子树上的最右节点</strong>的右孩子为 null</li>
<li>第二次访问时，其<strong>左子树上的最右节点</strong>的右孩子为该节点</li>
</ul>
</li>
<li>没左孩子，则该节点只会被访问一次</li>
</ul>
<p>复杂度：</p>
<ul>
<li>时间复杂度：不同的节点寻找 mostRight 的路径是完全不重合的，因此时间复杂度并没有增加太多，最对是 O(2N)，也还是 O(N)。</li>
<li>空间复杂度：O(1)。全局只需要存储 curr 和 mostRight，也没有利用系统栈，不耗费额外空间。</li>
</ul>

        <h4 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
      
<p>传统递归的方式进行遍历时，是通过系统压栈的方式告诉我们当前节点是第几次被访问，每个节点会被访问三次；但 Morris 遍历并不是，其只能模拟：在左子树上转一圈后回到自身，不能在右子树上转一圈后回到自身（即无法第三次回到自身）。它是利用线索化的机制回到当前节点。</p>
<p>Morris 遍历的特点：可以选择是否要第二次回到当前节点（实现方式为通过当前节点左子树的底层节点的线索化，将right指针指向当前节点来实现）</p>
<p>借助于 Morris 遍历，可以实现出时间复杂度为 O(N)，空间复杂度为 O(1) 的前序、中序以及后序遍历。</p>
<p>Morris 遍历代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    TreeNode mostRight;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Morris 顺序打印位置:</span></span><br><span class="line">        System.out.print(curr.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 有两种情况会来到某个节点:</span></span><br><span class="line">        <span class="comment">// 1. 第一次来到当前节点, 通过 curr = curr.left 或 curr = curr.right 方式</span></span><br><span class="line">        <span class="comment">// 2. 第二次回到当前节点, 通过线索节点的 curr = curr.right 进行回溯</span></span><br><span class="line">        <span class="comment">// 只要某个节点有左孩子, 就能线索化, 从而就能第二次回到当前位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先尝试寻找左子树上的最右节点</span></span><br><span class="line">        mostRight = curr.left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前节点存在左子树, 则开始寻找其 mostRight</span></span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 一直寻找 curr 左子树上的最右节点, 可能有两种情况:</span></span><br><span class="line">            <span class="comment">// 1. mostRight.right == null, 则代表还未建立线索</span></span><br><span class="line">            <span class="comment">// 2. mostRight.right == curr, 则代表已经建立了线索</span></span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != curr) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1. mostRight.right == null, 则代表还未建立线索</span></span><br><span class="line">            <span class="comment">// 此时是第一次到达 mostRight 与节点 A, 需要建立二者的线索</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mostRight.right = curr;</span><br><span class="line">                <span class="comment">// ========================================================</span></span><br><span class="line">                <span class="comment">// 此时是节点 A 第一次找到 mostRight, 同时也是第一次访问节点 A</span></span><br><span class="line">                <span class="comment">// 因为只有在访问到节点 A 时, 才会去寻找其 mostRight</span></span><br><span class="line">                <span class="comment">// ========================================================</span></span><br><span class="line">                <span class="comment">// 在这里打印, 就能符合前序遍历中先打印头的要求</span></span><br><span class="line">                <span class="comment">// System.out.print(curr.value + &quot; &quot;);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 线索化后, curr 开始遍历左子树</span></span><br><span class="line">                curr = curr.left;</span><br><span class="line">                <span class="comment">// 进入下一次循环, 开始遍历左子树</span></span><br><span class="line">                <span class="comment">// 这里的 continue 非常重要，能够令当前节点 A 不经过下面的 curr = curr.right; 直接进入到其左子树上进行遍历</span></span><br><span class="line">                <span class="comment">// 这样就有效地做到了第一次到当前节点时不处理，第二次到当前节点时（在接下来的 else 里）处理，从而很好地实现了中序遍历</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 2. mostRight.right == curr, 则代表已经建立了线索</span></span><br><span class="line">                <span class="comment">// ========================================================</span></span><br><span class="line">                <span class="comment">// 此时为第二次到达 mostRight, 也是第二次到达之前访问过的节点 A</span></span><br><span class="line">                <span class="comment">// (通过 mostRight 回溯到了 A), 需要取消二者的线索</span></span><br><span class="line">                <span class="comment">// 此时是节点 A 第二次找到 mostRight, 同时也是第二次访问节点 A,</span></span><br><span class="line">                <span class="comment">// 因为只有在访问到节点 A 时, 才会去寻找其 mostRight</span></span><br><span class="line">                <span class="comment">// ========================================================</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 第二次到达节点 A 后, 就会走出这里, 到下面继续执行 curr = curr.right, 从而开始遍历右子树</span></span><br><span class="line">                <span class="comment">// 通过在下面增加 else 分支就可以控制第二次到达节点 A 时不打印，从而实现中序遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两种情况:</span></span><br><span class="line">        <span class="comment">// 1. 到达某个节点的 mostRight, 通过其 right 线索回溯到其祖先节点</span></span><br><span class="line">        <span class="comment">// 2. 第二次回到祖先节点, 代表左子树遍历完毕了, 开始遍历右子树</span></span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>注意代码中，第一次和第二次来到节点 A 的时机，这对于修改成前序、中序以及后序遍历来说非常重要。</p>
<p>Morris 版的前序遍历：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPre</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    TreeNode mostRight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是 morris 遍历的打印位置</span></span><br><span class="line">        <span class="comment">// System.out.print(curr.value + &quot; &quot;);</span></span><br><span class="line"></span><br><span class="line">        mostRight = curr.left;</span><br><span class="line">        <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != curr) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mostRight.right = curr;</span><br><span class="line">                <span class="comment">// 此时是节点 A 第一次找到 mostRight, 同时也是第一次访问节点 A</span></span><br><span class="line">                <span class="comment">// 因为只有在访问到节点 A 时, 才会去寻找其 mostRight</span></span><br><span class="line">                <span class="comment">// 在更新 curr 向左子树遍历前, 先打印一下, 当前打印的顺序是要先于下面 else 里的打印的</span></span><br><span class="line">                System.out.print(curr.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 此时是节点 A 第二次找到 mostRight, 同时也是第二次访问节点 A,</span></span><br><span class="line">                <span class="comment">// 因为只有在访问到节点 A 时, 才会去寻找其 mostRight</span></span><br><span class="line">                <span class="comment">// 而第二次访问节点 A 后, 出了当前 if 后不会进入到下面的 else, 所以不会打印第二次</span></span><br><span class="line">                <span class="comment">// 从而实现了前序遍历</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第一次来的时候打印</span></span><br><span class="line">            <span class="comment">// 当第二次访问到节点 A 时, 其从上面的寻找 mostRight 的 if 判断中出来后</span></span><br><span class="line">            <span class="comment">// 是无法进入到当前 else 里的, 从而避免了第二次打印节点 A</span></span><br><span class="line">            <span class="comment">// 而对于没有左孩子的节点, 因为根本不会进入上面的 if 里, 所以只会来到这里打印一次</span></span><br><span class="line">            System.out.print(curr.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>Morris 版的中序遍历：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisIn</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    TreeNode mostRight;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostRight = curr.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != curr) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mostRight.right = curr;</span><br><span class="line">                curr = curr.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序遍历只需要在这里打印即可, 因为第一次到达节点 A 时, 触发了 continue</span></span><br><span class="line">        <span class="comment">// 导致第一次遍历不会执行到这里, 只有在第二次回到节点 A 时, 走出了上面的 if 后到达这里进行打印</span></span><br><span class="line">        System.out.print(curr.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>Morris 版的后序遍历：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Morris 后序遍历的思路:</span></span><br><span class="line"><span class="comment">//    第二次回到节点 A 时, 逆序打印其左子树的所有右侧节点, 所有节点遍历完后, 再逆序打印整棵树的右侧节点</span></span><br><span class="line"><span class="comment">// 解释:</span></span><br><span class="line"><span class="comment">//   不再需要额外打印任何其他节点, 只需要在回到节点 A 时打印其左子树的右侧节点,</span></span><br><span class="line"><span class="comment">//   即可将那些只会遍历一次的节点(没有左孩子)给打印出来, 并且当前节点 A 也会在其祖先节点</span></span><br><span class="line"><span class="comment">//   进行逆序打印时进行打印, 所以整体不漏也不重</span></span><br><span class="line"><span class="comment">// 逆序打印的方法: 不需要栈存储, 直接用链表逆序打印的思路, 将左子树上的右侧节点视为一条链表, 进行逆序打印即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPos</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    TreeNode mostRight;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostRight = curr.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != curr) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mostRight.right = curr;</span><br><span class="line">                curr = curr.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 只用在第二次回到当前节点时将其左子树上的右侧节点逆序打印</span></span><br><span class="line">                printEdge(curr.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有节点遍历完后, 再将整棵树的右侧节点逆序打印</span></span><br><span class="line">    printEdge(root);</span><br><span class="line">    System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用递归逆序打印</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(TreeNode curr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printEdge(curr.right);</span><br><span class="line">    <span class="comment">// 全部孩子都遍历完后再打印自己, 就实现了逆序</span></span><br><span class="line">    System.out.println(curr.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>直观的理解：每个节点左子树，从右下角向左上角划线逆序打印，整棵树的所有子节点都可以按照这种画法被不漏不重的画出来：</p>
<img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211206135831549.png" alt="image-20211206135831549" style="zoom:50%;" />

        <h4 id="morris-遍历的应用"   >
          <a href="#morris-遍历的应用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#morris-遍历的应用"></a> Morris 遍历的应用</h4>
      
<p>Morris 遍历通常用于以较低的空间复杂度遍历整棵树。</p>
<p><strong>应用一：判断某棵树是否是搜索二叉树</strong></p>
<p>思路：使用 Morris 中序遍历，判断当前值是否大于目前的最大值，若不大于，则不是搜索二叉树。</p>
<p><strong>应用二：恢复搜索二叉树</strong></p>
<p>思路：使用 Morris 中序遍历，判断前一个值 pred 是否大于当前值，若大于，则发现了错误点</p>

        <h3 id="直观地打印一颗二叉树"   >
          <a href="#直观地打印一颗二叉树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#直观地打印一颗二叉树"></a> 直观地打印一颗二叉树</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Binary Tree:&quot;</span>);</span><br><span class="line">    printInOrder(head, <span class="number">0</span>, <span class="string">&quot;H&quot;</span>, <span class="number">17</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInOrder</span><span class="params">(Node head, <span class="keyword">int</span> height, String to, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printInOrder(head.right, height + <span class="number">1</span>, <span class="string">&quot;v&quot;</span>, len);</span><br><span class="line">    String val = to + head.value + to;</span><br><span class="line">    <span class="keyword">int</span> lenM = val.length();</span><br><span class="line">    <span class="keyword">int</span> lenL = (len - lenM) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lenR = len - lenM - lenL;</span><br><span class="line">    val = getSpace(lenL) + val + getSpace(lenR);</span><br><span class="line">    System.out.println(getSpace(height * len) + val);</span><br><span class="line">    printInOrder(head.left, height + <span class="number">1</span>, <span class="string">&quot;^&quot;</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String space = <span class="string">&quot; &quot;</span>;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        buf.append(space);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="几种特殊的二叉树"   >
          <a href="#几种特殊的二叉树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#几种特殊的二叉树"></a> 几种特殊的二叉树</h2>
      

        <h3 id="搜索二叉树"   >
          <a href="#搜索二叉树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#搜索二叉树"></a> 搜索二叉树</h3>
      
<p>若一棵二叉树根节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值（等于都不行）； 它的左、右子树也分别为搜索二叉树。</p>
<p>搜索二叉树（Binary Search Tree）作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。</p>
<p>判断一棵树是否是搜索二叉树有三种方法。</p>

        <h4 id="方法一中序遍历后判断是否升序"   >
          <a href="#方法一中序遍历后判断是否升序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法一中序遍历后判断是否升序"></a> 方法一：中序遍历后，判断是否升序</h4>
      
<p>一种简单的方法是首先中序遍历这棵二叉树，并在遍历过程中将每个节点的值保存到一个数组里，遍历完成后，再判断该数组是否是升序的。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSBT01</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inOrderRecur(head, list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接着判断数组是否为升序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.get(i) &gt;= list.get(i+<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderRecur</span><span class="params">(Node head, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inOrderRecur(head.left, list);</span><br><span class="line">    list.add(head.value);</span><br><span class="line">    inOrderRecur(head.right, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="方法二中序遍历-不断保存当前最大值"   >
          <a href="#方法二中序遍历-不断保存当前最大值" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法二中序遍历-不断保存当前最大值"></a> 方法二：中序遍历 + 不断保存当前最大值</h4>
      
<p>方法二需要借助一个静态变量 <code>preMaxValue</code> 存储递归过程中 <strong>&quot;当前节点之前的所有节点&quot;的最大值</strong> 。因为搜索二叉树是按照<strong>中序遍历</strong>的方式升序的，<strong>所以当前节点后面的节点值都要大于该最大值</strong>。递归过程中<strong>不断保存当前已经遍历过的节点的最大值，并且令后续即将遍历的节点值都要大于该值</strong>。</p>
<p>整个方法栈调用时，是先从左下角的那颗子树开始的，按照 左 -&gt; 头 -&gt; 右 的顺序，依次判断当前节点的值是否大于其左侧的所有节点的最大值 <code>preMaxValue</code>，方法栈不断从左下角开始向右上方向扩展，直到整棵树完成遍历：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> preMaxValue = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSBT02</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意这里如果到了边界条件，是返回的true，因为叶子结点必定是满足搜索二叉树条件的</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先遍历左子树，返回其是否满足搜索二叉树条件</span></span><br><span class="line">    <span class="keyword">boolean</span> isLeftBst = isSBT02(head.left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子树不是搜索二叉树，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!isLeftBst) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子树上的点比当前节点的值还要大（或相等），则说明不是搜索二叉树，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (preMaxValue &gt;= head.value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则更新最小值为当前节点，令当前节点的右子树上的点都要比该值大</span></span><br><span class="line">        preMaxValue = head.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行到这里时，当前节点的左子树里的最大值都要比当前节点要小，</span></span><br><span class="line">    <span class="comment">// 说明到这里为止，都是符合搜索二叉树的，接着要遍历当前节点的右子树，判断其是否也满足搜索二叉树</span></span><br><span class="line">   <span class="keyword">return</span> isSBT02(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="方法三morris-中序遍历-不断保存当前最大值"   >
          <a href="#方法三morris-中序遍历-不断保存当前最大值" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法三morris-中序遍历-不断保存当前最大值"></a> 方法三：Morris 中序遍历 + 不断保存当前最大值</h4>
      
<p>与方法二的区别在于使用 Morris 中序遍历节省空间，思路几乎一致。代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisIn</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    TreeNode mostRight;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostRight = curr.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != curr) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mostRight.right = curr;</span><br><span class="line">                curr = curr.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序遍历只需要在这里打印即可, 因为第一次到达节点 A 时, 触发了 continue</span></span><br><span class="line">        <span class="comment">// 导致第一次遍历不会执行到这里, 只有在第二次回到节点 A 时, 走出了上面的 if 后到达这里进行打印</span></span><br><span class="line">        System.out.print(curr.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="方法四使用模板套路"   >
          <a href="#方法四使用模板套路" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法四使用模板套路"></a> 方法四：使用模板套路</h4>
      
<blockquote>
<p>先介绍非标准模板的解法</p>
</blockquote>
<p>也可以使用模板套路进行解题，每个节点的左右子树都返回一个 <code>ReturnType</code> 对象，其内即保存了该子树上的最大值和最小值，也保存了该子树是否是搜索二叉树。该对象内保存的最小值是给右子树判断时用，最大值是给左子树判断时用。</p>
<p>方法流程：</p>
<ul>
<li>遍历到每一个节点时，首先获取左子树的 <code>ReturnData</code>，判断左子树是否满足搜索二叉树：
<ul>
<li>如果返回值里的 <code>isBST</code> 为 false，说明其左子树不为搜索二叉树</li>
<li>如果当前节点的值<strong>小于等于</strong>左子树返回值里的<strong>最大值</strong>，则说明不是搜索二叉树</li>
<li>如果左子树不满足搜索二叉树，则向上返回一个 <code>new ReturnData(false)</code>，后续的右子树就不会再去判断了，直接方法栈返回到头结点后返回给主程序 false</li>
</ul>
</li>
<li>如果左子树满足搜索二叉树，则去获取其右子树的  <code>ReturnData</code>，判断右子树是否满足搜索二叉树：
<ul>
<li>如果返回值里的 <code>isBST</code>为 false，说明其右子树不为搜索二叉树</li>
<li>如果当前节点的值<strong>大于等于</strong>右子树返回值里的<strong>最小值</strong>，则说明不是搜索二叉树</li>
<li>如果右子树不满足搜索二叉树，则向上返回一个 <code>new ReturnData(false)</code></li>
</ul>
</li>
<li>如果左右子树都满足搜索二叉树，则返回一个 <code>ReturnData(leftReturn.min, rightReturn.max)</code>，其内保存了当前子树上的最小值和最大值，其中：
<ul>
<li><strong>当前子树的最小值是左子树上的最小值</strong></li>
<li><strong>当前子树的最大值是右子树上的最大值</strong></li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建模板返回值类，在其内保存当前子树上的最大值和最小值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isSBT = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnData</span><span class="params">(<span class="keyword">boolean</span> isSBT)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isSBT = isSBT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnData</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.min = min;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSBT03</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReturnData result = checkIsSBT(head);</span><br><span class="line">    <span class="keyword">return</span> result.isSBT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">checkIsSBT</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReturnData leftReturn = checkIsSBT(head.left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先判断左子树是否满足搜索二叉树：</span></span><br><span class="line">    <span class="comment">//   1. 如果返回值里的 isBST 为 false，说明其左子树不为搜索二叉树</span></span><br><span class="line">    <span class="comment">//   2. 如果当前节点的值小于等于左子树返回值里的最大值，则说明不是搜索二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (!leftReturn.isSBT || leftReturn.max &gt;= head.value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReturnData rightReturn = checkIsSBT(head.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再判断右子树是否满足搜索二叉树：</span></span><br><span class="line">    <span class="comment">//   1. 如果返回值里的 isBST 为 false，说明其右子树不为搜索二叉树</span></span><br><span class="line">    <span class="comment">//   2. 如果当前节点的值大于等于右子树返回值里的最小值，则说明不是搜索二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (!rightReturn.isSBT || rightReturn.min &lt;= head.value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前子树上的最大值和最小值</span></span><br><span class="line">    <span class="comment">// 最小值给右子树判断时用，最大值给左子树判断时用</span></span><br><span class="line">    <span class="comment">// 当前子树上的最小值是左子树上的最小值，最大值是右子树上的最大值</span></span><br><span class="line">    <span class="comment">// 因为其按照中序遍历时是升序大小，说明左子树上的最左叶子结点是最小值，右子树上的最右节点是最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(leftReturn.min, rightReturn.max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>注意：上面这种写法并不是标准的模板套路。标准的模板套路是：只在方法的最后进行 return，在方法前面先调用两个递归获取到左右子树上的返回值，据此进行判断后再最后封装成 <code>ReturnData</code> 返回：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">f</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据具体场景返回相应的值</span></span><br><span class="line">        <span class="keyword">return</span> ReturnData(xx, xx, xx);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先获取左右子树上的返回值</span></span><br><span class="line">    ReturnData leftReturnData = f(head.left);</span><br><span class="line">    ReturnData rightReturnData = f(head.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行判断处理等，例如将 boolean 类型值设置为 true 或 false，设置最大最小值等</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在最后将设置好的值封装成 ReturnData 并向上返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(xx, xx, xx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在本问题中，使用标准模板的解法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isSBT = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnData</span><span class="params">(<span class="keyword">boolean</span> isSBT, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.min = min;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBST04</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReturnData result = checkBST02(head);</span><br><span class="line">    <span class="keyword">return</span> result.isSBT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">checkIsSBT02</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReturnData leftReturn = checkIsSBT02(head.left);</span><br><span class="line">    ReturnData rightReturn = checkIsSBT02(head.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isSBT = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果左子树返回值不为空，且左子树不为搜索二叉树，或左子树最大值大于等于当前节点值，说明不构成搜索二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (leftReturn != <span class="keyword">null</span> &amp;&amp; (!leftReturn.isSBT || leftReturn.max &gt;= head.value))</span><br><span class="line">        isSBT = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果右子树返回值不为空，且右子树不为搜索二叉树，或右子树最小值小于等于当前节点值，说明不构成搜索二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (rightReturn != <span class="keyword">null</span> &amp;&amp; (!rightReturn.isSBT || rightReturn.min &lt;= head.value))</span><br><span class="line">        isSBT = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = head.value;</span><br><span class="line">    <span class="keyword">int</span> max = head.value;</span><br><span class="line">    <span class="comment">// 计算左右子树与当前节点构成的子树上的最大值和最小值，返回给上一层节点使用</span></span><br><span class="line">    <span class="keyword">if</span> (leftReturn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        min = Math.min(leftReturn.min, min);</span><br><span class="line">        max = Math.min(leftReturn.max, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightReturn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        min = Math.min(rightReturn.min, min);</span><br><span class="line">        max = Math.min(rightReturn.max, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(isSBT, min, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>这种标准模板的方式存在的缺点：一定会遍历整棵树，因为 return 在方法最后，只会在第三次回到该节点时 return，即只有在遍历过当前节点的左右子树后才会 return，这就导致效率相比上面的方式差了一些（上面的方式是只要在左子树上遇到不满足的子树就直接向上返回到根节点，不会再遍历右子树）</p>

        <h4 id="搜索二叉树的增删改查操作"   >
          <a href="#搜索二叉树的增删改查操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#搜索二叉树的增删改查操作"></a> 搜索二叉树的增删改查操作</h4>
      
<p>搜索二叉树<strong>查找</strong>节点的流程：</p>
<ul>
<li>如果目标节点值大于当前节点值，则向右递归遍历该树</li>
<li>如果目标节点值小于当前节点值，则向左递归遍历该树</li>
<li>直到找到<strong>当前节点的值等于目标节点值</strong>，即找到了目标节点</li>
</ul>
<p>搜索二叉树<strong>插入</strong>节点的流程：</p>
<ul>
<li>如果目标节点值大于当前节点值，则向右递归遍历该树</li>
<li>如果目标节点值小于当前节点值，则向左递归遍历该树</li>
<li>直到<strong>遍历到底层</strong>时（root == null），即找到了目标节点需要被插入的地方，将其父节点指向目标节点即可（目标节点肯定会被插入到树的<strong>某个叶子节点的孩子处</strong>）</li>
</ul>
<p>搜索二叉树<strong>删除</strong>节点的流程：</p>
<ul>
<li>若目标节点没有左右孩子，说明其是叶子节点，<strong>直接将其父节点的对应孩子位置置空</strong>（遍历过程中还需要记录当前节点的父节点，需要在删除了目标节点后将其父节点的对应孩子置空）</li>
<li>若目标节点有左孩子或右孩子（但不同时存在左右孩子），则<strong>将其父节点的对应孩子位置设置为目标节点的左或右孩子即可</strong>（让目标节点的孩子代替自己）</li>
<li>若目标节点同时有左孩子和右孩子，则<strong>找到其右子树上最左的节点或左子树上最右的节点，令该节点代替自己</strong>，并且：
<ul>
<li>若选择右子树的最左节点，则令该节点的父节点的左孩子指向该节点的右子树（令最左节点的右子树代替自己）</li>
<li>若选择左子树的最右节点，则令该节点的父节点的右孩子指向该节点的左子树（令最右节点的左子树代替自己）</li>
</ul>
</li>
</ul>

        <h3 id="完全二叉树"   >
          <a href="#完全二叉树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#完全二叉树"></a> 完全二叉树</h3>
      
<p>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与<strong>满二叉树</strong>中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树（Complete Binary Tree）。</p>
<blockquote>
<p>堆结构即为完全二叉树。</p>
</blockquote>

        <h4 id="方法一层次遍历-队列"   >
          <a href="#方法一层次遍历-队列" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法一层次遍历-队列"></a> 方法一：层次遍历 + 队列</h4>
      
<blockquote>
<p>层次遍历常常与队列一起组合出现，因为使用队列先进先出的特点才能保证做到层次遍历，如果是栈结构的先进后出，就无法做到层次遍历</p>
</blockquote>
<p>准备一个队列，用于存放层次遍历过程中的每个节点。之所以选择层次遍历，是因为在判断是否满足完全二叉树时有两个判断条件，这两个条件需要依靠层次遍历来实现（因为需要一层一层的遍历，判断当前层内的节点是否满足这两个条件）：</p>
<ul>
<li>当前节点如果<strong>只有右孩子</strong>，则必定不满足完全二叉树（对应图中情况1）</li>
<li>当前节点如果<strong>左右孩子不双全</strong>，那么当前层所在的后面节点都<strong>必须不能有孩子节点</strong>，即<strong>后面的节点都必须是叶子结点</strong>（对应图中情况2）</li>
</ul>
<p>可以看出，条件2中用到了判断<strong>当前层后面节点</strong>是否有孩子节点，所以必须使用层次遍历。</p>
<p><img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/%E5%B9%BB%E7%81%AF%E7%89%871-1634725344405.PNG" alt="幻灯片1" /></p>
<p>对上述两个条件进行解释：</p>
<ul>
<li>如果节点如果<strong>只有右孩子</strong>，则根据完全二叉树的定义，其必定不符合，因为完全二叉树里有右孩子的话必定得有左孩子</li>
<li>当前节点如果<strong>左右孩子不双全</strong>，那么说明当前节点为<strong>临界条件节点</strong>，当前层所在的后面节点都<strong>必须不能有孩子节点</strong>，即<strong>后面的节点都必须是叶子结点</strong>，这样才满足完全二叉树的定义</li>
</ul>
<p>代码实现时：</p>
<ul>
<li>条件1较好实现，在遍历过程中添加条件判断即可。</li>
<li>条件2的实现则需要借助一个布尔类型的 <code>flag</code>，其在遇到第一个<strong>左右孩子不双全</strong>的节点（上图中的绿色）时，将 <code>flag = true</code>，并且在每个节点遍历时，判断 <code>flag</code> 的值，如果为 true，就需要额外判断当前节点是否为叶子结点，如果不是则说明不符合完全二叉树。</li>
</ul>
<p><img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/%E5%B9%BB%E7%81%AF%E7%89%872.PNG" alt="幻灯片2" /></p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCBT</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line"></span><br><span class="line">    Node left = <span class="keyword">null</span>;</span><br><span class="line">    Node right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        left = head.left;</span><br><span class="line">        right = head.right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (    <span class="comment">// 条件1：</span></span><br><span class="line">                (left == <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)</span><br><span class="line">                ||</span><br><span class="line">                <span class="comment">// 条件2：</span></span><br><span class="line">                (flag == <span class="keyword">true</span> &amp;&amp; (left != <span class="keyword">null</span> || right != <span class="keyword">null</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果遇到临界条件节点（上文图中绿色节点），则将 flag = true</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="满二叉树"   >
          <a href="#满二叉树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#满二叉树"></a> 满二叉树</h3>
      
<p>满二叉树（Full Binary Tree）：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</p>

        <h4 id="方法一层次遍历-记录层数与总节点数"   >
          <a href="#方法一层次遍历-记录层数与总节点数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法一层次遍历-记录层数与总节点数"></a> 方法一：层次遍历 + 记录层数与总节点数</h4>
      
<p>判断是否是满二叉树的一种方法是使用层次遍历，在遍历的过程中一边记录层数，一边记录节点个数，遍历结束后判断总节点数和层数的关系是否满足满二叉树条件即可。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFBT01</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line"></span><br><span class="line">    Map&lt;Node, Integer&gt; layerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    layerMap.put(head, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录当前层</span></span><br><span class="line">    <span class="keyword">int</span> currLayer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录总节点数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node curr = queue.poll();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 如果 currLayer 小于当前节点的层数，说明需要换层：将层数加一</span></span><br><span class="line">        <span class="comment">// 该判断成立的时机在 遍历到了下一层的第一个节点时</span></span><br><span class="line">        <span class="keyword">if</span> (currLayer &lt; layerMap.get(curr))</span><br><span class="line">            currLayer++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(curr.left);</span><br><span class="line">            layerMap.put(curr.left, currLayer + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(curr.right);</span><br><span class="line">            layerMap.put(curr.right, currLayer + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 count == 2^k - 1</span></span><br><span class="line">    <span class="keyword">return</span> count == ((<span class="number">1</span> &lt;&lt; currLayer) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="方法二使用模板套路"   >
          <a href="#方法二使用模板套路" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法二使用模板套路"></a> 方法二：使用模板套路</h4>
      
<p>判断满二叉树的模板套路非常简单，只需在向左右孩子索要节点数与层数信息，从而更新自己的节点数与层数信息。递归该过程即可得到整棵树的节点数与层数。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> nodes;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> layers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnData</span><span class="params">(<span class="keyword">int</span> nodes, <span class="keyword">int</span> layers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nodes = nodes;</span><br><span class="line">        <span class="keyword">this</span>.layers = layers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFBT02</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReturnData result = checkIsFull(head);</span><br><span class="line">    <span class="keyword">return</span> result.nodes == ((<span class="number">1</span> &lt;&lt; result.layers) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">checkIsFull</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReturnData leftReturn = checkIsFull(head.left);</span><br><span class="line">    ReturnData rightReturn = checkIsFull(head.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出当前子树的高度和总节点数</span></span><br><span class="line">    <span class="keyword">int</span> layers = Math.max(leftReturn.layers, rightReturn.layers) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nodes = leftReturn.nodes + rightReturn.nodes + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(nodes, layers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="平衡二叉树"   >
          <a href="#平衡二叉树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#平衡二叉树"></a> 平衡二叉树</h3>
      
<p>平衡二叉树（Balanced Binary Tree）又被称为 AVL 树。它具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>使用模板套路即可解该题，定义 <code>ReturnData</code> 记录子树上的节点个数以及是否是平衡二叉树，不断向上返回时判断即可。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> nodes;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isBBT;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnData</span><span class="params">(<span class="keyword">boolean</span> isBBT, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isBBT = isBBT;</span><br><span class="line">        <span class="keyword">this</span>.nodes = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBBT</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReturnData result = checkIsBBT(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.isBBT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">checkIsBBT</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReturnData leftReturn = checkIsBBT(head.left);</span><br><span class="line">    ReturnData rightReturn = checkIsBBT(head.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isBBT = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果左右子树表明自己是非平衡二叉树或左右子树的节点数的绝对值之差大于1，则说明当前子树不是平衡二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (!leftReturn.isBBT || !rightReturn.isBBT)</span><br><span class="line">        isBBT = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(leftReturn.nodes - rightReturn.nodes) &gt; <span class="number">1</span>)</span><br><span class="line">        isBBT = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(isBBT, leftReturn.nodes + rightReturn.nodes + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>不使用模板的剪枝操作：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recur(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">recur</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = recur(root.left);</span><br><span class="line">    <span class="comment">// 如果左子树不为平衡二叉树，则直接返回，完成剪枝</span></span><br><span class="line">    <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> right = recur(root.right);</span><br><span class="line">    <span class="keyword">if</span>(right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Math.abs(left - right) &lt; <span class="number">2</span> ? Math.max(left, right) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="将有序数组转换为二叉平衡搜索树"   >
          <a href="#将有序数组转换为二叉平衡搜索树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#将有序数组转换为二叉平衡搜索树"></a> 将有序数组转换为二叉平衡搜索树</h3>
      
<p>给你一个整数数组 <code>nums</code> ，其中元素已经按<strong>升序</strong>排列，请你将其转换为一棵<strong>高度平衡</strong>二叉搜索树。高度平衡二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p>递归解决：使用递归的方式，每次取数组中间的值比如m作为当前节点，m前面的值作为他左子树的结点值，m后面的值作为他右子树的节点值，示例中一个可能的结果是</p>
<p><img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211026100602967.png" alt="image-20211026100602967" /></p>
<p>每次递归时，左子树对应数组 <code>[start, mid - 1]</code>，右子树对应数组 <code>[mid + 1, end]</code>。<strong>注意是没有取到 mid 的</strong>，因为 mid 位置的数字已经在当前方法栈中被创建成了一个节点添加到整棵树中，不能将其也放到左右子树的递归里，否则会重复创建节点。</p>
<p>注意边界条件是 <code>start &gt; end</code>。遇到这种情况说明在上一层递归中计算出的 mid 的左侧没有子数组，此时 <code>start == mid</code>，<code>end == mid -1</code>，故其左子树的递归方法里 <code>start &gt; end</code> 。这种情况，说明上一层的 mid 没有了左孩子，因此其左侧递归的结果应该返回 null。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次取数组中间的数字作为当前节点，其左右子数组作为当前节点的左右树上的节点    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sortedArrayToBSTHelper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBSTHelper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发生在划分叶子节点时，长度为2的子数组在计算[start, mid - 1] 时</span></span><br><span class="line">    <span class="comment">// 可能出现 start &gt; mid -1 的情况，例如 start == 0, end == 1，则计算出来的</span></span><br><span class="line">    <span class="comment">// mid - 1 == -1 &lt; start; 这种情况说明到了叶子节点，该返回null了</span></span><br><span class="line">    <span class="comment">// 即：上一层递归中计算出的 mid 在左侧没有了子数组，所以其左侧递归的结果应该返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左侧的范围注意是 [start, mid - 1]</span></span><br><span class="line">    root.left = sortedArrayToBSTHelper(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = sortedArrayToBSTHelper(nums, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="avl-树原理"   >
          <a href="#avl-树原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#avl-树原理"></a> AVL 树原理</h4>
      

        <h3 id="二叉树的线索化"   >
          <a href="#二叉树的线索化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二叉树的线索化"></a> 二叉树的线索化</h3>
      
<p>定义一个 pre 节点，令其不断等于 node 的前一个节点，在第二次回到当前节点时，设置node的前驱为 pre，然后设置 pre 的后继为 node</p>
<p>代码里的两个条件判断不是同时成立的，一个节点只可能某一个成立</p>
<p><img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211027144627113.png" alt="image-20211027144627113" /></p>
<p>二叉树线索化后，就等于一个双向链表（见书），可以直接按照某种顺序遍历整棵树</p>

        <h3 id="自平衡二叉查找树"   >
          <a href="#自平衡二叉查找树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#自平衡二叉查找树"></a> 自平衡二叉查找树</h3>
      
<blockquote>
<p>自平衡二叉查找树又被称为<strong>有序表</strong>，主要是用它来<strong>存储有序的数据</strong></p>
</blockquote>
<p>自平衡二叉查找的所有操作的时间复杂度都是 O(logN) 级别。具体实现为：</p>
<ul>
<li>平衡搜索二叉树（BST）系列
<ul>
<li>平衡二叉树（AVL树）</li>
<li>节点大小平衡树（Size Balanced Tree）</li>
<li>红黑树（Red–Black Tree）</li>
</ul>
</li>
<li>跳表（Skip List）</li>
</ul>
<p>四者的时间复杂度相同。</p>

        <h4 id="搜索二叉树的增删改查操作-2"   >
          <a href="#搜索二叉树的增删改查操作-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#搜索二叉树的增删改查操作-2"></a> 搜索二叉树的增删改查操作</h4>
      
<p>有序表都是搜索二叉树，因此首先介绍搜索二叉树的增删改查操作。</p>
<p>搜索二叉树<strong>查找</strong>节点的流程：</p>
<ul>
<li>如果目标节点值大于当前节点值，则向右递归遍历该树</li>
<li>如果目标节点值小于当前节点值，则向左递归遍历该树</li>
<li>直到找到<strong>当前节点的值等于目标节点值</strong>，即找到了目标节点</li>
</ul>
<p>搜索二叉树<strong>插入</strong>节点的流程：</p>
<ul>
<li>如果目标节点值大于当前节点值，则向右递归遍历该树</li>
<li>如果目标节点值小于当前节点值，则向左递归遍历该树</li>
<li>直到<strong>遍历到底层</strong>时（root == null），即找到了目标节点需要被插入的地方，将其父节点指向目标节点即可（目标节点肯定会被插入到树的<strong>某个叶子节点的孩子处</strong>）</li>
</ul>
<p>搜索二叉树<strong>删除</strong>节点的流程：</p>
<ul>
<li>若目标节点没有左右孩子，说明其是叶子节点，<strong>直接将其父节点的对应孩子位置置空</strong>（遍历过程中还需要记录当前节点的父节点，需要在删除了目标节点后将其父节点的对应孩子置空）</li>
<li>若目标节点有左孩子或右孩子（但不同时存在左右孩子），则<strong>将其父节点的对应孩子位置设置为目标节点的左或右孩子即可</strong>（让目标节点的孩子代替自己）</li>
<li>若目标节点同时有左孩子和右孩子，则<strong>找到其右子树上最左的节点或左子树上最右的节点，令该节点代替自己</strong>，并且：
<ul>
<li>若选择右子树的最左节点，则令该节点的父节点的左孩子指向该节点的右子树（令最左节点的右子树代替自己）</li>
<li>若选择左子树的最右节点，则令该节点的父节点的右孩子指向该节点的左子树（令最右节点的左子树代替自己）</li>
</ul>
</li>
</ul>

        <h4 id="左旋与右旋"   >
          <a href="#左旋与右旋" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#左旋与右旋"></a> 左旋与右旋</h4>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/blueliuyun/article/details/78523937" >https://blog.csdn.net/blueliuyun/article/details/78523937</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>如下图所示的操作被称为<strong>对节点Q的右旋</strong>，<strong>对节点P的左旋</strong>。二者互为逆操作。即，右旋——自己变为左孩子的右孩子；左旋——自己变为右孩子的左孩子。</p>
<p><img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/20171113195048032" alt="img" /></p>

        <h4 id="avl-树的自平衡实现原理"   >
          <a href="#avl-树的自平衡实现原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#avl-树的自平衡实现原理"></a> AVL 树的自平衡实现原理</h4>
      
<blockquote>
<p>AVL 树需要满足某节点的左右子树的高度差不大于1。</p>
</blockquote>
<p>当 AVL 插入一个节点或删除一个节点时，<strong>从该节点的父节点开始不断向树的顶部遍历</strong>，逐个判断当前节点的左右子树是否满足平衡性。如果不满足则开始进行自平衡调整，具体分四种情况：</p>
<ul>
<li>LR 型：某个节点的左孩子的右子树 subTree 过长。先进行左旋，然后进行右旋，令该右子树 subTree 的根节点成为该子树的根节点</li>
<li>LL 型：某个节点的左孩子 A 的左子树过长。只需要进行一次右旋，令该左孩子 A 成为该子树的根节点</li>
<li>RL 型：某个节点的右孩子的左子树 subTree 过长。先进行右旋，然后进行左旋，令该左子树 subTree 的根节点成为该子树的根节点</li>
<li>RR 型：某个节点的右孩子的右子树过长。只需要进行一次左旋，令该右孩子 A 成为该子树的根节点</li>
</ul>
<blockquote>
<p>更多细节参考文章：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56066942" >https://zhuanlan.zhihu.com/p/56066942</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h4 id="节点大小平衡树"   >
          <a href="#节点大小平衡树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#节点大小平衡树"></a> 节点大小平衡树</h4>
      
<p>Size Balanced Tree 也是一种自平衡二叉查找树，它的平衡原理是<strong>每棵树的大小，不小于其兄弟树的子树的大小</strong>，即每颗叔叔树的大小，不小于其他任何侄子树的大小。</p>
<p>该树的自平衡操作同样借助于左旋和右旋操作，区别在于：</p>
<ul>
<li>四种分型的定义区别：例如，LL 型指当前节点的左孩子的左子树的大小，大于当前节点的右子树的大小。LL 型需要将当前节点进行右旋</li>
<li>左右旋的操作和 AVL 树一样</li>
<li>左右旋后，递归判断哪些节点的左右孩子变化了，对左右孩子变化了的节点递归进行该过程，直到令所有节点都符合条件</li>
<li>与 AVL 树一样，当前子树调整完毕后，继续去其父节点上重复该过程直到整棵树完成自平衡</li>
</ul>

        <h4 id="红黑树"   >
          <a href="#红黑树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#红黑树"></a> 红黑树</h4>
      
<p>红黑树也是一种自平衡二叉查找树。红黑树的特性：</p>
<ul>
<li>每个节点或者是黑色，或者是红色</li>
<li>根节点是黑色</li>
<li>每个叶子节点（NIL）是黑色 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li>
<li><strong>如果一个节点是红色的，则它的子节点必须是黑色的</strong>（黑色节点却无此要求）</li>
<li><strong>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</strong>（利用该性质实现的平衡性）</li>
</ul>
<p><img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/251730074203156.jpg" alt="img" /></p>

        <h2 id="二叉树的常见问题"   >
          <a href="#二叉树的常见问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二叉树的常见问题"></a> 二叉树的常见问题</h2>
      

        <h3 id="树的序列化与反序列化"   >
          <a href="#树的序列化与反序列化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#树的序列化与反序列化"></a> 树的序列化与反序列化</h3>
      
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" >剑指 Offer 37. 序列化二叉树</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>：内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树？两种序列化的方式：</p>
<ul>
<li>前序遍历顺序</li>
<li>层次遍历顺序</li>
</ul>

        <h4 id="前序遍历序列化"   >
          <a href="#前序遍历序列化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#前序遍历序列化"></a> 前序遍历序列化</h4>
      
<p>序列化时，进行前序遍历，如果孩子节点不为空就 <code>append</code> 当前节点的 <code>value</code>，中间以 <code>_</code> 分割，如果为空需要设置为 <code>#</code>（注意这很关键，需要根据 <code>#</code> 判断何时遇到了 null），。序列化示例： <code>100_21_37_#_#_#_-42_0_#_#_666_#_#_</code>。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialByPre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    serializeProcessByPre(head, builder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化时，孩子节点为空需要设置为 #（注意这很关键，需要根据 # 判断何时遇到了 null），</span></span><br><span class="line"><span class="comment">// 不为空就添加数字，中间以 _ 分割</span></span><br><span class="line"><span class="comment">// 序列化示例： 100_21_37_#_#_#_-42_0_#_#_666_#_#_</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serializeProcessByPre</span><span class="params">(Node head, StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遇到空节点，就添加 #，注意，这很重要</span></span><br><span class="line">        builder.append(<span class="string">&quot;#_&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历过程中不断将当前节点加入到 builder 里</span></span><br><span class="line">    builder.append(head.value).append(<span class="string">&quot;_&quot;</span>);</span><br><span class="line"></span><br><span class="line">    serializeProcessByPre(head.left, builder);</span><br><span class="line">    serializeProcessByPre(head.right, builder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="前序遍历反序列化"   >
          <a href="#前序遍历反序列化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#前序遍历反序列化"></a> 前序遍历反序列化</h4>
      
<p>反序列化时，先将序列化后的字符串 <code>split</code> 拆成字符串数组，然后再进行前序遍历，不断创建节点拼接起来，注意遇到 <code>#</code> 说明当前分支到了底，需要返回 null</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconByPreString</span><span class="params">(String serialString)</span> </span>&#123;</span><br><span class="line">    String[] values = serialString.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">        queue.add(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reconProcess(queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconProcess</span><span class="params">(Queue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">    String value = queue.poll();</span><br><span class="line">    <span class="keyword">if</span> (value.equals(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历时先恢复出当前节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Integer.parseInt(value));</span><br><span class="line">    node.left = reconProcess(queue);</span><br><span class="line">    node.right = reconProcess(queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="层次遍历序列化与反序列化"   >
          <a href="#层次遍历序列化与反序列化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#层次遍历序列化与反序列化"></a> 层次遍历序列化与反序列化</h4>
      
<p>效果：</p>
<img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211223101721124.png" alt="image-20211223101721124" style="zoom:67%;" />
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.append(node.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> res.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">        res.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.equals(<span class="string">&quot;[]&quot;</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] vals = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="判断一颗二叉树是不是另一棵二叉树的子树"   >
          <a href="#判断一颗二叉树是不是另一棵二叉树的子树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#判断一颗二叉树是不是另一棵二叉树的子树"></a> 判断一颗二叉树是不是另一棵二叉树的子树</h3>
      
<p>可以先把两棵树序列化，变成两个字符串，然后 <code>str1.isContain(str2)</code> 直接判断二者是否为包含关系，如果是说明 str2 是 str1 的子树。</p>

        <h3 id="求一颗二叉树的最大深度"   >
          <a href="#求一颗二叉树的最大深度" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#求一颗二叉树的最大深度"></a> 求一颗二叉树的最大深度</h3>
      

        <h4 id="方法一递归-模板思想"   >
          <a href="#方法一递归-模板思想" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法一递归-模板思想"></a> 方法一：递归 + 模板思想</h4>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回左子树和右子树上最大深度，再加一，即为当前子树的总深度</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="方法二递归-计数"   >
          <a href="#方法二递归-计数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法二递归-计数"></a> 方法二：递归 + 计数</h4>
      
<p>第一次遍历到当前节点时，count++；最后一次回到当前节点时，count–；在遇到叶子节点时再更新一次 maxLayer：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;    </span><br><span class="line">        <span class="keyword">this</span>.maxLayer = Math.max(<span class="keyword">this</span>.maxLayer, <span class="keyword">this</span>.count);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.maxLayer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次来到当前节点时计数加一</span></span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line"></span><br><span class="line">    maxDepth(root.left);</span><br><span class="line">    maxDepth(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后一次回到当前节点时计数减一</span></span><br><span class="line">    <span class="keyword">this</span>.count--;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.maxLayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="方法三层次遍历-计数"   >
          <a href="#方法三层次遍历-计数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法三层次遍历-计数"></a> 方法三：层次遍历 + 计数</h4>
      
<p>使用层次遍历顺序，依次将每一层的节点入队，并且每次遍历一整层的节点，将其左右孩子依次入队，最后再更新一次树的深度。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备队列用于层次遍历</span></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> maxLayer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前队列中存储的节点依次弹出，同时将每个节点的左右孩子都加进去</span></span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node curr = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(curr.left);</span><br><span class="line">            <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) </span><br><span class="line">                queue.add(curr.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前层遍历完成后，更新最大深度</span></span><br><span class="line">        maxLayer++;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="求一颗二叉树的最大宽度"   >
          <a href="#求一颗二叉树的最大宽度" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#求一颗二叉树的最大宽度"></a> 求一颗二叉树的最大宽度</h3>
      
<p>可以在<strong>层次遍历</strong>的基础上完成该问题的求解。</p>
<p>首先设置几个关键变量：</p>
<ul>
<li><code>maxWidth</code>：要求的目标，整棵二叉树的最大宽度。该值将由最大的<code>nextWidth</code>决定</li>
<li><code>nextWidth</code>：当前层的下一层的宽度，将在遍历当前层的孩子节点时不断增大</li>
<li><code>currLayer</code>：当前层的编号，用于判断何时开始换层</li>
</ul>
<p>并且需要一个<code>HashMap</code>用于存储每一个节点的层编号信息。</p>
<p>方法思路：</p>
<ul>
<li>首先将根节点入队，并在<code>HashMap</code>中设置其层数编号为1，初始化三个关键参数都为1</li>
<li>弹出队首节点，获取其层数，并与当前层数<code>currLayer</code>对比
<ul>
<li>若当前层数小于弹出的队首节点，说明该换层了，则将变量进行更新：将下一层宽度<code>nextWidth</code>置空（因为换层后来到的新层还没开始遍历，所以新层的下一层宽度就是0，在后续遍历时才会开始逐渐增加），并更新最大宽度<code>maxWidth</code></li>
<li>若当前层数等于弹出的队首节点，说明还在当前这一层，不需要做额外操作</li>
</ul>
</li>
<li>遍历当前层，获取当前节点的左右孩子，若存在则放入<code>HashMap</code>中，并保存其孩子的层数编号为<code>currLayer + 1</code>，同时将下一层宽度 <code>nextWidth++</code>，因为当前节点的某一个子孩子被遍历到了，所以下一层宽度加一（在最底层时，因为都没孩子节点了，所以 <code>nextWidth</code> 不会增加，这也符合逻辑）</li>
<li>重复上面步骤，直到队列为空</li>
</ul>
<p>其中细节：</p>
<ul>
<li><code>nextWidth</code>保存的是下一层的节点数，其将在换层时，与 <code>maxWidth</code> 对比，为其赋值</li>
<li>因为每次对比的时候，给 <code>maxWidth</code> 赋值的都是下一层的宽度，所以在跳到最后一层的第一个节点时，给 <code>maxWidth</code> 附上了最后一层的信息，所以避免了漏层</li>
<li>每次更新<code>maxWidth</code>的时机都是在换层时，即遍历到下一层的第一个节点时，将原本下一层的宽度值 <code>nextWidth</code>（该值在其上一层遍历左右孩子的时候就已经被更新了，所以这里可以直接获取到，相当于提前更新了下一层的节点数）与当前最大宽度 <code>maxWidth</code> 对比并赋值。</li>
</ul>
<p>方法思想：层次遍历。提前计算好下一层的最大宽度，在换层时直接提前赋值给 <code>maxWidth</code> ，避免了漏层。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getTreeMaxWidth</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxWidth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextWidth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> currLayer = <span class="number">1</span>;</span><br><span class="line">    Map&lt;Node, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    map.put(head, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node curr = queue.poll();</span><br><span class="line">        <span class="comment">// 如果当前层数小于出队的节点的层数，说明该换层了</span></span><br><span class="line">        <span class="comment">// 换层时，将下一层宽度置空 nextWidth = 0，并更新最大宽度</span></span><br><span class="line">        <span class="keyword">if</span> (currLayer &lt; map.get(curr)) &#123;</span><br><span class="line">            maxWidth = Math.max(nextWidth, maxWidth);</span><br><span class="line">            currLayer++;</span><br><span class="line">            nextWidth = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：nextWidth 记录的是下一层的节点数</span></span><br><span class="line">        <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(curr.left);</span><br><span class="line">            <span class="comment">// 左右孩子对应的层数是当前层数+1</span></span><br><span class="line">            map.put(curr.left, currLayer+<span class="number">1</span>);</span><br><span class="line">            nextWidth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(curr.right);</span><br><span class="line">            map.put(curr.right, currLayer+<span class="number">1</span>);</span><br><span class="line">            nextWidth++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;max with = &quot;</span> + maxWidth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="层次遍历优化"   >
          <a href="#层次遍历优化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#层次遍历优化"></a> 层次遍历优化</h4>
      
<p>可以对上述代码进行优化。层次遍历时，可以进行双层 while 循环，外层循环判断当前树的节点是否全部都遍历过，内层循环则负责<strong>循环当前层的所有节点</strong>。</p>
<p>具体做法为：在内层 while 循环开始遍历前，首先计算当前队列内的节点个数。这个数字，其实就是<strong>目前队列中当前层节点的个数</strong>。</p>
<blockquote>
<p>原因：在内层 while 循环里，每次都将当前层的所有节点依次弹出，同时把其左右孩子都入队，这就导致了，第 N 层的 M 个节点都遍历后，队列里就 add 了第 N+1 层的所有节点，这样再进入下一次外层的 while 循环后，再次计算队列里的节点个数时，得到的数量就是第 N+1 层的节点个数。</p>
</blockquote>
<p>利用这种思想，可以一次性遍历一整层的节点，从而十分方便地计算当前层宽度</p>
<blockquote>
<p>记得当每进入一次外层循环时就令 count = 0，在每一次外层循环即将结束，更新 maxWidth</p>
</blockquote>
<p>优化后代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTreeMaxWidth3</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 首先别忘了将当前层节点个数清空</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="comment">// 依次遍历当前层内所有节点</span></span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node curr = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(curr.left);</span><br><span class="line">            <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(curr.right);</span><br><span class="line">            <span class="comment">// 每遍历一个当前层的节点，就更新一次最大宽度</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每遍历一次当前层节点，就更新一次最大宽度</span></span><br><span class="line">        maxWidth = Math.max(maxWidth, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="重建二叉树"   >
          <a href="#重建二叉树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#重建二叉树"></a> 重建二叉树</h3>
      
<p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>思路：</p>
<ul>
<li>先将中序数组里的所有数字及其对应的索引都加入到一个<strong>哈希表</strong>中，用于快速查询到前序数组中某个根节点在中序数组中的位置，从而<strong>根据该位置将中序数组划分为左右两半</strong></li>
<li>递归方法传入参数：
<ul>
<li>preRoot：<strong>前序</strong>数组中<strong>当前子树的根节点的索引值</strong>，使用该值创建出树结构，并去中序哈希表里查找该根节点在中序数组中的位置</li>
<li>inleft, inright：<strong>中序</strong>数组中<strong>当前子树的左右边界索引值</strong>，代表当前子树包含的节点只可能在此区间内</li>
</ul>
</li>
<li>根据传入的 preRoot 创建出对应的树节点，然后利用中序哈希表定位到该节点在中序数组中的位置 i，并据此将中序数组划分为左右两个区间：
<ul>
<li>中序数组中左子树的范围：[inleft, i - 1]</li>
<li>中序数组中右子树的范围：[i + 1, inright]</li>
</ul>
</li>
<li>根据划分出来的左右子树范围，计算出当前节点的左右子树的根节点（新一轮递归中的根节点）在前序数组中的位置：
<ul>
<li>preRoot 的左子树的根节点：preRoot + 1</li>
<li>preRoot 的左子树的根节点：preRoot + leftLength + 1 = preRoot  + i - inleft + 1</li>
</ul>
</li>
<li>使用计算出的新根节点位置（在前序数组中）以及新根节点的左右边界范围（在中序数组中）进行递归，直到 left &gt; right 时递归返回。</li>
</ul>
<p><img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211206145926473.png" alt="image-20211206145926473" /></p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; inorderMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// inorder 先存储到哈希表中</span></span><br><span class="line">        <span class="keyword">this</span>.inorderMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 存储每个元素值以及其对应的下标，用于快速定位该元素</span></span><br><span class="line">            inorderMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(preorder, <span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTreeHelper</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preRoot, <span class="keyword">int</span> inleft, <span class="keyword">int</span> inright)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果中序数组的左边界大于右边界，则不能继续递归了</span></span><br><span class="line">        <span class="keyword">if</span> (inleft &gt; inright) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode currRoot = <span class="keyword">new</span> TreeNode(preorder[preRoot]);</span><br><span class="line">        <span class="comment">// 从中序哈希表中找出当前根节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">this</span>.inorderMap.get(preorder[preRoot]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序数组中左子树的根节点为 preRoot + 1</span></span><br><span class="line">        <span class="comment">// 中序数组中左子树的范围：[inleft, i - 1]</span></span><br><span class="line">        currRoot.left = buildTreeHelper(preorder, preRoot + <span class="number">1</span>, inleft, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 左子树的长度为：i-1 - left + 1</span></span><br><span class="line">        <span class="keyword">int</span> leftLength = i - inleft;</span><br><span class="line">        <span class="comment">// 前序数组中右子树的根节点为 preRoot + leftLength + 1</span></span><br><span class="line">        <span class="comment">// 中序数组中右子树的范围：[i + 1, inright]</span></span><br><span class="line">        currRoot.right = buildTreeHelper(preorder, preRoot + leftLength + <span class="number">1</span>, i + <span class="number">1</span>, inright);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="二叉搜索树的最近公共祖先"   >
          <a href="#二叉搜索树的最近公共祖先" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二叉搜索树的最近公共祖先"></a> 二叉搜索树的最近公共祖先</h3>
      
<p>本题给定了两个重要条件：</p>
<ul>
<li>树为<strong>二叉搜索树</strong></li>
<li>树的所有节点的值都是<strong>唯一</strong>的。</li>
</ul>
<p>根据以上条件，可方便地判断 p，q 与 root 的子树关系，即：</p>
<ul>
<li>若 <code>root.val &lt; p.val</code>，则 p 在 root 右子树 中；</li>
<li>若 <code>root.val &gt; p.val</code>，则 p 在 root 左子树 中；</li>
<li>若 <code>root.val = p.val</code>，则 p 和 root 指向同一节点 。</li>
</ul>

        <h4 id="方法一迭代"   >
          <a href="#方法一迭代" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法一迭代"></a> 方法一：迭代</h4>
      
<p>循环搜索： 当节点 root 为空时跳出；</p>
<ul>
<li>当 p，q 都在 root 的<strong>右子树</strong>中，则遍历至 root.right；</li>
<li>否则，当 p，q 都在 root 的<strong>左子树</strong>中，则遍历至 root.left；</li>
<li>否则，说明找到了**最近公共祖先 **，跳出。</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代版本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            <span class="comment">// p,q 在 root 的右子树</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">            <span class="comment">// p,q 在 root 的左子树</span></span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="方法二递归"   >
          <a href="#方法二递归" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法二递归"></a> 方法二：递归</h4>
      
<p>递推工作：</p>
<ul>
<li>当 p，q 都在 root 的<strong>右子树</strong>中，则开启递归 root.right 并返回；</li>
<li>否则，当 p，q 都在 root 的<strong>左子树</strong>中，则开启递归 root.left 并返回；</li>
</ul>
<p>返回值：最近公共祖先 root 。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="二叉树的最低公共祖先"   >
          <a href="#二叉树的最低公共祖先" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二叉树的最低公共祖先"></a> 二叉树的最低公共祖先</h3>
      

        <h4 id="方法一递归"   >
          <a href="#方法一递归" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法一递归"></a> 方法一：递归</h4>
      
<p>本题是普通的树，而非二叉搜索树，因此不能简单的判断当前节点值是否小于或大于p，q的值。而应该在递归过程中判断当前节点的值是否等于 p 或 q：</p>
<ul>
<li>如果当前节点为空，则返回 null</li>
<li>若相等，则找到了二者中的某一个，直接向上返回该节点（如果是 p 是 q 的祖先的情况，则此时返回的就是二者中更靠上层的节点，也就是另一个节点的最近祖先）</li>
<li>若不相等，则继续递归向下寻找是够有节点等于 p 或 q</li>
</ul>
<p>递归方法的返回值共有四种情况：</p>
<ul>
<li>如果 <strong>left，right 都为空</strong>，则当前子树上不包含二者，直接返回 null</li>
<li>如果<strong>二者都不为空</strong>，则当前 root 即为二者的最近公共祖先，返回 root（root 就是左右子树上的 p 和 q 的公共祖先节点）</li>
<li>如果<strong>左子树为空</strong>，<strong>右子树不为空</strong>，则右子树上有 p 或 q（或者都有），左子树上肯定没有 p 和 q，返回 right（right 就是右子树递归向下寻找到的那个等于 p 或 q 的节点，或者是二者的某个祖先节点，该节点被一路向上返回，直到得到答案）</li>
<li>如果<strong>右子树为空</strong>，<strong>左子树不为空</strong>，则左子树上有 p 或 q（或者都有），右子树上肯定没有 p 和 q，返回 left</li>
</ul>
<p>图解该过程：</p>
<img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211214214247676.png" alt="image-20211214214247676" style="zoom:67%;" />
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case，到底时返回null</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.val == root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q.val == root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="comment">// 共有四种情况</span></span><br><span class="line">    <span class="comment">// 1. left,right 都为空，则当前子树上不包含二者，直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 如果二者都不为空，则当前root即为二者的最近公共祖先，返回root</span></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 如果左子树为空，右子树不为空，则右子树上有p或q（或者都有），左子树上肯定没有p和q，返回right</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 如果右子树为空，左子树不为空，则左子树上有p或q（或者都有），右子树上肯定没有p和q，返回left</span></span><br><span class="line">    <span class="keyword">if</span> (right == <span class="keyword">null</span> &amp;&amp; left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 应该不会来到这里的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="方法二哈希表记录每个节点的父节点"   >
          <a href="#方法二哈希表记录每个节点的父节点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法二哈希表记录每个节点的父节点"></a> 方法二：哈希表记录每个节点的父节点</h4>
      
<p>思路：</p>
<ol>
<li>第一次遍历二叉树时，使用一个 <code>HashMap</code> 存放每个节点的头节点</li>
<li>然后借助于第一步获取的 <code>HashMap</code> 遍历 o1 的祖先节点们，使用一个 <code>HashSet</code> 存放 o1 节点的祖先节点（注意要包含 o1 自身）</li>
<li>最后遍历 o2 的祖先节点们，判断当前节点是否在第二步创建的 <code>HashSet</code> 里（注意要包含 o2 自身），如果在，说明该节点就是二者的最低公共祖先</li>
</ol>
<p>需要注意步骤2,3里存储 o1 的祖先节点时需要将 o1 自身也存进去，遍历 o2 的祖先节点时需要将 o2 也进行判断。这是为了在 o1、o2 在同一条链上时不会漏掉 o1 或 o2 自身。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">lowestCommonAncestor</span><span class="params">(Node head, Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先将头结点自身添加到 map 中，设置头结点为自己</span></span><br><span class="line">    Map&lt;Node, Node&gt; fatherMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    fatherMap.put(head, head);</span><br><span class="line"></span><br><span class="line">    process(head, fatherMap);</span><br><span class="line"></span><br><span class="line">    Set&lt;Node&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Node curr = o1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先将自身添加到 set1 里，避免 o1 就是 o2 祖先节点时漏放 o1 造成出错</span></span><br><span class="line">    <span class="comment">// 注意：必须要把 o1 自身也加到 Set 里，不然如果出现 o1 和 o2 在同一条链上（例如 o1 是 o2 的祖先）的情况下</span></span><br><span class="line">    <span class="comment">// 如果 o1 自身没加到 Set 里，o2 在找祖先节点时就会漏掉 o1</span></span><br><span class="line">    set1.add(o1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 o1 开始向上沿着自己的父节点遍历，直到找到根节点 head（因为只有 head 的 father 等于自身）</span></span><br><span class="line">    <span class="keyword">while</span> (curr != fatherMap.get(curr)) &#123;</span><br><span class="line">        <span class="comment">// 先找到 curr 的父节点</span></span><br><span class="line">        <span class="comment">// 然后不断将 o1 的祖先结点们添加到 set1 中，直到最后将 head 添加进去</span></span><br><span class="line">        curr = fatherMap.get(curr);</span><br><span class="line">        set1.add(curr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面那种顺序就不再需要将 head 添加到 set1 中，因为在临界条件时就已经加进去了</span></span><br><span class="line">    <span class="comment">// set1.add(head);</span></span><br><span class="line"></span><br><span class="line">    curr = o2;</span><br><span class="line">    <span class="comment">// 开始遍历 o2 的祖先节点们（注意，遍历时要包括 o2 自己）</span></span><br><span class="line">    <span class="keyword">while</span> (curr != fatherMap.get(curr)) &#123;</span><br><span class="line">        <span class="comment">// 下面两句顺序不能反，必须先判断当前节点在不在 set1 里，因为可能 o2 就是其中的某一个节点</span></span><br><span class="line">        <span class="comment">// 如果顺序反了，就漏掉了 o2</span></span><br><span class="line">        <span class="keyword">if</span> (set1.contains(curr))</span><br><span class="line">            <span class="keyword">return</span> curr;</span><br><span class="line">        curr = fatherMap.get(curr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Node head, Map&lt;Node, Node&gt; fatherMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前节点的左右孩子节点添加到 map 中</span></span><br><span class="line">    <span class="keyword">if</span> (head.left != <span class="keyword">null</span>)</span><br><span class="line">        fatherMap.put(head.left, head);</span><br><span class="line">    <span class="keyword">if</span> (head.right != <span class="keyword">null</span>)</span><br><span class="line">        fatherMap.put(head.right, head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归，令子节点也添加自己的左右孩子节点到 map 中</span></span><br><span class="line">    process(head.left, fatherMap);</span><br><span class="line">    process(head.right, fatherMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="寻找二叉树的后继节点"   >
          <a href="#寻找二叉树的后继节点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#寻找二叉树的后继节点"></a> 寻找二叉树的后继节点</h3>
      

        <h4 id="方法一中序遍历-存储节点到-list-中"   >
          <a href="#方法一中序遍历-存储节点到-list-中" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法一中序遍历-存储节点到-list-中"></a> 方法一：中序遍历 + 存储节点到 List 中</h4>
      
<p>简单的想法是在中序遍历的过程中将每个节点保存到一个 List 中，然后再在该 List 里找到其下一个节点即为其后继节点。但是代价是时间复杂度为 O(N)，并且空间复杂度也为 O(N)。</p>

        <h4 id="方法二借助父节点"   >
          <a href="#方法二借助父节点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法二借助父节点"></a> 方法二：借助父节点</h4>
      
<p>如果已知每一个节点的父节点，那么其实目标节点寻找距离自己 K 单位的后继节点所耗费的时间复杂度可以优化到 O(K)。</p>
<p>共有三种情况：</p>
<ul>
<li>目标节点有右孩子：此时目标节点的右孩子所在的<strong>右子树上最左边的节点</strong>就是当前节点的后继节点，对应下图中的情况1</li>
<li>目标节点没有右孩子：则一直向上遍历他的父节点，直到<strong>当前节点是其父节点的左孩子</strong>，则这个父节点就是目标节点的后继节点，对应下图中的情况2</li>
<li>目标节点是整棵树最右侧的节点：其后继节点为 null，对应下图中的情况2中的黄色节点</li>
</ul>
<p>图解：</p>
<p><img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/%E5%B9%BB%E7%81%AF%E7%89%871-1634726617676.PNG" alt="幻灯片1" /></p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传参只需要待求的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getSuccessorNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 如果目标节点有右孩子，则右孩子所在的右子树上最左边的节点就是 node 的后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getLeftMostNode(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 如果目标节点没有右孩子，则一直向上遍历他的父节点，直到当前节点是其父节点的左孩子</span></span><br><span class="line">    <span class="comment">//    这种情况对应了 while 循环里的第二条判断条件，当其满足时即找到了后继节点</span></span><br><span class="line">    <span class="comment">// 3. 同样包括了第三种情况：node 为整棵树最右的那个节点，其后继节点为 null，</span></span><br><span class="line">    <span class="comment">//    这种情况对应了 while 循环里的第一条判断条件，当其满足时，node 就是 head，最后 return head.parent == null</span></span><br><span class="line">    <span class="keyword">while</span> (node.parent != <span class="keyword">null</span> &amp;&amp; node != node.parent.left) &#123;</span><br><span class="line">        node = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意要返回的是 parent 而不是 node，因为他跳出 while 循环时，node 是要求的后继节点的左孩子</span></span><br><span class="line">    <span class="comment">// 需要返回 node.parent</span></span><br><span class="line">    <span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找子树上的最左节点，不需要递归，直接一直找左孩子即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLeftMostNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="翻转二叉树"   >
          <a href="#翻转二叉树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#翻转二叉树"></a> 翻转二叉树</h3>
      
<p><strong>翻转的本质是：交换每个节点的左右孩子</strong>。</p>

        <h4 id="方法一递归-交换左右孩子"   >
          <a href="#方法一递归-交换左右孩子" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法一递归-交换左右孩子"></a> 方法一：递归 + 交换左右孩子</h4>
      
<p>在递归时，不断交换当前节点的左右孩子节点，如此下去，最后就完成了整棵树的翻转。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">invertTree</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归函数的终止条件，节点为空时返回</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面三句是将当前节点的左右子树交换</span></span><br><span class="line">    Node tmp = root.right;</span><br><span class="line">    root.right = root.left;</span><br><span class="line">    root.left = tmp;</span><br><span class="line">    <span class="comment">//递归交换当前节点的 左子树</span></span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    <span class="comment">//递归交换当前节点的 右子树</span></span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="comment">//函数返回时就表示当前这个节点，以及它的左右子树</span></span><br><span class="line">    <span class="comment">//都已经交换完了</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="方法二层次遍历-交换左右孩子"   >
          <a href="#方法二层次遍历-交换左右孩子" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法二层次遍历-交换左右孩子"></a> 方法二：层次遍历 + 交换左右孩子</h4>
      
<p>也可以使用层次遍历。在层次遍历的过程中，先将当前节点的左右孩子进行交换，然后再放入队列中。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">invertTree</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素</span></span><br><span class="line">    LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//每次都从队列中拿一个节点，并交换这个节点的左右子树</span></span><br><span class="line">        Node tmp = queue.poll();</span><br><span class="line">        Node left = tmp.left;</span><br><span class="line">        tmp.left = tmp.right;</span><br><span class="line">        tmp.right = left;</span><br><span class="line">        <span class="comment">//如果当前节点的左子树不为空，则放入队列等待后续处理</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(tmp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前节点的右子树不为空，则放入队列等待后续处理</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回处理完的根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>该方法的空间复杂度会比第一种方法更大。</p>

        <h3 id="对称的二叉树"   >
          <a href="#对称的二叉树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对称的二叉树"></a> 对称的二叉树</h3>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" >https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/ebf894b723530a89cc9a1fe099f36c57c584d4987b080f625b33e228c0a02bec-Picture1.png" alt="img" style="zoom: 50%;" />
<p>思路：递归时每次传入一对节点（这两个节点是位置对称的），例如传入 L.left  和 R.right；另一个递归方法传入 L.right 和 R.left。这样保证每次递归方法里的节点都是位置对称的，因此只需要判断这两个节点的值是否相同即可。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recur(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode leftSubTree, TreeNode rightSubTree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 判断 leftSubTree ?= rightSubTree</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这两个判断不需要在当前层进行，将会在下一层进行比较</span></span><br><span class="line">        <span class="comment">// 2. 判断 leftSubTree.left ?= rightSubTree.right</span></span><br><span class="line">        <span class="comment">// 3. 判断 leftSubtree.right ?= rightSubTree.left </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一对一对的递归，递归时判断这一对是不是对称的</span></span><br><span class="line">        <span class="comment">// 如果所有对都是对称的，整体就是对称的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftSubTree == <span class="keyword">null</span> || rightSubTree == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftSubTree == rightSubTree ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 判断当前的这一对对称位置的节点是否值相等</span></span><br><span class="line">        <span class="keyword">if</span> (leftSubTree.val != rightSubTree.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将两对对称的节点继续递归</span></span><br><span class="line">        <span class="keyword">return</span> recur(leftSubTree.left, rightSubTree.right) &amp;&amp; recur(leftSubTree.right, rightSubTree.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="树的子结构"   >
          <a href="#树的子结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#树的子结构"></a> 树的子结构</h3>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/" >https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>输入两棵二叉树A和B，判断B是不是A的子结构。（约定空树不是任意一个树的子结构）</p>
<p>B是A的子结构， 即A中有出现和B相同的结构和节点值。</p>
<img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211202111942469.png" alt="image-20211202111942469" style="zoom: 67%;" />
<p>思路：双递归，一个递归寻找A中哪个节点与B树的根节点相同；另一个递归在找到相同的节点后开始深入A的当前局部子树进行递归。示意图：</p>
<img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/27d9f65b79ae4982fb58835d468c2a23ec2ac399ba5f38138f49538537264d03-Picture1.png" alt="img" style="zoom: 50%;" />
<p>算法流程：</p>
<blockquote>
<p>名词规定：<strong>树 A*A*</strong> 的根节点记作 <strong>节点 A*A*</strong> ，<strong>树 B*B*</strong> 的根节点称为 <strong>节点 B*B*</strong> 。</p>
</blockquote>
<p><strong><code>recur(A, B)</code> 函数：</strong></p>
<ul>
<li>终止条件：
<ul>
<li>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true</li>
<li>当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false</li>
<li>当节点 A 和 B 的值不同：说明匹配失败，返回 false</li>
</ul>
</li>
<li>返回值：
<ul>
<li>判断 A 和 B 的左子节点是否相等，即 <code>recur(A.left, B.left)</code></li>
<li>判断 A 和 B 的右子节点是否相等，即 <code>recur(A.right, B.right)</code></li>
</ul>
</li>
</ul>
<p><strong><code>isSubStructure(A, B)</code> 函数：</strong></p>
<ul>
<li>特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false</li>
<li>返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 || 连接
<ul>
<li>以 节点 A 为根节点的子树 包含树 BB ，对应 <code>recur(A, B)</code></li>
<li>树 B 是 树 A 左子树 的子结构，对应 <code>isSubStructure(A.left, B)</code></li>
<li>树 B 是 树 A 右子树 的子结构，对应 <code>isSubStructure(A.right, B)</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>以上 <code>2.</code> <code>3.</code> 实质上是在对树 A<em>A</em> 做 <strong>先序遍历</strong> 。</p>
</blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度 O(MN) ： 其中 M,N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 <code>recur(A, B)</code>判断占用 O(N) 。</li>
<li>空间复杂度 O(M)： 当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M ≤ N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M&gt;N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题解：简洁形式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (A != <span class="keyword">null</span> &amp;&amp; B != <span class="keyword">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果B为空，说明B遍历到底了，当前分支下是相同的子结构，递归返回开始判断其他分支是否也是相同子结构</span></span><br><span class="line">    <span class="keyword">if</span>(B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果B不为空，但A为空；或者B和A的值不同，说明B不是A的子结构</span></span><br><span class="line">    <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 只有在左子树和右子树都为true才说明整体也是true</span></span><br><span class="line">    <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我自己的：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A == <span class="keyword">null</span> || B == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意是判断 值 是否相同，而不是节点是否相同</span></span><br><span class="line">    <span class="comment">// 并且注意，不能直接返回！！因为可能目标位置很靠下，在书的上层就有一个A和值和B的值相同，如果在这里就返回了，就会漏掉下面的正确结构，直接返回false了，就错误了</span></span><br><span class="line">    <span class="keyword">if</span> (A.val == B.val) &#123;</span><br><span class="line">        res |= f(A, B);</span><br><span class="line">    &#125;    </span><br><span class="line">    res |= isSubStructure(A.left, B);</span><br><span class="line">    res |= isSubStructure(A.right, B);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 上面这几行也可以写成：</span></span><br><span class="line">    <span class="comment">// 1. 当前A位置组成的子树是否包含B树 || 2. 当前左子树是否包含B树 || 3. 当前右子树是否包含B树</span></span><br><span class="line">    <span class="keyword">return</span> f(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">    <span class="comment">// 按照树形DP的模板套路可以理解为：</span></span><br><span class="line">    <span class="comment">//    1. 考虑当前节点A的情况：f(A, B)</span></span><br><span class="line">    <span class="comment">//    2. 不考虑当前节点A的情况：</span></span><br><span class="line">    <span class="comment">//       2.1 左子树是否满足 isSubStructure(A.left, B)</span></span><br><span class="line">    <span class="comment">//       2.2 右子树是否满足 isSubStructure(A.right, B)  </span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 再精简一下就是：    </span></span><br><span class="line">    <span class="comment">// return (A != null &amp;&amp; B != null) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(TreeNode a, TreeNode b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// a为空说明走到底了，但是b又不为空，说明不是子结构返回false</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二者如果不相等，说明肯定不是子结构（因为b能进这层循环就不为空，a经过前面判断也不为空，则说明a和b都有值也不相等，则不是子结构）</span></span><br><span class="line">    <span class="keyword">if</span> (a.val != b.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        res &amp;= f(a.left, b.left);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (b.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        res &amp;= f(a.right, b.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="二叉树中和为某一值的路径"   >
          <a href="#二叉树中和为某一值的路径" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二叉树中和为某一值的路径"></a> 二叉树中和为某一值的路径</h3>
      
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" >剑指 Offer 34. 二叉树中和为某一值的路径</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>：给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有从根节点到叶子节点 路径总和等于给定目标和的路径。叶子节点是指没有子节点的节点。</p>
<img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211210110655646.png" alt="image-20211210110655646" style="zoom: 50%;" />

        <h4 id="方法一深度优先遍历"   >
          <a href="#方法一深度优先遍历" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法一深度优先遍历"></a> 方法一：深度优先遍历</h4>
      
<ul>
<li><strong>前序遍历：</strong> 按照 “根、左、右” 的顺序，遍历树的所有节点。</li>
<li><strong>路径记录：</strong> 在先序遍历中，记录从根节点到当前节点的路径。当路径为 ① 根节点到叶节点形成的路径 <strong>且</strong> ② 各节点值的和等于目标值 <code>sum</code> 时，将此路径加入结果列表。</li>
</ul>
<blockquote>
<p>注意：记录路径时若直接执行 res.append(path) ，则是将 path 对象加入了 res ；后续 path 改变时， res 中的 path 对象也会随之改变。正确做法：res.append(list(path)) ，相当于复制了一个 path 并加入到 res 。</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">Deque&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    dfs(root, target);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先添加当前节点的值，代表来过当前节点</span></span><br><span class="line">    path.offerLast(root.val);</span><br><span class="line">    <span class="comment">// 更新target</span></span><br><span class="line">    target -= root.val;</span><br><span class="line">    <span class="comment">// 如果当前节点时叶子节点，且 target == 0，则找到了一条符合题意的分支，进行保存</span></span><br><span class="line">    <span class="comment">// 注意！！！保存时需要另外复制一份path，否则path其随着方法栈返回会被修改</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left, target);</span><br><span class="line">    dfs(root.right, target);</span><br><span class="line">    <span class="comment">// 左右子树遍历完后，记得删掉之前添加的值</span></span><br><span class="line">    path.pollLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="方法二广度优先搜索"   >
          <a href="#方法二广度优先搜索" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法二广度优先搜索"></a> 方法二：广度优先搜索</h4>
      
<p>也可以采用广度优先搜索的方式遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>
<p>为了节省空间，我们<strong>使用哈希表记录树中的每一个节点的父节点</strong>。每次找到一个满足条件的节点，我们就<strong>从该节点出发不断向父节点迭代</strong>，即可还原出从根节点到当前节点的路径。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">Map&lt;TreeNode, TreeNode&gt; map = <span class="keyword">new</span> HashMap&lt;TreeNode, TreeNode&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queueNode = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; queueSum = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    queueNode.offer(root);</span><br><span class="line">    queueSum.offer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queueNode.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queueNode.poll();</span><br><span class="line">        <span class="keyword">int</span> rec = queueSum.poll() + node.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rec == target) &#123;</span><br><span class="line">                getPath(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                map.put(node.left, node);</span><br><span class="line">                queueNode.offer(node.left);</span><br><span class="line">                queueSum.offer(rec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                map.put(node.right, node);</span><br><span class="line">                queueNode.offer(node.right);</span><br><span class="line">                queueSum.offer(rec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPath</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        temp.add(node.val);</span><br><span class="line">        node = map.get(node);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(temp);</span><br><span class="line">    ret.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;(temp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="二叉搜索树的后序遍历序列"   >
          <a href="#二叉搜索树的后序遍历序列" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二叉搜索树的后序遍历序列"></a> 二叉搜索树的后序遍历序列</h3>
      
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" >剑指 Offer 33. 二叉搜索树的后序遍历序列</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<p>解决该问题的关键在于理解后序遍历在数组中的体现：</p>
<ul>
<li>根节点位置：后序遍历：在数组的<strong>最后一个</strong>位置</li>
<li>左右子树的分布特点：后序遍历：左 -&gt; 右 -&gt; 根</li>
</ul>
<p>因此重点在于<strong>如何确定左右子树间的边界</strong>。</p>

        <h4 id="方法一递归分治"   >
          <a href="#方法一递归分治" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法一递归分治"></a> 方法一：递归分治</h4>
      
<p>一种思路是：根据二叉搜索树的特点，左子树区间内的值都应该小于当前根节点值，右子树区间内的值都应该大于当前根节点值。那么从左往右遍历一遍数组，定位到：第一个大于根节点值的位置 m，则 [left, m - 1] 为左子树区间；[m, right - 1] 为右子树区间。然后继续在右子树区间内遍历，直到与 right 位置相遇。如果无法相遇则代表当前子树不符合；如果可以相遇则代表当前子树符合，那么接着开始递归判断左子树 [left, m - 1] 是否符合，右子树 [m, right - 1] 是否符合。</p>
<p>示意图：</p>
<img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211218190011688.png" alt="image-20211218190011688" style="zoom: 67%;" />
<img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211218190051540.png" alt="image-20211218190051540" style="zoom:67%;" />
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前子树的范围[left, right]，因为是后序遍历，所以当前子树的根节点必定是postorder[right]的值，</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">// 一直遍历到第一个大于postorder[right]的位置m，m-1就是当前根节点的左子树的根节点（子数组里的右边界right）</span></span><br><span class="line">        <span class="comment">// 1. 当前遍历的是左子树</span></span><br><span class="line">        <span class="keyword">while</span> (postorder[i] &lt; postorder[right]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录一下第一个大于根节点值的位置，该位置理论上来说是右子树的左边界（最左结点），m-1是左子树的右边界</span></span><br><span class="line">        <span class="keyword">int</span> m = i;</span><br><span class="line">        <span class="comment">// 2. 接着遍历右子树，如果是符合二叉搜索树，则肯定是都比rootValue大的，那么就能一直遍历到right</span></span><br><span class="line">        <span class="keyword">while</span> (postorder[i] &gt; postorder[right]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果i != right，则i没有能顺利遍历到right位置，说明肯定不是二叉搜索树（否则肯定能遍历到right位置）</span></span><br><span class="line">		<span class="comment">// 如果i == right，则当前以postorder[right]为根节点的子树是符合二叉搜索树的，接着开始递归判断该树的左右子树是否也是满足的</span></span><br><span class="line">        <span class="comment">// 根节点：right  左子树范围：[left, m - 1]，右子树范围：[m, right - 1]</span></span><br><span class="line">        <span class="keyword">return</span> i == right &amp;&amp; recur(postorder, left, m - <span class="number">1</span>) &amp;&amp; recur(postorder, m, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="方法二单调栈"   >
          <a href="#方法二单调栈" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法二单调栈"></a> 方法二：单调栈</h4>
      

        <h4 id="方法三倒序重建"   >
          <a href="#方法三倒序重建" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法三倒序重建"></a> 方法三：倒序重建</h4>
      
<p>可以尝试倒序重建整棵二叉树，如果重建过程中发现不符合就返回 false。当然不是重建出整棵树的结构，而是判断当前根节点（当前子数组的最后一个节点）是否在合适区间内：</p>
<ul>
<li>当前根节点的右子树的根节点的值应该大于当前的值且小于最大值</li>
<li>当前根节点的左子树的根节点的值应该小于当前的值且大于最小值</li>
</ul>
<p>参考的 python 代码：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">postorder: List[<span class="built_in">int</span>], ma: <span class="built_in">int</span>, mi: <span class="built_in">int</span></span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> postorder: <span class="keyword">return</span></span><br><span class="line">            val = postorder[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> mi &lt; val &lt; ma: <span class="keyword">return</span></span><br><span class="line">            postorder.pop() <span class="comment"># 根</span></span><br><span class="line">            build(postorder, ma, val) <span class="comment"># 右</span></span><br><span class="line">            build(postorder, val, mi) <span class="comment"># 左</span></span><br><span class="line"></span><br><span class="line">        build(postorder, sys.maxsize, -sys.maxsize)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> postorder</span><br></pre></td></tr></table></div></figure>

        <h2 id="二叉树中序遍历的常见题目"   >
          <a href="#二叉树中序遍历的常见题目" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二叉树中序遍历的常见题目"></a> 二叉树中序遍历的常见题目</h2>
      

        <h3 id="模板"   >
          <a href="#模板" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#模板"></a> 模板</h3>
      
<p>许多二叉树问题都可以使用中序遍历 + <code>pre</code> 变量的套路解决。在中序遍历的过程中，使用 <code>pre</code> 变量不断记录当前节点的前一个节点，从而解决问题。其中中序遍历的实现既可以使用递归栈又可以使用 Morris 遍历。</p>
<p><strong>模板一：递归</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pre 变量不断记录当前节点的前一个节点</span></span><br><span class="line"><span class="keyword">public</span> Node pre;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">template01</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(cur.left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 pre 已存在（后续的所有节点都符合该情况），则进行业务</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 此处进行具体业务：例如比较pre和curr的大小等</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果还未设置，此时到达整棵树的最左侧节点（中序遍历的第一个节点），将该节点设置为 pre</span></span><br><span class="line">        <span class="comment">// 记得更新pre</span></span><br><span class="line">        pre = curr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(cur.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>模板二：Morris 遍历</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">template</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node curr = root;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    Node pre = <span class="keyword">null</span>;</span><br><span class="line">    Node head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从当前节点的左子树开始找最右节点</span></span><br><span class="line">        mostRight = curr.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != curr) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 第一次来到mostRight和节点A，建立线索</span></span><br><span class="line">                mostRight.right = curr;</span><br><span class="line">                <span class="comment">// 开始遍历左子树</span></span><br><span class="line">                curr = curr.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == curr) &#123;</span><br><span class="line">                <span class="comment">// 第二次来到mostRight和节点A</span></span><br><span class="line">                <span class="comment">// 断开线索</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// =========================================================</span></span><br><span class="line">        <span class="comment">// 上面都是 Morris 的标准模板，从下面开始才加入 pre 相关的代码</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 具体业务</span></span><br><span class="line">            <span class="comment">// 记得更新pre</span></span><br><span class="line">            pre = curr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 更新pre</span></span><br><span class="line">            pre = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// =========================================================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Morris 遍历标准模板：</span></span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="二叉搜索树与双向链表"   >
          <a href="#二叉搜索树与双向链表" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二叉搜索树与双向链表"></a> 二叉搜索树与双向链表</h3>
      
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" >剑指 Offer 36. 二叉搜索树与双向链表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211210212721807.png" alt="image-20211210212721807" style="zoom: 50%;" />

        <h4 id="方法一递归-2"   >
          <a href="#方法一递归-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法一递归-2"></a> 方法一：递归</h4>
      
<p>在</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node pre, head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList01</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    head.left = pre;</span><br><span class="line">    pre.right = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(cur.left);</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="keyword">null</span>) pre.right = cur;</span><br><span class="line">    <span class="keyword">else</span> head = cur;</span><br><span class="line">    cur.left = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    dfs(cur.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="方法二morris-遍历"   >
          <a href="#方法二morris-遍历" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法二morris-遍历"></a> 方法二：Morris 遍历</h4>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList02</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node curr = root;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    Node pre = <span class="keyword">null</span>;</span><br><span class="line">    Node head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从当前节点的左子树开始找最右节点</span></span><br><span class="line">        mostRight = curr.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != curr) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 第一次来到mostRight和节点A，建立线索</span></span><br><span class="line">                mostRight.right = curr;</span><br><span class="line">                <span class="comment">// 开始遍历左子树</span></span><br><span class="line">                curr = curr.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == curr) &#123;</span><br><span class="line">                <span class="comment">// 第二次来到mostRight和节点A</span></span><br><span class="line">                <span class="comment">// 断开线索</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 前后节点建立线索</span></span><br><span class="line">            pre.right = curr;</span><br><span class="line">            curr.left = pre;</span><br><span class="line">            <span class="comment">// 记得更新pre</span></span><br><span class="line">            pre = curr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 更新pre</span></span><br><span class="line">            pre = curr;</span><br><span class="line">            <span class="comment">// 第一次到的节点被标记为head</span></span><br><span class="line">            head = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出循环时，pre指向树的最后一个节点</span></span><br><span class="line">    pre.right = head;</span><br><span class="line">    head.left = pre;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="方法三树形-dp"   >
          <a href="#方法三树形-dp" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法三树形-dp"></a> 方法三：树形 DP</h4>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node mostLeft;</span><br><span class="line">    <span class="keyword">public</span> Node mostRight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnData</span><span class="params">(Node left, Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mostLeft = left;</span><br><span class="line">        <span class="keyword">this</span>.mostRight = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList01</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先找到整棵树的最左侧节点</span></span><br><span class="line">    globalRoot = root;</span><br><span class="line">    head = root;</span><br><span class="line"></span><br><span class="line">    recur(root);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node globalRoot;</span><br><span class="line"><span class="keyword">public</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReturnData <span class="title">recur</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReturnData leftReturn = recur(root.left);</span><br><span class="line">    ReturnData rightReturn = recur(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取左子树的最左节点和右子树的最右节点</span></span><br><span class="line">    Node currMostLeft = leftReturn.mostLeft;</span><br><span class="line">    Node currMostRight = rightReturn.mostRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左子树的最右节点要和当前节点建立线索</span></span><br><span class="line">    <span class="keyword">if</span> (leftReturn.mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">        leftReturn.mostRight.right = root;</span><br><span class="line">        root.left = leftReturn.mostRight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右子树的最左节点要和当前节点建立线索</span></span><br><span class="line">    <span class="keyword">if</span> (rightReturn.mostLeft != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rightReturn.mostLeft.left = root;</span><br><span class="line">        root.right = rightReturn.mostLeft;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子树不存在，则当前子树的最左节点就是自身</span></span><br><span class="line">    <span class="keyword">if</span> (leftReturn.mostLeft == <span class="keyword">null</span>) &#123;</span><br><span class="line">        currMostLeft = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果右子树不存在，则当前子树的最右节点就是自身</span></span><br><span class="line">    <span class="keyword">if</span> (rightReturn.mostRight == <span class="keyword">null</span>) &#123;</span><br><span class="line">        currMostRight = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点等于根节点，则将当前整棵树的最左节点和最右节点串起来</span></span><br><span class="line">    <span class="comment">// 注意这里要用整棵树的最左和最右节点，因为可能左子树的最左节点是空，无法.left</span></span><br><span class="line">    <span class="keyword">if</span> (root == globalRoot) &#123;</span><br><span class="line">        head = currMostLeft;</span><br><span class="line">        currMostLeft.left = currMostRight;</span><br><span class="line">        currMostRight.right = currMostLeft;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前子树的最左节点和最右节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(currMostLeft, currMostRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="恢复二叉搜索树"   >
          <a href="#恢复二叉搜索树" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#恢复二叉搜索树"></a> 恢复二叉搜索树</h3>
      
<p>给你二叉搜索树的根节点 <code>root</code> ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。示例：</p>
<p><img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/recover1.jpg" alt="img" /></p>

        <h4 id="方法一递归中序遍历"   >
          <a href="#方法一递归中序遍历" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法一递归中序遍历"></a> 方法一：递归中序遍历</h4>
      
<p>这道题的关键在于正确的分析错误的两个点的位置。例如 [1, 2, 3, 4, 5, 6, 7] 被交换成了 [1, 6, 3, 4, 5, 2, 7]，当中序遍历时，不断判断当前 i 是否大于 i+1</p>
<ul>
<li>如果是，则记录 i 是那个较大的错误点，即 index2，i+1 不是错误点（这点不能乱，错误的是 i，不是i+1）。</li>
<li>当再次发现 i &gt; i+1 时，即 5 &gt; 2，此时错误的就不是 i 了，而是 i+1，这个点就是 index1 。</li>
<li>最后交换 index1 和 index2</li>
</ul>
<p>具体实现：只需要在中序遍历的时候不断记录 pred 点（i），比较当前点（i+1）的值。如果pred更大，说明他就是 index2。再找下去，pred 再次大于 curr 时，curr 就是 index1。最后做交换即可</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode errorRoot;</span><br><span class="line">    <span class="keyword">public</span> TreeNode errorcChild;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode pred; <span class="comment">// 当前节点的前辈节点（中序遍历的上一个）</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode node01;</span><br><span class="line">    <span class="keyword">public</span> TreeNode node02;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在递归的时候如果找到了 curr 所在子树不满足</span></span><br><span class="line">        <span class="comment">// 递归时，记录左右子树上的最小值和最大值的节点对象</span></span><br><span class="line">        <span class="comment">// 将 curr 的值与其交换即可</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 官方方法一：中序遍历时记录前一个节点pre，并比较pre和当前节点curr的大小，若发现pre&gt;curr，则记录pre，第二次记录curr</span></span><br><span class="line">        <span class="comment">// 之所以这么定，是因为一个数组里交换两个数字后，第一个错误的数字是大于后面的数字的，第二个则是前一个大于当前的，所以两次取，一次是pre，一次是curr</span></span><br><span class="line">        inOrderRecurr(root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换错误的两个节点</span></span><br><span class="line">        <span class="keyword">int</span> tmp = node01.val;</span><br><span class="line">        node01.val = node02.val;</span><br><span class="line">        node02.val = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderRecurr</span><span class="params">(TreeNode curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inOrderRecurr(curr.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要放在中序遍历的位置</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span> &amp;&amp; pred.val &gt; curr.val) &#123;</span><br><span class="line">            <span class="comment">// 成立时代表是第二次发现有异常条件，说明该赋值给node02 = curr</span></span><br><span class="line">            <span class="keyword">if</span> (--count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 若能进来，说明两个错误的节点是不相邻的，则更新后者为 curr</span></span><br><span class="line">                node02 = curr;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则说明是第一次来到当前节点，说明赋值给node01 = pred</span></span><br><span class="line">                node01 = pred;</span><br><span class="line">                <span class="comment">// 并且需要将 curr 赋值给 node02，以免相邻两个数交换时</span></span><br><span class="line">                <span class="comment">// count 只会减一次，永远不会进入上面</span></span><br><span class="line">                <span class="comment">// 这里赋值就能记录到错误交换的两个节点</span></span><br><span class="line">                node02 = curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意要在第二次回到当前节点时（中序遍历的顺序）将pred更新</span></span><br><span class="line">        <span class="comment">// 接下来遍历其右子树时，pred就更新为了当前节点</span></span><br><span class="line">        pred = curr;</span><br><span class="line"></span><br><span class="line">        inOrderRecurr(curr.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="方法二morris-中序遍历"   >
          <a href="#方法二morris-中序遍历" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#方法二morris-中序遍历"></a> 方法二：Morris 中序遍历</h4>
      
<p>对于这种跟中序遍历相关的题目，可以考虑使用 Morris 中序遍历降低空间复杂度。思路同样是在中序遍历的过程中，比较 pred 与 curr 的大小。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    TreeNode mostRight;</span><br><span class="line">    TreeNode x = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode y = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode pred = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostRight = curr.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != curr) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mostRight.right = curr;</span><br><span class="line">                curr = curr.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 中序遍历第二次到达当前节点 A 时回来到这里，并顺利到达下面的 if 外的代码，第一次遍历会被continue给打断</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里是 Morris 中序遍历的位置，在这里判断即可</span></span><br><span class="line">        <span class="comment">// 假设正确的顺序是 ... x ... y ...</span></span><br><span class="line">        <span class="comment">// 那么交换后是    ... y ... x ...，</span></span><br><span class="line">        <span class="comment">// y 要设置为 pred，并且只设置一次；x 要设置为 curr，需要设置两次（为了应对xy挨着的情况）</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span> &amp;&amp; pred.val &gt; curr.val) &#123;</span><br><span class="line">            x = curr;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="keyword">null</span>) &#123;</span><br><span class="line">                y = pred;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新pred和curr</span></span><br><span class="line">        pred = curr;</span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换 x y</span></span><br><span class="line">    <span class="keyword">int</span> tmp = x.val;</span><br><span class="line">    x.val = y.val;</span><br><span class="line">    y.val = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="树型动态规划问题"   >
          <a href="#树型动态规划问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#树型动态规划问题"></a> 树型动态规划问题</h2>
      

        <h3 id="模板套路"   >
          <a href="#模板套路" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#模板套路"></a> 模板套路</h3>
      
<p>符合模板套路的特点：可以通过当前节点向左右子树索要一些信息（例如节点数，层数等），从而递归地解决问题。</p>
<p>模板：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">f</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据具体场景返回相应的值</span></span><br><span class="line">        <span class="keyword">return</span> ReturnData(xx, xx, xx);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先获取左右子树上的返回值</span></span><br><span class="line">    ReturnData leftReturnData = f(head.left);</span><br><span class="line">    ReturnData rightReturnData = f(head.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行判断处理等，例如将 boolean 类型值设置为 true 或 false，设置最大最小值等</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在最后将设置好的值封装成 ReturnData 并向上返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(xx, xx, xx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>一些问题需要在当前子树上进行分类：<strong>考虑当前节点</strong>或<strong>不考虑当前节点</strong>两种情况，分别计算两种情况中的最优解，进行返回。</p>

        <h3 id="叉树节点间的最大距离问题"   >
          <a href="#叉树节点间的最大距离问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#叉树节点间的最大距离问题"></a> 叉树节点间的最大距离问题</h3>
      
<p>从二叉树的节点a出发，可以向上或者向下走，但沿途的节点只能经过一次，到达节点b时路径上的节点个数叫作a到b的距离，那么二叉树任何两个节点之间都有距离，求整棵树上的最大距离。</p>
<p>当前子树的最大距离分两种情况：</p>
<ul>
<li>考虑当前节点时：最大距离为左子树的高度 + 右子树高度 + 1</li>
<li>不考虑当前节点时：最大距离为左子树上的最大距离或右子树上的最大距离</li>
</ul>
<p>最后返回二者中的最大值。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxDistance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnData</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前子树的高度</span></span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">        <span class="comment">// 当前子树上的最长路径</span></span><br><span class="line">        <span class="keyword">int</span> maxLength;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReturnData</span><span class="params">(<span class="keyword">int</span> height, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">            <span class="keyword">this</span>.maxLength = count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ReturnData res = process(root);</span><br><span class="line">        <span class="keyword">return</span> res.maxLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">process</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先得到左右子树上的信息</span></span><br><span class="line">        ReturnData leftReturn = process(root.left);</span><br><span class="line">        ReturnData rightReturn = process(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先更新当前子树的最大高度</span></span><br><span class="line">        <span class="keyword">int</span> currHeight = Math.max(leftReturn.height, rightReturn.height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 考虑当前节点, 即最长路径包含当前节点</span></span><br><span class="line">        <span class="comment">// 最长路径为: 从左子树上的某个节点一路连接经过当前节点, 到右子树上的另一个节点</span></span><br><span class="line">        <span class="comment">// 最长路径为: 左子树的高度 + 右子树的高度 + 1</span></span><br><span class="line">        <span class="keyword">int</span> length1 = leftReturn.height + rightReturn.height + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 不考虑当前节点, 即最长路径包含当前节点</span></span><br><span class="line">        <span class="comment">// 最长路径: 左右子树上的最长路径的最大值</span></span><br><span class="line">        <span class="keyword">int</span> length2 = Math.max(leftReturn.maxLength, rightReturn.maxLength);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取两种情况的最大值, 返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(currHeight, Math.max(length1, length2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="派对的最大快乐值"   >
          <a href="#派对的最大快乐值" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#派对的最大快乐值"></a> 派对的最大快乐值</h3>
      
<p><img src="/images/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/image-20211203151542500.png" alt="image-20211203151542500" /></p>
<p>情况：</p>
<ul>
<li>当前员工要来——其直接下级不能来</li>
<li>当前员工不来——其直接下级可以选择：来或不来</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHappyValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> happy; <span class="comment">// 这名员工可以带来的快乐值</span></span><br><span class="line">        List&lt;Employee&gt; subordinates; <span class="comment">// 这名员工有哪些直接下级</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnData</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> happyValue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReturnData</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.happyValue = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxHappyValue</span><span class="params">(Employee boss)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(recur(boss, <span class="keyword">true</span>), recur(boss, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recur</span><span class="params">(Employee curr, <span class="keyword">boolean</span> consider)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这里先判断是否有下级, 这样在下面代码里就不需要判断了</span></span><br><span class="line">        <span class="keyword">if</span> (curr.subordinates == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> consider ? curr.happy : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两种情况: 1. 考虑当前员工  2. 不考虑当前员工</span></span><br><span class="line">        <span class="comment">// 1. 如果考虑当前员工</span></span><br><span class="line">        <span class="keyword">if</span> (consider) &#123;</span><br><span class="line">            p1 += curr.happy;</span><br><span class="line">            <span class="comment">// 判断当前员工有无下级:</span></span><br><span class="line">            <span class="comment">// 如果有下级, 遍历所有下级, 同时不能考虑这些下级</span></span><br><span class="line">            <span class="keyword">for</span> (Employee subordinate : curr.subordinates) &#123;</span><br><span class="line">                p1 += recur(subordinate, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 如果不考虑当前员工</span></span><br><span class="line">            <span class="comment">// 遍历所有下级, 同时要考虑这些下级</span></span><br><span class="line">            <span class="keyword">for</span> (Employee subordinate : curr.subordinates) &#123;</span><br><span class="line">                p2 += recur(subordinate, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存下级, 要用 list 存储, 一对多</span></span><br><span class="line">    <span class="comment">// 如果存上级, 就只用一个常数, 多对一</span></span><br><span class="line">    <span class="comment">// dp[][]的形式：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxHappy</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</span><br><span class="line">        <span class="comment">// matrix[0]: 当前员工的上级编号</span></span><br><span class="line">        <span class="comment">// 先找出 root 是谁</span></span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == matrix[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                root = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        process(matrix, dp, visited, root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[root][<span class="number">0</span>], dp[root][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[][] dp, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 来到了root, 计算其值后, 就在表中缓存来到过当前位置, 其他分支就不需要再次访问当前位置了</span></span><br><span class="line">        visited[root] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// dp[x][0]: 不考虑当前员工</span></span><br><span class="line">        <span class="comment">// dp[x][1]: 考虑当前员工</span></span><br><span class="line">        <span class="comment">// 考虑当前员工root时, 先初始化上matrix中其对应的快乐值</span></span><br><span class="line">        dp[root][<span class="number">1</span>] = matrix[root][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每一个员工, 判断是否为传入的root的下级(如果用树结构, 就是直接获取 list, 不用遍历)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前员工的上级等于传入的root, 并且当前员工没考虑过(还没遍历到)</span></span><br><span class="line">            <span class="comment">// 就递归当前员工root的下级, 更新root的快乐值</span></span><br><span class="line">            <span class="comment">// 这里的visited就是用来缓存的, 避免重复计算i</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == root &amp;&amp; !visited[i]) &#123;</span><br><span class="line">                <span class="comment">// 如果还没计算过i, 就先去计算i的情况, 算完后再回来算i的上级root</span></span><br><span class="line">                process(matrix, dp, visited, i);</span><br><span class="line">                <span class="comment">// 1. 更新 &quot;当前员工i的上级员工root&quot; 考虑自身时的快乐值</span></span><br><span class="line">                <span class="comment">// 考虑root时, 下级i的快乐值就不能算上, 所以要加上下级dp[i][0]: &quot;不考虑自身时的快乐值&quot;</span></span><br><span class="line">                dp[root][<span class="number">1</span>] += dp[i][<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 2. 更新 root 不考虑自身时的快乐值</span></span><br><span class="line">                <span class="comment">// 不考虑自身, 要取 &quot;考虑下级&quot; 和 &quot;不考虑下级&quot; 中的最大值</span></span><br><span class="line">                dp[root][<span class="number">0</span>] += Math.max(dp[i][<span class="number">1</span>], dp[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">8</span> &#125;, &#123; <span class="number">1</span>, <span class="number">9</span> &#125;, &#123; <span class="number">1</span>, <span class="number">10</span> &#125; &#125;;</span><br><span class="line">        System.out.println(maxHappy(matrix));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="二叉树的不同种类个数"   >
          <a href="#二叉树的不同种类个数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二叉树的不同种类个数"></a> 二叉树的不同种类个数</h3>
      
<p>给定一个非负整数n，代表二叉树的节点个数。返回能形成多少种不同的二叉树结构。</p>
<p>思路：当前位置作为根节点时，左子树的节点个数从 0 开始遍历一直到 n - 1，累加各种情况下当前子树的结构种类：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前子树上有n个节点的前提下：当左子树上有i个节点时, 右子树上有n-1-i个节点(要排除掉root)</span></span><br><span class="line">res += process(i, record) * process(n - <span class="number">1</span> - i, record);</span><br></pre></td></tr></table></div></figure>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOfTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfTree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process(n, record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] record)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// n: 当前子树上拥有的节点个数</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root = null</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// null &lt;- root -&gt; null</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left &lt;- root -&gt; null 或 null &lt;- root -&gt; right</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缓存表, 避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> (record[n] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> record[n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历决定当前节点的左子树上有多少个节点, 范围: 从0到n-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 当左子树上有i个节点时, 右子树上有n-1-i个节点(要排除掉root)</span></span><br><span class="line">            res += process(i, record) * process(n - <span class="number">1</span> - i, record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(numberOfTree(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://yuyun-zhao.github.io">yuyun zhao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://yuyun-zhao.github.io/2021/10/15/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/">http://yuyun-zhao.github.io/2021/10/15/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.github.io/tags/%E7%AE%97%E6%B3%95/">算法</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/10/17/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">【数据结构】图</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/10/10/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E9%93%BE%E8%A1%A8/"><span class="paginator-prev__text">【数据结构】链表</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">
           二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">
           前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F"><span class="toc-text">
           递归方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E5%80%9F%E5%8A%A9%E4%B8%80%E4%B8%AA%E6%A0%88%E7%BB%93%E6%9E%84"><span class="toc-text">
           非递归方式：借助一个栈结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">
           中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F-2"><span class="toc-text">
           递归方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E5%80%9F%E5%8A%A9%E4%B8%80%E4%B8%AA%E6%A0%88%E7%BB%93%E6%9E%84-2"><span class="toc-text">
           非递归方式：借助一个栈结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">
           后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F-3"><span class="toc-text">
           递归方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E5%80%9F%E5%8A%A9%E4%B8%A4%E4%B8%AA%E6%A0%88%E7%BB%93%E6%9E%84"><span class="toc-text">
           非递归方式：借助两个栈结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F-%E4%B8%AD%E5%BA%8F-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-text">
           前序、中序、后序遍历在数组中的体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-text">
           层次遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E4%B9%8B%E5%AD%97%E5%BD%A2%E8%BF%9B%E8%A1%8C%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-text">
           按照之字形进行层次遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#morris-%E9%81%8D%E5%8E%86"><span class="toc-text">
           Morris 遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-text">
           实现流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">
           算法复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">
           总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#morris-%E9%81%8D%E5%8E%86%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">
           Morris 遍历的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%89%93%E5%8D%B0%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">
           直观地打印一颗二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">
           几种特殊的二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">
           搜索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%90%8E%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%8D%87%E5%BA%8F"><span class="toc-text">
           方法一：中序遍历后，判断是否升序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E4%B8%8D%E6%96%AD%E4%BF%9D%E5%AD%98%E5%BD%93%E5%89%8D%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">
           方法二：中序遍历 + 不断保存当前最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89morris-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E4%B8%8D%E6%96%AD%E4%BF%9D%E5%AD%98%E5%BD%93%E5%89%8D%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">
           方法三：Morris 中序遍历 + 不断保存当前最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%9B%9B%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%A5%97%E8%B7%AF"><span class="toc-text">
           方法四：使用模板套路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">
           搜索二叉树的增删改查操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">
           完全二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-%E9%98%9F%E5%88%97"><span class="toc-text">
           方法一：层次遍历 + 队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">
           满二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-%E8%AE%B0%E5%BD%95%E5%B1%82%E6%95%B0%E4%B8%8E%E6%80%BB%E8%8A%82%E7%82%B9%E6%95%B0"><span class="toc-text">
           方法一：层次遍历 + 记录层数与总节点数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%A5%97%E8%B7%AF"><span class="toc-text">
           方法二：使用模板套路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">
           平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">
           将有序数组转换为二叉平衡搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#avl-%E6%A0%91%E5%8E%9F%E7%90%86"><span class="toc-text">
           AVL 树原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-text">
           二叉树的线索化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-text">
           自平衡二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%93%8D%E4%BD%9C-2"><span class="toc-text">
           搜索二叉树的增删改查操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E4%B8%8E%E5%8F%B3%E6%97%8B"><span class="toc-text">
           左旋与右旋</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#avl-%E6%A0%91%E7%9A%84%E8%87%AA%E5%B9%B3%E8%A1%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">
           AVL 树的自平衡实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%A4%A7%E5%B0%8F%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-text">
           节点大小平衡树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-text">
           红黑树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">
           二叉树的常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">
           树的序列化与反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">
           前序遍历序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">
           前序遍历反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">
           层次遍历序列化与反序列化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%A6%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-text">
           判断一颗二叉树是不是另一棵二叉树的子树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">
           求一颗二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92-%E6%A8%A1%E6%9D%BF%E6%80%9D%E6%83%B3"><span class="toc-text">
           方法一：递归 + 模板思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E9%80%92%E5%BD%92-%E8%AE%A1%E6%95%B0"><span class="toc-text">
           方法二：递归 + 计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-%E8%AE%A1%E6%95%B0"><span class="toc-text">
           方法三：层次遍历 + 计数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6"><span class="toc-text">
           求一颗二叉树的最大宽度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%BC%98%E5%8C%96"><span class="toc-text">
           层次遍历优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">
           重建二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">
           二叉搜索树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E8%BF%AD%E4%BB%A3"><span class="toc-text">
           方法一：迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E9%80%92%E5%BD%92"><span class="toc-text">
           方法二：递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">
           二叉树的最低公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92"><span class="toc-text">
           方法一：递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AE%B0%E5%BD%95%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E7%88%B6%E8%8A%82%E7%82%B9"><span class="toc-text">
           方法二：哈希表记录每个节点的父节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9"><span class="toc-text">
           寻找二叉树的后继节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%AD%98%E5%82%A8%E8%8A%82%E7%82%B9%E5%88%B0-list-%E4%B8%AD"><span class="toc-text">
           方法一：中序遍历 + 存储节点到 List 中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%80%9F%E5%8A%A9%E7%88%B6%E8%8A%82%E7%82%B9"><span class="toc-text">
           方法二：借助父节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">
           翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92-%E4%BA%A4%E6%8D%A2%E5%B7%A6%E5%8F%B3%E5%AD%A9%E5%AD%90"><span class="toc-text">
           方法一：递归 + 交换左右孩子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-%E4%BA%A4%E6%8D%A2%E5%B7%A6%E5%8F%B3%E5%AD%A9%E5%AD%90"><span class="toc-text">
           方法二：层次遍历 + 交换左右孩子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">
           对称的二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-text">
           树的子结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">
           二叉树中和为某一值的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-text">
           方法一：深度优先遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">
           方法二：广度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-text">
           二叉搜索树的后序遍历序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB"><span class="toc-text">
           方法一：递归分治</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-text">
           方法二：单调栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%E5%80%92%E5%BA%8F%E9%87%8D%E5%BB%BA"><span class="toc-text">
           方法三：倒序重建</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE"><span class="toc-text">
           二叉树中序遍历的常见题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-text">
           模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">
           二叉搜索树与双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92-2"><span class="toc-text">
           方法一：递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8Cmorris-%E9%81%8D%E5%8E%86"><span class="toc-text">
           方法二：Morris 遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%E6%A0%91%E5%BD%A2-dp"><span class="toc-text">
           方法三：树形 DP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">
           恢复二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">
           方法一：递归中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8Cmorris-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">
           方法二：Morris 中序遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98"><span class="toc-text">
           树型动态规划问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%A5%97%E8%B7%AF"><span class="toc-text">
           模板套路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98"><span class="toc-text">
           叉树节点间的最大距离问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E5%AF%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BF%AB%E4%B9%90%E5%80%BC"><span class="toc-text">
           派对的最大快乐值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8D%E5%90%8C%E7%A7%8D%E7%B1%BB%E4%B8%AA%E6%95%B0"><span class="toc-text">
           二叉树的不同种类个数</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/author.png" alt="avatar"></div><p class="sidebar-ov-author__text">no code no life</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YUYUN-ZHAO" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="zyy18749810683" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1024462136" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:im.yuyunzhao@gmail.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gmail</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">139</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">39</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">39</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>yuyun zhao</span><span class="footer__devider">|</span><span>沪ICP备2022000458号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>