<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="JVM 调优概述                             生产环境中的问题         生产环境发生了内存溢出该如何处理？ 生产环境应该给服务器分配多少内存合适？ 如何对垃圾回收器的性能进行调优？ 生产环境CPU负载飙高该如何处理？ 生产环境应该给应用分配多少线程合适？ 不加log，如何确定请求是否执行了某一行代码？ 不加log，如何实时查看某个方法的入">
<meta property="og:type" content="article">
<meta property="og:title" content="【JVM】JVM 监控及诊断工具">
<meta property="og:url" content="http://yuyun-zhao.github.io/2021/10/18/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/index.html">
<meta property="og:site_name" content="yuyun zhao&#39;s blog">
<meta property="og:description" content="JVM 调优概述                             生产环境中的问题         生产环境发生了内存溢出该如何处理？ 生产环境应该给服务器分配多少内存合适？ 如何对垃圾回收器的性能进行调优？ 生产环境CPU负载飙高该如何处理？ 生产环境应该给应用分配多少线程合适？ 不加log，如何确定请求是否执行了某一行代码？ 不加log，如何实时查看某个方法的入">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019194726602.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019194901811.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018143521569.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144605845.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144636311.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144724807.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144741353.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144811128.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144853740.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144920184.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144946904.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018145058532.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018145110053.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210517225915759.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018145358819.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210518090954961.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210518224426354.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210518224413517.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210518225518037.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211020110057297.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210518235707000.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519000148496.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519000756518.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519000816175.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519000835395.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519000848394.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519000900135.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519132440728.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519132543453.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519132722496.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519132711392.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018212421955.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018212430167.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018212443302.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018212452056.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210520235805487.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521093956938.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521145844721.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521145941114.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521150407870.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521150855253.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521153855310.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521154115936.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521154221915.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521154546655.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018213204845.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018213217786.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521154809697.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018213301773.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521195844113.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019183843470.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019183932731.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019183942592.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019183954641.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019184002347.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019184015271.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019184023306.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019184031773.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019184121880.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521233837255.png">
<meta property="og:image" content="https://gitee.com/tcl192243051/studyJVM/raw/master/4_%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%AF%87/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0.assets/image-20210521234011514.png">
<meta property="og:image" content="https://gitee.com/tcl192243051/studyJVM/raw/master/4_%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%AF%87/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0.assets/image-20210521234301291.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521234626600.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200713094745366.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211020104915344.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211020105935721.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714081610474.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714081622526.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714081909309.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714081925767.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714082555688.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714082714690.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714083332238.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714083526790.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714084726824.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714084921184.png">
<meta property="article:published_time" content="2021-10-18T04:12:18.000Z">
<meta property="article:modified_time" content="2021-10-23T02:36:06.218Z">
<meta property="article:author" content="yuyun zhao">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yuyun-zhao.github.io/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019194726602.png"><title>【JVM】JVM 监控及诊断工具 | yuyun zhao's blog</title><link ref="canonical" href="http://yuyun-zhao.github.io/2021/10/18/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">文章</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">yuyun zhao's blog</div><div class="header-banner-info__subtitle">no code no life</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">【JVM】JVM 监控及诊断工具</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-18</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-23</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">18.9k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">117分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h2 id="jvm-调优概述"   >
          <a href="#jvm-调优概述" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jvm-调优概述"></a> JVM 调优概述</h2>
      

        <h3 id="生产环境中的问题"   >
          <a href="#生产环境中的问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#生产环境中的问题"></a> 生产环境中的问题</h3>
      
<ul>
<li>生产环境发生了内存溢出该如何处理？</li>
<li>生产环境应该给服务器分配多少内存合适？</li>
<li>如何对垃圾回收器的性能进行调优？</li>
<li>生产环境CPU负载飙高该如何处理？</li>
<li>生产环境应该给应用分配多少线程合适？</li>
<li>不加log，如何确定请求是否执行了某一行代码？</li>
<li>不加log，如何实时查看某个方法的入参与返回值？</li>
</ul>

        <h3 id="为什么要调优"   >
          <a href="#为什么要调优" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#为什么要调优"></a> 为什么要调优</h3>
      
<ul>
<li>防止出现OOM</li>
<li>解决OOM</li>
<li>减少Full GC出现的频率</li>
</ul>
<p><strong>不同阶段的考虑</strong></p>
<ul>
<li>上线前</li>
<li>项目运行阶段</li>
<li>线上出现OOM</li>
</ul>

        <h3 id="调优概述"   >
          <a href="#调优概述" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调优概述"></a> 调优概述</h3>
      
<p><strong>监控的依据</strong></p>
<ul>
<li>运行日志</li>
<li>异常堆栈</li>
<li>GC日志</li>
<li>线程快照</li>
<li>堆转储快照</li>
</ul>
<p><strong>调优的大方向</strong></p>
<ul>
<li>合理地编写代码</li>
<li>充分并合理的使用硬件资源</li>
<li>合理地进行JVM调优</li>
</ul>

        <h3 id="性能优化的步骤"   >
          <a href="#性能优化的步骤" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#性能优化的步骤"></a> 性能优化的步骤</h3>
      
<p><strong>第1步：性能监控</strong></p>
<ul>
<li>GC频繁</li>
<li>cpu load过高</li>
<li>OOM</li>
<li>内存泄露</li>
<li>死锁</li>
<li>程序响应时间较长</li>
</ul>
<p><strong>第2步：性能分析</strong></p>
<ul>
<li>打印GC日志，通过GCviewer或者 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://gceasy.io" >http://gceasy.io</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 来分析异常信息</li>
<li>灵活运用命令行工具、jstack、jmap、jinfo等</li>
<li>dump出堆文件，使用内存分析工具分析文件</li>
<li>使用阿里Arthas、jconsole、JVisualVM来实时查看JVM状态</li>
<li>jstack查看堆栈信息</li>
</ul>
<p><strong>第3步：性能调优</strong></p>
<ul>
<li>适当增加内存，根据业务背景选择垃圾回收器</li>
<li>优化代码，控制内存使用</li>
<li>增加机器，分散节点压力</li>
<li>合理设置线程池线程数量</li>
<li>使用中间件提高程序效率，比如缓存、消息队列等</li>
</ul>
<span id="more"></span>

        <h3 id="性能评价测试指标"   >
          <a href="#性能评价测试指标" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#性能评价测试指标"></a> 性能评价/测试指标</h3>
      
<ul>
<li><strong>停顿时间（或响应时间）</strong>：提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。在垃圾回收环节中：
<ul>
<li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li>通过<code>-XX:MaxGCPauseMillis</code>参数进行设置</li>
</ul>
</li>
<li><strong>吞吐量</strong>：
<ul>
<li>对单位时间内完成的工作量（请求）的量度</li>
<li>在GC中：运行用户代码的事件占总运行时间的比例（总运行时间：程序的运行时间+内存回收的时间）</li>
<li>吞吐量为<code>1-1/(1+n)</code>，其中<code>-XX::GCTimeRatio=n</code></li>
</ul>
</li>
<li>并发数
<ul>
<li>同一时刻，对服务器有实际交互的请求数</li>
</ul>
</li>
<li>内存占用
<ul>
<li>Java堆区所占的内存大小</li>
</ul>
</li>
</ul>
<p>相互间的关系（以高速公路通行状况为例）：</p>
<ul>
<li>吞吐量：每天通过高速公路收费站的车辆的数据</li>
<li>并发数：高速公路上正在行驶的车辆的数目</li>
<li>响应时间：车速</li>
</ul>
<p>补充：常用操作的响应时间列表</p>
<div class="table-container"><table>
<thead>
<tr>
<th>操作</th>
<th>响应时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>打开一个站点</td>
<td>几秒</td>
</tr>
<tr>
<td>数据库查询一条记录（有索引）</td>
<td>十几毫秒</td>
</tr>
<tr>
<td>机械磁盘一次寻址定位</td>
<td>4毫秒</td>
</tr>
<tr>
<td>从机械磁盘顺序读取1M数据</td>
<td>2毫秒</td>
</tr>
<tr>
<td>从SSD磁盘顺序读取1M数据</td>
<td>0.3毫秒</td>
</tr>
<tr>
<td>从远程分布式换成Redis 读取一个数据</td>
<td>0.5毫秒</td>
</tr>
<tr>
<td>从内存读取 1M数据</td>
<td>十几微妙</td>
</tr>
<tr>
<td>Java程序本地方法调用</td>
<td>几微妙</td>
</tr>
<tr>
<td>网络传输2Kb数据</td>
<td>1 微妙</td>
</tr>
</tbody>
</table></div>

        <h2 id="浅堆深堆"   >
          <a href="#浅堆深堆" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#浅堆深堆"></a> 浅堆深堆</h2>
      

        <h3 id="浅堆shallow-heap"   >
          <a href="#浅堆shallow-heap" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#浅堆shallow-heap"></a> 浅堆（Shallow Heap）</h3>
      
<p>浅堆是指一个对象所消耗的内存。在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。根据堆快照格式不同，对象的大小可能会同8字节进行对齐。</p>
<p>以String为例：2个int值共占8字节，对象引用占用4字节，对象头8字节，合计20字节，向8字节对齐，故占24字节。（JDK 7中）</p>
<div class="table-container"><table>
<thead>
<tr>
<th>int</th>
<th>hash32</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>int</strong></td>
<td><strong>hash</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td><strong>ref</strong></td>
<td><strong>value</strong></td>
<td><strong>C:\Users\Administrat</strong></td>
</tr>
</tbody>
</table></div>
<p>这24字节为String对象的浅堆大小。<strong>它与String的value实际取值无关，无论字符串长度如何，浅堆大小始终是24字节</strong>。</p>
<p><strong>浅堆指对象本身占用的内存，不包括其内部引用对象的大小</strong></p>

        <h3 id="保留集retained-set"   >
          <a href="#保留集retained-set" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#保留集retained-set"></a> 保留集（Retained Set）</h3>
      
<p><strong>对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合</strong>（包括对象A本身），即对象A的保留集可以被认为是 <mark><strong>只能通过</strong></mark> <strong>对象A被直接或间接访问到的所有对象的集合</strong>。通俗地说，就是指<strong>仅被对象A所持有的对象的集合</strong>。</p>
<p>这些对象无法被其他对象所访问到，所以一旦A对象需要被回收，那么其所持有的的保留集中的对象都需要被回收。</p>

        <h3 id="深堆retained-heap"   >
          <a href="#深堆retained-heap" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#深堆retained-heap"></a> 深堆（Retained Heap）</h3>
      
<p>深堆是指<strong>对象的保留集中所有的对象的浅堆大小之和</strong>。</p>
<p>注意：<strong>浅堆指对象本身占用的内存，不包括其内部引用对象的大小</strong>。<strong>一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间</strong>。</p>

        <h3 id="对象的实际大小"   >
          <a href="#对象的实际大小" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对象的实际大小"></a> 对象的实际大小</h3>
      
<p>这里，对象的实际大小定义为<strong>一个对象所能触及的所有对象的浅堆大小之和</strong>，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，但实际上，这个概念和垃圾回收无关。</p>
<p>下图显示了一个简单的对象引用关系图，对象A引用了C和D，对象B引用了C和E。<strong>那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内</strong>。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019194726602.png" alt="image-20211019194726602" /></p>

        <h3 id="支配树dominator-tree"   >
          <a href="#支配树dominator-tree" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#支配树dominator-tree"></a> 支配树（Dominator Tree）</h3>
      
<p>支配树的概念源自图论。MAT提供了一个称为支配树（Dominator Tree）的对象图。支配树体现了对象实例间的支配关系。在对象引用图中，<strong>所有指向对象B的路径都经过对象A，则认为对象A支配对象B</strong>。如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的直接支配者。支配树是基于对象间的引用图所建立的，它有以下基本性质：</p>
<ul>
<li>对象A的子树（所有被对象A支配的对象集合）表示对象A的保留集（retained set），即深堆。</li>
<li>如果对象A支配对象B，那么对象A的直接支配者也支配对象B。</li>
<li>支配树的边与对象引用图的边不直接对应。</li>
</ul>
<p>如下图所示：左图表示对象引用图，右图表示左图所对应的支配树。对象A和B由根对象直接支配，由于在到对象C的路径中，可以经过A，也可以经过B，因此对象C的直接支配者也是根对象。对象F与对象D相互引用，因为到对象F的所有路径必然经过对象D，因此，对象D是对象F的直接支配者。而到对象D的所有路径中，必然经过对象C，即使是从对象F到对象D的引用，从根节点出发，也是经过对象C的，所以，对象D的直接支配者为对象C。同理，对象E支配对象G。到达对象H的可以通过对象D，也可以通过对象E，因此对象D和E都不能支配对象H，而经过对象C既可以到达D也可以到达E，因此对象C为对象H的直接支配者。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019194901811.png" alt="image-20211019194901811" /></p>

        <h2 id="命令行工具"   >
          <a href="#命令行工具" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#命令行工具"></a> 命令行工具</h2>
      

        <h3 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3>
      
<p>性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。</p>
<p>Java 作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。可能造成 Java 应用出现性能问题的因素非常多，例如线程控制、磁盘读写、数据库访问、网络I/O、垃圾收集等。想要定位这些问题，一款优秀的性能诊断工具必不可少。</p>
<p>在JDK的bin目录下，有很多官方提供的监控与诊断工具：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018143521569.png" alt="image-20211018143521569" /></p>

        <h3 id="jps查看正在运行的-java-进程"   >
          <a href="#jps查看正在运行的-java-进程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jps查看正在运行的-java-进程"></a> jps：查看正在运行的 Java 进程</h3>
      
<p>jps（Java Process Status）：显示指定系统内所有的HotSpot虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程。</p>
<p>格式：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></div></figure>
<p>常用参数：</p>
<ul>
<li><code>jps -q</code>：只显示Java进程号</li>
<li><code>jps -l</code>：显示主类全类名</li>
<li><code>jps -m</code>：显示主类<code>main()</code>的参数</li>
<li><code>jps -v</code>：显示进程启动的JVM参数。比如：<code>-Xms20m</code> <code>-Xmx50m</code>是启动程序指定的JVM参数。</li>
</ul>
<p>上述参数可以组合使用。</p>
<blockquote>
<p>如果某 Java 进程关闭了默认开启的UsePerfData参数（即使用参数-XX：-UsePerfData），那么jps命令（以及下面介绍的jstat）将无法探知该Java 进程。</p>
</blockquote>

        <h3 id="jstat查看-jvm-统计信息"   >
          <a href="#jstat查看-jvm-统计信息" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jstat查看-jvm-统计信息"></a> jstat：查看 JVM 统计信息</h3>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/u21195183/jvm/pgrt7e" >https://www.yuque.com/u21195183/jvm/pgrt7e</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>jstat（JVM Statistics Monitoring Tool）：用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题。</p>
<p><strong>jstat是命令行中运行期间定位虚拟机性能问题首选工具，常用于检查垃圾回收以及内存泄漏问题</strong>。</p>
<p>格式：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h] &lt;vmid&gt; [interval] [count]</span><br></pre></td></tr></table></div></figure>
<p>常用参数：</p>
<ul>
<li><code>-option</code>：要查看什么统计信息</li>
<li><code>-t</code>：输出程序运行到现在好费时间</li>
<li><code>-h</code> ：输出多少行后输出一次表头信息</li>
<li><code>vmid</code>：要查看的进程号</li>
<li><code>interval</code>：间隔多少毫秒输出一次统计信息</li>
<li><code>count</code>：输出多少次终止</li>
</ul>
<p>常用命令：</p>
<p><strong>jstat -class</strong>：显示ClassLoader的相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间等</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144605845.png" alt="image-20211018144605845" /></p>
<p><strong>jstat -compiler</strong>：显示JIT编译器编译过的方法、耗时等信息</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144636311.png" alt="image-20211018144636311" /></p>
<p><strong>jstat -printcompilation</strong>：输出已经被JIT编译的方法</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144724807.png" alt="image-20211018144724807" /></p>
<p><strong>jstat -gc</strong>：显示与GC相关的堆信息。包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144741353.png" alt="image-20211018144741353" /></p>
<p><strong>jstat -gccapacity</strong>：显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144811128.png" alt="image-20211018144811128" /></p>
<p><strong>jstat -gcutil</strong>：显示内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144853740.png" alt="image-20211018144853740" /></p>
<p><strong>jstat -gccause</strong>：与-gcutil功能一样，但是会额外输出导致最后一次或当前正在发生的GC产生的原因。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144920184.png" alt="image-20211018144920184" /></p>
<p><strong>jstat -gcnew</strong>：显示新生代GC状况</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018144946904.png" alt="image-20211018144946904" /></p>
<p><strong>jstat -t</strong></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018145058532.png" alt="image-20211018145058532" /></p>
<p><strong>jstat -t -h</strong></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018145110053.png" alt="image-20211018145110053" /></p>
<div class="table-container"><table>
<thead>
<tr>
<th>表头</th>
<th>含义（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td>EC</td>
<td>Eden区的大小</td>
</tr>
<tr>
<td>EU</td>
<td>Eden区已使用的大小</td>
</tr>
<tr>
<td>S0C</td>
<td>幸存者0区的大小</td>
</tr>
<tr>
<td>S1C</td>
<td>幸存者1区的大小</td>
</tr>
<tr>
<td>S0U</td>
<td>幸存者0区已使用的大小</td>
</tr>
<tr>
<td>S1U</td>
<td>幸存者1区已使用的大小</td>
</tr>
<tr>
<td>MC</td>
<td>元空间的大小</td>
</tr>
<tr>
<td>MU</td>
<td>元空间已使用的大小</td>
</tr>
<tr>
<td>OC</td>
<td>老年代的大小</td>
</tr>
<tr>
<td>OU</td>
<td>老年代已使用的大小</td>
</tr>
<tr>
<td>CCSC</td>
<td>压缩类空间的大小</td>
</tr>
<tr>
<td>CCSU</td>
<td>压缩类空间已使用的大小</td>
</tr>
<tr>
<td>YGC</td>
<td>从应用程序启动到采样时young gc的次数</td>
</tr>
<tr>
<td>YGCT</td>
<td>从应用程序启动到采样时young gc消耗时间（秒）</td>
</tr>
<tr>
<td>FGC</td>
<td>从应用程序启动到采样时full gc的次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>从应用程序启动到采样时的full gc的消耗时间（秒）</td>
</tr>
<tr>
<td>GCT</td>
<td>从应用程序启动到采样时gc的总时间</td>
</tr>
</tbody>
</table></div>
<p><strong>经验</strong>：</p>
<ul>
<li>当GC时间占总时间比率很大时，说明频繁GC，越大越可能OOM
<ul>
<li>计算GC占比公式 = 2次GC耗时时间相减 / 这2次程序持续时间相减</li>
</ul>
</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210517225915759.png" alt="img" /></p>
<ul>
<li>当老年代占用内存不断上涨,可能出现内存泄漏</li>
</ul>
<p><strong>补充：</strong> jstat还可以用来判断是否出现内存泄漏。</p>
<ul>
<li>第1步：在长时间运行的 Java 程序中，我们可以运行jstat命令连续获取多行性能数据，并取这几行数据中 OU 列（即已占用的老年代内存）的最小值</li>
<li>第2步：然后，我们每隔一段较长的时间重复一次上述操作，来获得多组 OU 最小值。如果这些值呈上涨趋势，则说明该 Java 程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018145358819.png" alt="image-20211018145358819" /></p>

        <h3 id="jinfo实时查看和修改-jvm-配置参数"   >
          <a href="#jinfo实时查看和修改-jvm-配置参数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jinfo实时查看和修改-jvm-配置参数"></a> jinfo：实时查看和修改 JVM 配置参数</h3>
      
<p>jinfo（Configuration Info for Java）：<strong>查看虚拟机配置参数信息，也可用于实时修改虚拟机的配置参数</strong>。在很多情况卡，Java应用程序不会指定所有的Java虚拟机参数。而此时，开发人员可能不知道某一个具体的Java虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但有了jinfo工具，开发人员可以很方便地找到Java虚拟机参数的当前值。</p>
<blockquote>
<p>jinfo 可以在程序运行时动态修改某些参数（只有少数参数支持运行时修改）。更多的应用是查看JVM的一些参数</p>
</blockquote>
<p>格式：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [options] pid</span><br></pre></td></tr></table></div></figure>
<p>参数列表：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>选项</th>
<th>选项说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no option</td>
<td>输出全部的参数和系统属性</td>
</tr>
<tr>
<td>-flag name</td>
<td>输出对应名称的参数</td>
</tr>
<tr>
<td>-flag [±]name</td>
<td>开启或者关闭对应名称的参数 只有被标记为manageable的参数才可以被动态修改</td>
</tr>
<tr>
<td>-flag name=value</td>
<td>设定对应名称的参数</td>
</tr>
<tr>
<td>-flags</td>
<td>输出全部的参数</td>
</tr>
<tr>
<td>-sysprops</td>
<td>输出系统属性</td>
</tr>
</tbody>
</table></div>
<p>常用参数：</p>
<p><strong>jinfo -sysprops</strong>：  输出系统属性</p>
<figure class="highlight properties"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> <span class="string">jinfo -sysprops</span></span><br><span class="line"><span class="meta">jboss.modules.system.pkgs</span> = <span class="string">com.intellij.rt</span></span><br><span class="line"><span class="meta">java.vendor</span> = <span class="string">Oracle Corporation</span></span><br><span class="line"><span class="meta">sun.java.launcher</span> = <span class="string">SUN_STANDARD</span></span><br><span class="line"><span class="meta">sun.management.compiler</span> = <span class="string">HotSpot 64-Bit Tiered Compilers</span></span><br><span class="line"><span class="meta">catalina.useNaming</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">os.name</span> = <span class="string">Windows 10</span></span><br><span class="line"><span class="attr">...</span></span><br></pre></td></tr></table></div></figure>
<p><strong>jinfo -flags</strong>：输出全部的参数</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> jinfo -flags 25592</span></span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=4 -XX:InitialHeapSize=333447168 -XX:MaxHeapSize=5324668928 -XX:MaxNewSize=1774714880 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=111149056 -XX:OldSize=222298112 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class="line">Command line:  -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:8040,suspend=y,server=n -Drebel.base=C:\Users\Vector\.jrebel -Drebel.env.ide.plugin.version=2021.1.2 -Drebel.env.ide.version=2020.3.3 -Drebel.env.ide.product=IU -Drebel.env.ide=intellij -Drebel.notification.url=http://localhost:7976 -agentpath:C:\Users\Vector\AppData\Roaming\JetBrains\IntelliJIdea2020.3\plugins\jr-ide-idea\lib\jrebel6\lib\jrebel64.dll -Dmaven.home=D:\eclipse\env\maven -Didea.modules.paths.file=C:\Users\Vector\AppData\Local\JetBrains\IntelliJIdea2020.3\Maven\idea-projects-state-596682c7.properties -Dclassworlds.conf=C:\Users\Vector\AppData\Local\Temp\idea-6755-mvn.conf -Dmaven.ext.class.path=D:\IDEA\plugins\maven\lib\maven-event-listener.jar -javaagent:D:\IDEA\plugins\java\lib\rt\debugger-agent.jar -Dfile.encoding=UTF-8</span><br></pre></td></tr></table></div></figure>
<p><strong>jinfo -flag name</strong>：输出对应名称的参数</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> jinfo -flag UseParallelGC 25592</span></span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> jinfo -flag UseG1GC 25592</span></span><br><span class="line">-XX:-UseG1GC</span><br></pre></td></tr></table></div></figure>
<p><strong>jinfo -flag [±]name</strong>：开启或者关闭对应名称的参数，只有被标记为manageable的参数才可以被动态修改</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> jinfo -flag +PrintGCDetails 25592</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> jinfo -flag PrintGCDetails 25592</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> jinfo -flag -PrintGCDetails 25592</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> jinfo -flag PrintGCDetails 25592</span></span><br><span class="line">-XX:-PrintGCDetails</span><br></pre></td></tr></table></div></figure>
<p>拓展：</p>
<p><code>java -XX:+PrintFlagsInitial</code> 查看所有JVM参数启动的初始值</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">     intx ActiveProcessorCount                      = -1                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeDecrementScaleFactor          = 4                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePausePolicy                   = 0                                   &#123;product&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure>
<p><code>java -XX:+PrintFlagsFinal</code> 查看所有JVM参数的最终值</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">     intx ActiveProcessorCount                      = -1                                  &#123;product&#125;</span><br><span class="line">...</span><br><span class="line">     intx CICompilerCount                          := 4                                   &#123;product&#125;</span><br><span class="line">    uintx InitialHeapSize                          := 333447168                           &#123;product&#125;</span><br><span class="line">    uintx MaxHeapSize                              := 1029701632                          &#123;product&#125;</span><br><span class="line">    uintx MaxNewSize                               := 1774714880                          &#123;product&#125;</span><br></pre></td></tr></table></div></figure>
<p><code>java -XX:+PrintCommandLineFlags</code> 查看哪些已经被用户或者JVM设置过的详细的XX参数的名称和值</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=332790016 -XX:MaxHeapSize=5324640256 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></div></figure>

        <h3 id="jmap导出内存映像文件和内存使用情况"   >
          <a href="#jmap导出内存映像文件和内存使用情况" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jmap导出内存映像文件和内存使用情况"></a> jmap：导出内存映像文件和内存使用情况</h3>
      
<p>jmap（JVM Memory Map）：作用一方面是获取dump文件（堆转储快照文件，二进制文件），它还可以获取目标Java进程的内存相关信息，包括Java堆各区域的使用情况、堆中对象的统计信息、类加载信息等。开发人员可以在控制台中输入命令“jmap -help”查阅jmap工具的具体使用方式和一些标准选项配置。</p>
<p><strong>jmap用于获取dump文件以及目标Java进程内存相关信息（堆使用情况，对象统计信息，类加载信息）</strong></p>
<p>基本使用语法为：</p>
<ul>
<li><code>jmap [option] &lt;pid&gt;</code></li>
<li><code>jmap [option] &lt;executable &lt;core&gt;</code></li>
<li><code>jmap [option] [server_id@] &lt;remote server IP or hostname&gt;</code></li>
</ul>
<p>常用选项：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210518090954961.png" alt="img" /></p>
<div class="table-container"><table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-dump</td>
<td>生成dump文件（Java堆转储快照），<code>-dump:live</code>只保存堆中的存活对象</td>
</tr>
<tr>
<td>-heap</td>
<td>输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等</td>
</tr>
<tr>
<td>-histo</td>
<td>输出堆空间中对象的统计信息，包括类、实例数量和合计容量，<code>-histo:live</code>只统计堆中的存活对象</td>
</tr>
<tr>
<td>-J &lt;flag&gt;</td>
<td>传递参数给jmap启动的jvm</td>
</tr>
<tr>
<td>-finalizerinfo</td>
<td>显示在F-Queue中等待Finalizer线程执行finalize方法的对象，仅linux/solaris平台有效</td>
</tr>
<tr>
<td>-permstat</td>
<td>以ClassLoader为统计口径输出永久代的内存状态信息，仅linux/solaris平台有效</td>
</tr>
<tr>
<td>-F</td>
<td>当虚拟机进程对-dump选项没有任何响应时，强制执行生成dump文件，仅linux/solaris平台有效</td>
</tr>
</tbody>
</table></div>
<p><strong>该命令常用于导出dump文件</strong>：</p>
<ul>
<li>手动导出dump文件：</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</span><br><span class="line">jmap -dump:live,format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>自动导出：启动程序时需要带参数，发生OOM时自动导出
<ul>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code></li>
<li><code>-XX:HeapDumpPath=导出目录\文件名.hprof</code></li>
</ul>
</li>
</ul>
<p>说明：这些参数和Linux下输入显示的命令多少会有不同，包括也受jdk版本的影响。</p>
<p>由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，<strong>jmap需要借助安全点机制，让所有线程停留在不改变堆中数据的状态</strong>。也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。</p>
<p>举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么:live选项将无法探知到这些对象。</p>
<p>另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去。与前面讲的jstat则不同，垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需直接读取即可。</p>

        <h3 id="jhatjdk自带堆分析工具"   >
          <a href="#jhatjdk自带堆分析工具" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jhatjdk自带堆分析工具"></a> jhat：JDK自带堆分析工具</h3>
      
<p>jhat（JVM Heap Analysis Tool）：Sun JDK提供的jhat命令与jmap命令搭配使用，<strong>用于分析jmap生成的heap dump文件</strong>（堆转储快照）。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，用户可以在浏览器中查看分析结果（分析虚拟机转储快照信息）。</p>
<p>使用了jhat命令，就启动了一个http服务，端口是7000，即http://localhost:7000/，就可以在浏览器里分析。使用的时候会占用CPU所以不会在生成环境中使用jhat来分析</p>
<blockquote>
<p>说明：jhat命令在JDK9、JDK10中已经被删除，官方建议用VisualVM代替。</p>
</blockquote>
<p>格式：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat &lt;option&gt; &lt;dumpfile&gt;</span><br></pre></td></tr></table></div></figure>
<p>常用参数：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>option参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-stack false｜true</td>
<td>关闭｜打开对象分配调用栈跟踪</td>
</tr>
<tr>
<td>-refs false｜true</td>
<td>关闭｜打开对象引用跟踪</td>
</tr>
<tr>
<td>-port port-number</td>
<td>设置jhat HTTP Server的端口号，默认7000</td>
</tr>
<tr>
<td>-exclude exclude-file</td>
<td>执行对象查询时需要排除的数据成员</td>
</tr>
<tr>
<td>-baseline exclude-file</td>
<td>指定一个基准堆转储</td>
</tr>
<tr>
<td>-debug int</td>
<td>设置debug级别</td>
</tr>
<tr>
<td>-version</td>
<td>启动后显示版本信息就退出</td>
</tr>
<tr>
<td>-J &lt;flag&gt;</td>
<td>传入启动参数，比如-J-Xmx512m</td>
</tr>
</tbody>
</table></div>

        <h3 id="jstack打印-jvm-中线程快照"   >
          <a href="#jstack打印-jvm-中线程快照" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jstack打印-jvm-中线程快照"></a> jstack：打印 JVM 中线程快照</h3>
      
<p>jstack（JVM Stack Trace）：<strong>用于生成虚拟机指定进程当前时刻的线程快照</strong>（虚拟机堆栈跟踪）。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p>
<p>生成线程快照的作用：可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用jstack显示各个线程调用的堆栈情况。</p>
<p>在thread dump中，要留意下面几种状态</p>
<ul>
<li>死锁，<code>Deadlock</code>（重点关注）</li>
<li>等待资源，<code>Waiting on condition</code>（重点关注）</li>
<li>等待获取监视器，<code>Waiting on monitor entry</code>（重点关注）</li>
<li>阻塞，<code>Blocked</code>（重点关注）</li>
<li>执行中，<code>Runnable</code></li>
<li>暂停，<code>Suspended</code></li>
<li>对象等待中，<code>Object.wait()</code> 或 <code>TIMED_WAITING</code></li>
<li>停止，<code>Parked</code></li>
</ul>
<p>格式：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack option pid</span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210518224426354.png" alt="img" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210518224413517.png" alt="img" /></p>

        <h3 id="jcmd多功能命令行"   >
          <a href="#jcmd多功能命令行" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jcmd多功能命令行"></a> jcmd：多功能命令行</h3>
      
<blockquote>
<p>jcmd可以实现除了jstat外所有指令的功能</p>
</blockquote>
<p>在JDK 1.7以后，新增了一个命令行工具jcmd。它是一个<strong>多功能</strong>的工具，可以用来实现前面除了jstat之外所有命令的功能。比如：用它来导出堆、内存使用、查看Java进程、导出线程信息、执行GC、JVM运行时间等。jcmd拥有jmap的大部分功能，并且在Oracle的官方网站上也推荐使用jcmd命令代jmap命令。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210518225518037.png" alt="img" /></p>
<p>常用命令：</p>
<ul>
<li><code>jcmd -l</code>：列出所有的JVM进程</li>
<li><code>jcmd 进程号 help</code>：针对指定的进程，列出支持的所有具体命令</li>
<li><code>jcmd 进程号 具体命令</code>：显示指定进程的指令命令的数据
<ul>
<li><code>Thread.print</code> 可以替换 jstack指令</li>
<li><code>GC.class_histogram</code> 可以替换 jmap中的<code>-histo</code>操作</li>
<li><code>GC.heap_dump</code> 可以替换 jmap中的<code>-dump</code>操作</li>
<li><code>GC.run</code> 可以查看GC的执行情况</li>
<li><code>VM.uptime</code> 可以查看程序的总执行时间，可以替换jstat指令中的<code>-t</code>操作</li>
<li><code>VM.system_properties</code> 可以替换 <code>jinfo -sysprops 进程id</code></li>
<li><code>VM.flags</code> 可以获取JVM的配置参数信息</li>
</ul>
</li>
</ul>

        <h3 id="jstatd远程主机信息收集"   >
          <a href="#jstatd远程主机信息收集" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jstatd远程主机信息收集"></a> jstatd：远程主机信息收集</h3>
      
<p>之前的指令只涉及到监控本机的Java应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如jps、jstat）。为了启用远程监控，则需要配合使用jstatd 工具。命令jstatd是一个RMI服务端程序，它的作用相当于<strong>代理服务器，建立本地计算机与远程监控工具的通信</strong>。jstatd服务器将本机的Java应用程序信息传递到远程计算机。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211020110057297.png" alt="image-20211020110057297" /></p>

        <h2 id="gui-工具"   >
          <a href="#gui-工具" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#gui-工具"></a> GUI 工具</h2>
      
<p>使用上一章命令行工具或组合能帮我们获取目标Java应用性能相关的基础信息，但它们存在下列局限：</p>
<ul>
<li>无法获取方法级别的分析数据，如方法间的调用关系、各方法的调用次数和调用时间等（这对定位应用性能瓶颈至关重要）。</li>
<li>要求用户登录到目标 Java 应用所在的宿主机上，使用起来不是很方便。</li>
<li>分析数据通过终端输出，结果展示不够直观。</li>
</ul>
<p>为此，JDK提供了一些内存泄漏的分析工具，如jconsole，jisualvm等，用于辅助开发人员定位问题，但是这些工具很多时候并不足以满足快速定位的需求。所以这里我们介绍的工具相对多一些、丰富一些。</p>
<p><strong>JDK 自带的工具</strong></p>
<ul>
<li>jconsole：JDK自带的可视化监控工具。查看Java应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等</li>
<li>Visual VM：Visual VM是一个工具，它提供了一个可视界面，用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息。</li>
<li>JMC：Java Mission Control，内置Java Flight Recorder。能够以极低的性能开销收集Java虚拟机的性能数据。</li>
</ul>
<p><strong>第三方工具</strong></p>
<ul>
<li>MAT：MAT（Memory Analyzer Tool）是基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li>
<li>JProfiler：商业软件，需要付费。功能强大。</li>
</ul>

        <h3 id="jconsole"   >
          <a href="#jconsole" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jconsole"></a> JConsole</h3>
      
<blockquote>
<p>jconsole 可用于观察堆内存情况、检查线程是否发生死锁</p>
</blockquote>
<p>jconsole：从Java 5开始，在JDK中自带的java<strong>监控和管理控制台</strong>。用于对JVM中内存、线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监控工具。</p>
<p>官方地址：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html" >https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="启动"   >
          <a href="#启动" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#启动"></a> 启动</h4>
      
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210518235707000.png" alt="image-20210518235707000" /></p>

        <h4 id="连接"   >
          <a href="#连接" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#连接"></a> 连接</h4>
      
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519000148496.png" alt="image-20210519000148496" /></p>
<p>无法连接解决方案，启动JVM参数加上</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote  </span><br><span class="line">-Dcom.sun.management.jmxremote.port&#x3D;8011 </span><br><span class="line">-Dcom.sun.management.jmxremote.ssl&#x3D;false</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate&#x3D;false</span><br></pre></td></tr></table></div></figure>

        <h4 id="查看信息"   >
          <a href="#查看信息" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#查看信息"></a> 查看信息</h4>
      
<blockquote>
<p>概述信息</p>
</blockquote>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519000756518.png" alt="image-20210519000756518" /></p>
<blockquote>
<p>内存信息</p>
</blockquote>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519000816175.png" alt="image-20210519000816175" /></p>
<blockquote>
<p>线程信息 可检查死锁</p>
</blockquote>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519000835395.png" alt="image-20210519000835395" /></p>
<blockquote>
<p>关于类信息</p>
</blockquote>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519000848394.png" alt="image-20210519000848394" /></p>
<blockquote>
<p>有关VM以及参数等信息</p>
</blockquote>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519000900135.png" alt="image-20210519000900135" /></p>

        <h3 id="visual-vm"   >
          <a href="#visual-vm" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#visual-vm"></a> Visual VM</h3>
      
<blockquote>
<p>Visual VM 集合了上一章讲解的多个命令行工具的功能，并提供了可视化界面，能够替代 JConsole</p>
</blockquote>
<p>Visual VM是一个功能强大的多合一故障诊断和性能监控的可视化工具。它集成了多个JDK命令行工具，使用Visual VM可用于显示虚拟机进程及进程的配置和环境信息（jps，jinfo），监视应用程序的CPU、GC、堆、方法区及线程的信息（jstat、jstack）等，甚至代替JConsole。在JDK 6 Update 7以后，Visual VM便作为JDK的一部分发布（VisualVM 在JDK／bin目录下）即：它完全免费。</p>
<p>IDEA 可以继承 Visual VM 插件。另外，Visual VM 也需要安装一个插件：Visual GC，用于观察GC情况。</p>
<p><strong>主要功能：</strong></p>
<ul>
<li>生成/读取堆内存/线程快照</li>
<li>查看JVM参数和系统属性</li>
<li>查看运行中的虚拟机进程</li>
<li>程序资源的实时监控</li>
<li>JMX代理连接、远程环境监控、CPU分析和内存分析</li>
</ul>
<p>官方地址：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://visualvm.github.io/index.html" >https://visualvm.github.io/index.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="查看堆dump文件"   >
          <a href="#查看堆dump文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#查看堆dump文件"></a> 查看堆dump文件</h4>
      
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519132440728.png" alt="image-20210519132440728" /></p>

        <h4 id="查看线程dump文件"   >
          <a href="#查看线程dump文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#查看线程dump文件"></a> 查看线程dump文件</h4>
      
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519132543453.png" alt="image-20210519132543453" /></p>

        <h4 id="查看cpu内存抽样"   >
          <a href="#查看cpu内存抽样" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#查看cpu内存抽样"></a> 查看CPU，内存抽样</h4>
      
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519132722496.png" alt="image-20210519132722496" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210519132711392.png" alt="image-20210519132711392" /></p>

        <h3 id="eclipse-mat"   >
          <a href="#eclipse-mat" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#eclipse-mat"></a> Eclipse MAT</h3>
      
<p>MAT（Memory Analyzer Tool）工具是一款功能强大的Java<strong>堆内存分析器</strong>。可以用于查找内存泄漏以及查看内存消耗情况。MAT是基于Eclipse开发的，不仅可以单独使用，还可以作为插件的形式嵌入在Eclipse中使用。是一款免费的性能分析工具，使用起来非常方便。</p>
<p>MAT可以分析heap dump文件。在进行内存分析时，只要获得了反映当前设备内存映像的hprof文件，通过MAT打开就可以直观地看到当前的内存信息。一般说来，这些内存信息包含：</p>
<ul>
<li>所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。</li>
<li>所有的类信息，包括classloader、类名称、父类、静态变量等</li>
<li>GCRoot到所有的这些对象的引用路径</li>
<li>线程信息，包括线程的调用栈及此线程的线程局部变量（TLS）</li>
</ul>
<p>MAT 不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如Sun，HP，SAP 所采用的 HPROF 二进制堆存储文件，以及 IBM的 PHD 堆存储文件等都能被很好的解析。</p>
<p>最吸引人的还是能够快速为开发人员生成内存泄漏报表，方便定位问题和分析问题。虽然MAT有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从MAT展现给我们的信息当中通过经验和直觉来判断才能发现。</p>
<p>官方地址： <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.eclipse.org/mat/downloads.php" >https://www.eclipse.org/mat/downloads.php</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018212421955.png" alt="image-20211018212421955" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018212430167.png" alt="image-20211018212430167" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018212443302.png" alt="image-20211018212443302" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018212452056.png" alt="image-20211018212452056" /></p>

        <h3 id="jprofiler"   >
          <a href="#jprofiler" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jprofiler"></a> JProfiler</h3>
      
<p>在运行Java的时候有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了。在eclipse里面有 Eclipse Memory Analyzer tool（MAT）插件可以测试，而在IDEA中也有这么一个插件，就是JProfiler。JProfiler 是由 ej-technologies 公司开发的一款 Java 应用性能诊断工具。功能强大，但是收费。</p>
<p><strong>特点：</strong></p>
<ul>
<li>使用方便、界面操作友好（简单且强大）</li>
<li>对被分析的应用影响小（提供模板）</li>
<li>CPU，Thread，Memory分析功能尤其强大</li>
<li>支持对jdbc，noSql，jsp，servlet，socket等进行分析</li>
<li>支持多种模式（离线，在线）的分析</li>
<li>支持监控本地、远程的JVM</li>
<li>跨平台，拥有多种操作系统的安装版本</li>
</ul>
<p><strong>主要功能：</strong></p>
<ul>
<li>方法调用：对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法</li>
<li>内存分配：通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄露问题，优化内存使用</li>
<li>线程和锁：JProfiler提供多种针对线程和锁的分析视图助您发现多线程问题</li>
<li>高级子系统：许多性能问题都发生在更高的语义级别上。例如，对于JDBC调用，您可能希望找出执行最慢的SQL语句。JProfiler支持对这些子系统进行集成分析</li>
</ul>
<p>官网地址：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ej-technologies.com/products/jprofiler/overview.html" >https://www.ej-technologies.com/products/jprofiler/overview.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><strong>数据采集方式：</strong></p>
<p>JProfier数据采集方式分为两种：Sampling（样本采集）和Instrumentation（重构模式）</p>
<ul>
<li><strong>Instrumentation</strong>：这是JProfiler全功能模式。在class加载之前，JProfier把相关功能代码写入到需要分析的class的bytecode中，对正在运行的jvm有一定影响。
<ul>
<li>优点：功能强大。在此设置中，调用堆栈信息是准确的。</li>
<li>缺点：若要分析的class较多，则<strong>对应用的性能影响较大</strong>，CPU开销可能很高（取决于Filter的控制）。因此使用此模式一般配合Filter使用，只对特定的类或包进行分</li>
</ul>
</li>
<li><strong>Sampling</strong>：类似于样本统计，每隔一定时间（5ms）将每个线程栈中方法栈中的信息统计出来。
<ul>
<li>优点：对CPU的开销非常低，对应用影响小（即使你不配置任何Filter）</li>
<li>缺点：一些数据／特性不能提供（例如：方法的调用次数、执行时间）</li>
</ul>
</li>
</ul>
<p>注：JProfiler本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为JProfiler的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是JProfiler的数据采集类型。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210520235805487.png" alt="image-20210520235805487" /></p>

        <h4 id="摇杆检测-telemetries"   >
          <a href="#摇杆检测-telemetries" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#摇杆检测-telemetries"></a> 摇杆检测 Telemetries</h4>
      
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521093956938.png" alt="image-20210521093956938" /></p>

        <h4 id="内存视图分析-live-memory"   >
          <a href="#内存视图分析-live-memory" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存视图分析-live-memory"></a> 内存视图分析 Live memory</h4>
      
<p>Live memory 内存剖析：class／class instance的相关信息。例如对象的个数，大小，对象创建的方法执行栈，对象创建的热点。</p>
<ul>
<li><strong>所有对象 All Objects</strong>：显示所有加载的类的列表和在堆上分配的实例数。只有Java 1.5（JVMTI）才会显示此视图。</li>
<li><strong>记录对象 Record Objects</strong>：查看特定时间段对象的分配，并记录分配的调用堆栈。</li>
<li><strong>分配访问树 Allocation Call Tree</strong>：显示一棵请求树或者方法、类、包或对已选择类有带注释的分配信息的J2EE组件。</li>
<li><strong>分配热点 Allocation Hot Spots</strong>：显示一个列表，包括方法、类、包或分配已选类的J2EE组件。你可以标注当前值并且显示差异值。对于每个热点都可以显示它的跟踪记录树。</li>
<li><strong>类追踪器 Class Tracker</strong>：类跟踪视图可以包含任意数量的图表，显示选定的类和包的实例与时间。</li>
</ul>
<p>可以通过对比分析，如果增加很多对象可能有几种情况：</p>
<ol>
<li><strong>频繁创建对象,死循环或循环次数多</strong></li>
<li><strong>存在大对象（读取文件byte[]不要太大,边写边读,长时间不写出会导致byte[]过大）</strong></li>
<li><strong>每次GC后，内存依次递增可能存在内存泄漏</strong></li>
</ol>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521145844721.png" alt="image-20210521145844721" /></p>
<ul>
<li>All Objects 所有对象：Size显示的是该实例对象的浅堆(不包含它引用字段的实际大小)</li>
<li>Recorded Objects 记录对象：可以动态看到类的对象变化情况 (默认不开启,开启后影响性能)</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521145941114.png" alt="image-20210521145941114" /></p>
<ul>
<li>Allocation Call Tree 分配访问树：将执行方法所占时间显示成树 (默认不开启,开启后影响性能)</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521150407870.png" alt="image-20210521150407870" /></p>
<ul>
<li>Allocation Hots Spots 分配热点：显示什么方法时间占比大</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521150855253.png" alt="image-20210521150855253" /></p>
<ul>
<li>Class Tracker 类追踪器</li>
</ul>

        <h4 id="堆遍历-heap-walker"   >
          <a href="#堆遍历-heap-walker" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#堆遍历-heap-walker"></a> 堆遍历 Heap Walker</h4>
      
<p>通过对比发现对象增长过快,可以查看该对象的引用链</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521153855310.png" alt="image-20210521153855310" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521154115936.png" alt="image-20210521154115936" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521154221915.png" alt="image-20210521154221915" /></p>

        <h4 id="cpu-视图-cpu-views"   >
          <a href="#cpu-视图-cpu-views" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cpu-视图-cpu-views"></a> CPU 视图 CPU views</h4>
      
<p>JProfiler 提供不同的方法来记录访问树以优化性能和细节。线程或者线程组以及线程状况可以被所有的视图选择。所有的视图都可以聚集到方法、类、包或J2EE组件等不同层上。</p>
<ul>
<li><strong>访问树 Call Tree</strong>：显示一个积累的自顶向下的树，树中包含所有在JVM中已记录的访问队列。JDBC，JMS和JNDI服务请求都被注释在请求树中。请求树可以根据Servlet和JSP对URL的不同需要进行拆分。</li>
<li><strong>热点 Hot Spots</strong>：显示消耗时间最多的方法的列表。对每个热点都能够显示回溯树。该热点可以按照方法请求，JDBC，JMS和JNDI服务请求以及按照URL请求来进行计算。</li>
<li><strong>访问图 Call Graph</strong>：显示一个从已选方法、类、包或J2EE组件开始的访问队列的图。</li>
<li><strong>方法统计 Method Statistis</strong>：显示一段时间内记录的方法的调用时间细节。</li>
</ul>
<p>关于这种分析都可以从范围大的到范围小的 <strong>package -&gt; class -&gt; method</strong></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521154546655.png" alt="image-20210521154546655" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018213204845.png" alt="image-20211018213204845" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018213217786.png" alt="image-20211018213217786" /></p>

        <h4 id="线程视图-threads"   >
          <a href="#线程视图-threads" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程视图-threads"></a> 线程视图 Threads</h4>
      
<p>JProfiler通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所管理的方法以树状形式呈现。对线程剖析。</p>
<ul>
<li><strong>线程历史 Thread History</strong>：显示一个与线程活动和线程状态在一起的活动时间表。</li>
<li><strong>线程监控 Thread Monitor</strong>：显示一个列表，包括所有的活动线程以及它们目前的活动状况。</li>
<li><strong>线程转储 Thread Dumps</strong>：显示所有线程的堆栈跟踪。</li>
</ul>
<p>线程分析主要关心三个方面：</p>
<ul>
<li>web容器的线程最大数。比如：Tomcat的线程容量应该略大于最大并发数。</li>
<li>线程阻塞</li>
<li>线程死锁</li>
</ul>
<p>查看线程运行状态，可以知道线程执行情况，比如main线程大部分时间在等待，少部分时间在运行</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521154809697.png" alt="image-20210521154809697" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211018213301773.png" alt="image-20211018213301773" /></p>

        <h4 id="监视器和锁-monitors-locks"   >
          <a href="#监视器和锁-monitors-locks" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#监视器和锁-monitors-locks"></a> 监视器和锁 Monitors &amp; Locks</h4>
      
<p>所有线程持有锁的情况以及锁的信息。观察JVM的内部线程并查看状态：</p>
<ul>
<li><strong>死锁探测图表 Current Locking Graph</strong>：显示JVM中的当前死锁图表。</li>
<li><strong>目前使用的监测器 Current Monitors</strong>：显示目前使用的监测器并且包括它们的关联线程。</li>
<li><strong>锁定历史图表 Locking History Graph</strong>：显示记录在JVM中的锁定历史。</li>
<li><strong>历史检测记录 Monitor History</strong>：显示重大的等待事件和阻塞事件的历史记录。</li>
<li><strong>监控器使用统计 Monitor Usage Statistics</strong>：显示分组监测，线程和监测类的统计监测数据</li>
</ul>

        <h3 id="arthas"   >
          <a href="#arthas" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#arthas"></a> Arthas</h3>
      
<p>上述工具都必须在服务端项目进程中配置相关的监控参数，然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如<strong>线上环境的网络是隔离的</strong>，<strong>本地的监控工具根本连不上线上环境</strong>。并且类似于Jprofiler这样的商业工具，是需要付费的。那么有没有一款工具<strong>不需要远程连接</strong>，<strong>也不需要配置监控参数</strong>，同时也提供了丰富的性能监控数据呢？</p>
<p>阿里巴巴开源的性能分析神器Arthas应运而生。</p>
<p>Arthas是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。Arthas 支持JDK 6＋，支持Linux／Mac／Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p>
<ul>
<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li>
<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li>
<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li>
<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>有什么办法可以监控到JVM的实时运行状态？</li>
<li>怎么快速定位应用的热点，生成火焰图？</li>
</ul>
<blockquote>
<p>官方地址：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/quick-start.html" >https://arthas.aliyun.com/doc/quick-start.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h4 id="下载与使用"   >
          <a href="#下载与使用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#下载与使用"></a> 下载与使用</h4>
      
<p>下载方式：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https:&#x2F;&#x2F;arthas.aliyun.com&#x2F;arthas-boot.jar</span><br></pre></td></tr></table></div></figure>
<p>安装方式：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;io&#x2F;arthas&#x2F;arthas-boot.jar</span><br><span class="line">wget https:&#x2F;&#x2F;arthas&#x2F;gitee&#x2F;io&#x2F;arthas-boot.jar</span><br></pre></td></tr></table></div></figure>
<p>Arthas只是一个java程序，所以可以直接用java -jar运行。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 启动</span><br><span class="line">java -jar arthas-boot.jar</span><br><span class="line"></span><br><span class="line"># 关闭服务器(关闭所有客户端)</span><br><span class="line">stop</span><br><span class="line"></span><br><span class="line"># 关闭当前客户端</span><br><span class="line">quit</span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521195844113.png" alt="img" /></p>
<p>除了在命令行查看外，Arthas目前还支持 Web Console。在成功启动连接进程之后就已经自动启动，可以直接访问 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://127.0.0.1:8563/" >http://127.0.0.1:8563/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 访问，页面上的操作模式和控制台完全一样。</p>

        <h4 id="基础命令"   >
          <a href="#基础命令" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#基础命令"></a> 基础命令</h4>
      
<ul>
<li>help——查看命令帮助信息</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/cat.html" >cat</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——打印文件内容，和linux里的cat命令类似</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/echo.html" >echo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>–打印参数，和linux里的echo命令类似</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/grep.html" >grep</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——匹配查找，和linux里的grep命令类似</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/base64.html" >base64</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——base64编码转换，和linux里的base64命令类似</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/tee.html" >tee</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——复制标准输入到标准输出和指定的文件，和linux里的tee命令类似</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/pwd.html" >pwd</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——返回当前的工作目录，和linux命令类似</li>
<li>cls——清空当前屏幕区域</li>
<li>session——查看当前会话的信息</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/reset.html" >reset</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端关闭时会重置所有增强过的类</li>
<li>version——输出当前目标 Java 进程所加载的 Arthas 版本号</li>
<li>history——打印命令历史</li>
<li>quit——退出当前 Arthas 客户端，其他 Arthas 客户端不受影响</li>
<li>stop——关闭 Arthas 服务端，所有 Arthas 客户端全部退出</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/keymap.html" >keymap</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——Arthas快捷键列表及自定义快捷键</li>
</ul>

        <h4 id="jvm-相关"   >
          <a href="#jvm-相关" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jvm-相关"></a> JVM 相关</h4>
      
<ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/dashboard.html" >dashboard</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——当前系统的实时数据面板</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/thread.html" >thread</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——查看当前 JVM 的线程堆栈信息</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/jvm.html" >jvm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——查看当前 JVM 的信息</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sysprop.html" >sysprop</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——查看和修改JVM的系统属性</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sysenv.html" >sysenv</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——查看JVM的环境变量</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/vmoption.html" >vmoption</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——查看和修改JVM里诊断相关的option</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/perfcounter.html" >perfcounter</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——查看当前 JVM 的Perf Counter信息</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/logger.html" >logger</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——查看和修改logger</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/getstatic.html" >getstatic</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——查看类的静态属性</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/ognl.html" >ognl</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——执行ognl表达式</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/mbean.html" >mbean</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——查看 Mbean 的信息</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/heapdump.html" >heapdump</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——dump java heap, 类似jmap命令的heap dump功能</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/vmtool.html" >vmtool</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——从jvm里查询对象，执行forceGc</li>
</ul>

        <h4 id="classclassloader-相关"   >
          <a href="#classclassloader-相关" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#classclassloader-相关"></a> class/classloader 相关</h4>
      
<ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sc.html" >sc</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——查看JVM已加载的类信息</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sm.html" >sm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——查看已加载类的方法信息</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/jad.html" >jad</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——反编译指定已加载类的源码</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/mc.html" >mc</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——内存编译器，内存编译<code>.java</code>文件为<code>.class</code>文件</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/retransform.html" >retransform</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——加载外部的<code>.class</code>文件，retransform到JVM里</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/redefine.html" >redefine</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——加载外部的<code>.class</code>文件，redefine到JVM里</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/dump.html" >dump</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——dump 已加载类的 byte code 到特定目录</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/classloader.html" >classloader</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——查看classloader的继承树，urls，类加载信息，使用classloader去getResource</li>
</ul>

        <h4 id="monitorwatchtrace-相关"   >
          <a href="#monitorwatchtrace-相关" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#monitorwatchtrace-相关"></a> monitor/watch/trace 相关</h4>
      
<blockquote>
<p>请注意，这些命令，都通过字节码增强技术来实现的，会在指定类的方法中插入一些切面来实现数据统计和观测，因此在线上、预发使用时，请尽量明确需要观测的类、方法以及条件，诊断结束要执行 <code>stop</code> 或将增强过的类执行 <code>reset</code> 命令。</p>
</blockquote>
<ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/monitor.html" >monitor</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——方法执行监控</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/watch.html" >watch</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——方法执行数据观测</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/trace.html" >trace</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——方法内部调用路径，并输出方法路径上的每个节点上耗时</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/stack.html" >stack</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——输出当前方法被调用的调用路径</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/tt.html" >tt</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>——方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</li>
</ul>

        <h3 id="java-misssion-control"   >
          <a href="#java-misssion-control" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java-misssion-control"></a> Java Misssion Control</h3>
      
<p>在Oracle收购Sun之前，Oracle的JRockit虚拟机提供了一款叫做 JRockit Mission Control 的虚拟机诊断工具。在Oracle收购sun之后，Oracle公司同时拥有了Hotspot和 JRockit 两款虚拟机。根据Oracle对于Java的战略，在今后的发展中，会将JRokit的优秀特性移植到Hotspot上。其中一个重要的改进就是在Sun的JDK中加入了JRockit的支持。</p>
<p>在Oracle JDK 7.0之后，Mission Control这款工具已经绑定在Oracle JDK中发布。</p>
<p>自Java11开始，本节介绍的JFR已经开源。但在之前的Java版本，JFR属于Commercial Feature通过Java虚拟机参数<code>-XX:+UnlockCommercialFeatures</code> 开启。</p>
<p>Java Mission Control（简称JMC) ， Java官方提供的性能强劲的工具，是一个用于对 Java应用程序进行管理、监视、概要分析和故障排除的工具套件。它包含一个GUI客户端以及众多用来收集Java虚拟机性能数据的插件如 JMX Console（能够访问用来存放虚拟机齐个于系统运行数据的MXBeans）以及虚拟机内置的高效 profiling 工具 Java Flight Recorder（JFR）。</p>
<p>JMC的另一个优点就是：<strong>采用取样</strong>，<strong>而不是传统的代码植入技术，对应用性能的影响非常非常小</strong>，<strong>完全可以开着JMC来做压测（唯一影响可能是 full gc 多了）</strong>。</p>
<p>官方地址：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/JDKMissionControl/jmc" >https://github.com/JDKMissionControl/jmc</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019183843470.png" alt="image-20211019183843470" /></p>

        <h4 id="java-flight-recorder"   >
          <a href="#java-flight-recorder" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java-flight-recorder"></a> Java Flight Recorder</h4>
      
<p>Java Flight Recorder是JMC的其中一个组件，能够以极低的性能开销收集Java虚拟机的性能数据。与其他工具相比，JFR的性能开销很小，在默认配置下平均低于1%。JFR能够直接访问虚拟机内的敌据并且不会影响虚拟机的优化。因此它非常适用于生产环境下满负荷运行的Java程序。</p>
<p><strong>Java Flight Recorder 和 JDK Mission Control共同创建了一个完整的工具链</strong>。JDK Mission Control 可对 Java Flight Recorder 连续收集低水平和详细的运行时信息进行高效、详细的分析。</p>
<p>当启用时 JFR将记录运行过程中发生的一系列事件。其中包括Java层面的事件如线程事件、锁事件，以及Java虚拟机内部的事件，如新建对象，垃圾回收和即时编译事件。按照发生时机以及持续时间来划分，JFR的事件共有四种类型，它们分别为以下四种：</p>
<ul>
<li>瞬时事件（Instant Event) ，用户关心的是它们发生与否，例如异常、线程启动事件。</li>
<li>持续事件(Duration Event) ，用户关心的是它们的持续时间，例如垃圾回收事件。</li>
<li>计时事件(Timed Event) ，是时长超出指定阈值的持续事件。</li>
<li>取样事件（Sample Event)，是周期性取样的事件。</li>
</ul>
<p>取样事件的其中一个常见例子便是方法抽样（Method Sampling），即每隔一段时问统计各个线程的栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法。</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019183932731.png" alt="image-20211019183932731" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019183942592.png" alt="image-20211019183942592" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019183954641.png" alt="image-20211019183954641" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019184002347.png" alt="image-20211019184002347" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019184015271.png" alt="image-20211019184015271" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019184023306.png" alt="image-20211019184023306" /></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019184031773.png" alt="image-20211019184031773" /></p>

        <h4 id="flame-graphs火焰图"   >
          <a href="#flame-graphs火焰图" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#flame-graphs火焰图"></a> Flame Graphs（火焰图）</h4>
      
<p>在追求极致性能的场景下，了解你的程序运行过程中cpu在干什么很重要，火焰图就是一种非常直观的展示CPU在程序整个生命周期过程中时间分配的工具。火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用找中的CPU消耗瓶颈。</p>
<p>网上的关于Java火焰图的讲解大部分来自于Brenden Gregg的博客 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://new.brendangregg.com/flamegraphs.html" >http://new.brendangregg.com/flamegraphs.html </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211019184121880.png" alt="image-20211019184121880" /></p>
<p>火焰图，简单通过x轴横条宽度来度量时间指标，y轴代表线程栈的层次。</p>

        <h3 id="tprofiler"   >
          <a href="#tprofiler" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tprofiler"></a> Tprofiler</h3>
      
<blockquote>
<p>案例： 使用JDK自身提供的工具进行JVM调优可以将下 TPS 由2.5提升到20（提升了7倍），并准确 定位系统瓶颈。</p>
</blockquote>
<p>系统瓶颈有：应用里静态对象不是太多、有大量的业务线程在频繁创建一些生命周期很长的临时对象，代码里有问题。</p>
<p>那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具 Tprofiler 来定位 这些性能代码，成功解决掉了GC 过于频繁的性能瓶预，并最终在上次优化的基础上将 TPS 再提升了4倍，即提升到100。</p>
<ul>
<li>Tprofiler配置部署、远程操作、 日志阅谈都不太复杂，操作还是很简单的。但是其却是能够起到一针见血、立竿见影的效果，帮我们解决了GC过于频繁的性能瓶预。</li>
<li>Tprofiler最重要的特性就是<strong>能够统汁出你指定时间段内 JVM 的 top method</strong>。这些 top method 极有可能就是造成你 JVM 性能瓶颈的元凶。这是其他大多数 JVM 调优工具所不具备的，包括 JRockit Mission Control。JRokit 首席开发者 Marcus Hirt 在其私人博客《 Lom Overhead Method Profiling cith Java Mission Control》下的评论中曾明确指出  JRMC 井不支持 TOP 方法的统计。</li>
</ul>
<p>官方地址：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://github.com/alibaba/Tprofiler" >http://github.com/alibaba/Tprofiler</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="btrace"   >
          <a href="#btrace" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#btrace"></a> Btrace</h3>
      
<p>常见的动态追踪工具有BTrace、HouseHD（该项目己经停止开发）、Greys-Anatomy（国人开发 个人开发者）、Byteman（JBoss出品），注意Java运行时追踪工具井不限干这几种，但是这几个是相对比较常用的。</p>
<p>BTrace是SUN Kenai 云计算开发平台下的一个开源项目，旨在为java提供安全可靠的动态跟踪分析工具。先看一卜日Trace的官方定义：</p>
<blockquote>
<p>一个 Java 平台的安全的动态追踪工具，可以用来动态地追踪一个运行的 Java 程序。BTrace动态调整目标应用程序的类以注入跟踪代码（“字节码跟踪“）。</p>
</blockquote>
<p>其他小众监控工具：</p>
<ul>
<li><strong>YourKit</strong></li>
<li><strong>JProbe</strong></li>
<li><strong>Spring Insight</strong></li>
</ul>

        <h2 id="jvm-运行时参数"   >
          <a href="#jvm-运行时参数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jvm-运行时参数"></a> JVM 运行时参数</h2>
      
<blockquote>
<p>官网地址：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html" >https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>JVM 的运行时参数可以分为三类：</p>
<ul>
<li>标准参数选项</li>
<li>-X参数选项</li>
<li>-XX:参数选项</li>
</ul>

        <h3 id="添加-jvm-参数选项"   >
          <a href="#添加-jvm-参数选项" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#添加-jvm-参数选项"></a> 添加 JVM 参数选项</h3>
      
<p>运行 jar 包</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms100m -Xmx100m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -jar demo.jar</span><br></pre></td></tr></table></div></figure>
<p>Tomcat 运行 war 包</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linux下catalina.sh添加</span></span><br><span class="line">JAVA_OPTS=<span class="string">&quot;-Xms512M -Xmx1024M&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># windows下catalina.bat添加</span></span><br><span class="line"><span class="built_in">set</span> <span class="string">&quot;JAVA_OPTS=-Xms512M -Xmx1024M&quot;</span></span><br></pre></td></tr></table></div></figure>
<p>程序运行中</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置Boolean类型参数</span></span><br><span class="line">jinfo -flag [+|-]&lt;name&gt; &lt;pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置非Boolean类型参数</span></span><br><span class="line">jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</span><br></pre></td></tr></table></div></figure>

        <h3 id="类型一标准参数选项"   >
          <a href="#类型一标准参数选项" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类型一标准参数选项"></a> 类型一：标准参数选项</h3>
      
<p>特点：</p>
<ul>
<li>以<code>-</code>开头</li>
<li>稳定，后续版本基本不变</li>
<li>不常用</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> java -<span class="built_in">help</span></span></span><br><span class="line">用法: java [-options] class [args...]</span><br><span class="line">           (执行类)</span><br><span class="line">   或  java [-options] -jar jarfile [args...]</span><br><span class="line">           (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">    -d32          使用 32 位数据模型 (如果可用)</span><br><span class="line">    -d64          使用 64 位数据模型 (如果可用)</span><br><span class="line">    -server       选择 &quot;server&quot; VM</span><br><span class="line">                  默认 VM 是 server.</span><br><span class="line"></span><br><span class="line">    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">                  用 ; 分隔的目录, JAR 档案</span><br><span class="line">                  和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line">    -D&lt;名称&gt;=&lt;值&gt;</span><br><span class="line">                  设置系统属性</span><br><span class="line">    -verbose:[class|gc|jni]</span><br><span class="line">                  启用详细输出</span><br><span class="line">    -version      输出产品版本并退出</span><br><span class="line">    -version:&lt;值&gt;</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  需要指定的版本才能运行</span><br><span class="line">    -showversion  输出产品版本并继续</span><br><span class="line">    -jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  在版本搜索中包括/排除用户专用 JRE</span><br><span class="line">    -? -help      输出此帮助消息</span><br><span class="line">    -X            输出非标准选项的帮助</span><br><span class="line">    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  按指定的粒度启用断言</span><br><span class="line">    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  禁用具有指定粒度的断言</span><br><span class="line">    -esa | -enablesystemassertions</span><br><span class="line">                  启用系统断言</span><br><span class="line">    -dsa | -disablesystemassertions</span><br><span class="line">                  禁用系统断言</span><br><span class="line">    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help</span><br><span class="line">    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  按完整路径名加载本机代理库</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  使用指定的图像显示启动屏幕</span><br><span class="line">有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。</span><br></pre></td></tr></table></div></figure>
<p><strong>Server 模式和 Client 模式</strong></p>
<p>Hotspot JVM有两种模式，分别是server和client，分别通过<code>-server</code>和<code>-client</code>参数设置</p>
<ul>
<li>32位系统上，默认使用client类型的JVM。要想使用Server模式，机器配置至少有2个以上的CPU和2G以上的物理内存。client模式适用于对内存要求较小的桌面应用程序，默认使用Serial串行垃圾收集器</li>
<li><strong>64位系统上，只支持server模式的JVM</strong>，适用于需要大内存的应用程序，默认使用并行垃圾收集器</li>
</ul>
<blockquote>
<p>官网地址：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html" >https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>如何知道系统默认使用的是哪种模式呢：通过<code>java -version</code>命令：可以看到Server VM字样，代表当前系统使用是Server模式</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> java -version</span></span><br><span class="line">java version &quot;1.8.0_201&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_201-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</span><br></pre></td></tr></table></div></figure>

        <h3 id="类型二-x参数选项"   >
          <a href="#类型二-x参数选项" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类型二-x参数选项"></a> 类型二：-X参数选项</h3>
      
<p>特点：</p>
<ul>
<li>以<code>-X</code>开头</li>
<li>较稳定，后续版本可能改变</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> java -X</span></span><br><span class="line">    -Xmixed           混合模式执行 (默认)</span><br><span class="line">    -Xint             仅解释模式执行</span><br><span class="line">    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      设置搜索路径以引导类和资源</span><br><span class="line">    -Xbootclasspath/a:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      附加在引导类路径末尾</span><br><span class="line">    -Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      置于引导类路径之前</span><br><span class="line">    -Xdiag            显示附加诊断消息</span><br><span class="line">    -Xnoclassgc       禁用类垃圾收集</span><br><span class="line">    -Xincgc           启用增量垃圾收集</span><br><span class="line">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)</span><br><span class="line">    -Xbatch           禁用后台编译</span><br><span class="line">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class="line">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class="line">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class="line">    -Xprof            输出 cpu 配置文件数据</span><br><span class="line">    -Xfuture          启用最严格的检查, 预期将来的默认值</span><br><span class="line">    -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)</span><br><span class="line">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">    -Xshare:off       不尝试使用共享类数据</span><br><span class="line">    -Xshare:auto      在可能的情况下使用共享类数据 (默认)</span><br><span class="line">    -Xshare:on        要求使用共享类数据, 否则将失败。</span><br><span class="line">    -XshowSettings    显示所有设置并继续</span><br><span class="line">    -XshowSettings:all</span><br><span class="line">                      显示所有设置并继续</span><br><span class="line">    -XshowSettings:vm 显示所有与 vm 相关的设置并继续</span><br><span class="line">    -XshowSettings:properties</span><br><span class="line">                      显示所有属性设置并继续</span><br><span class="line">    -XshowSettings:locale</span><br><span class="line">                      显示所有与区域设置相关的设置并继续</span><br><span class="line"></span><br><span class="line">-X 选项是非标准选项, 如有更改, 恕不另行通知。</span><br></pre></td></tr></table></div></figure>
<p>其中，<strong>重点需要记忆的参数有</strong>：</p>
<p>1、和解释器相关的参数：</p>
<ul>
<li><code>-Xint</code>：只使用解释器</li>
<li><code>-Xcomp</code>：只使用编译器</li>
<li><code>-Xmixed</code>：混用（默认选项），前期解释器解释字节码执行，等程序运行起来后后端编译器缓存热点代码，加速执行效率</li>
</ul>
<p>2、<strong>和堆内存相关的参数</strong>：</p>
<ul>
<li><code>-Xss</code>：设置<strong>线程</strong>（栈）内存大小，等效于<code>-XX:ThreadStackSize</code>（记忆：Stack Size）</li>
<li><code>-Xms</code>：设置堆内存<strong>初始</strong>大小，等效于<code>-XX:InitalHeapSize</code>（记忆：Memory Size）</li>
<li><code>-Xmx</code>：设置堆内存<strong>最大</strong>大小，等效于 <code>-XX:MaxHeapSize</code>（记忆：Memory maX）</li>
<li><code>-Xmn</code>：设置<strong>年轻代</strong>内存，等同于<code>-XX:NewSize</code>+<code>-XX:MaxNewSize</code>（记忆：Memory New）</li>
</ul>
<p>3、日志相关：</p>
<ul>
<li><code>-Xloggc:&lt;file&gt;</code>：将 GC 状态记录在文件中 （带时间戳）；可以使用 <strong>GCeasy</strong> 网站分析 GC 记录，<a href="#GC-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90">GC 日志分析</a></li>
</ul>
<hr />
<p><code>-Xms</code> 和 <code>-Xmx</code> 两个参数设置相同的值，目的是为了能够在每次GC后不需要再重新计算堆区要分配的大小，从而提高性能。</p>
<p>如果二者设置不相同，则每次GC后，会根据当前GC的效果动态调整堆区的大小：回收效果好 -&gt; 减小堆区大小；回收效果差 -&gt; 增大堆区大小</p>
<hr />

        <h3 id="类型三-xx参数选项"   >
          <a href="#类型三-xx参数选项" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类型三-xx参数选项"></a> 类型三：-XX:参数选项</h3>
      
<p>特点：</p>
<ul>
<li>以<code>-XX:</code>开头</li>
<li>不稳定，后续版本会改动</li>
<li>常用</li>
</ul>
<p><strong>Boolean 类型格式</strong></p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+&lt;option&gt;  <span class="comment"># 启用option属性，例如 -XX:+UseParallelGC：使用parallel垃圾收集器</span></span><br><span class="line">-XX:-&lt;option&gt;  <span class="comment"># 禁用option属性，例如 -XX:-UseParallelGC：不使用parallel垃圾收集器</span></span><br></pre></td></tr></table></div></figure>
<p><strong>非 Boolean 类型格式</strong></p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:&lt;option&gt;=&lt;number&gt;  <span class="comment"># 设置option数值，可以带单位如k/K/m/M/g/G，例如 -XX:SurvivorRatio=8 设置新生代中Eden区与survivor区占比为: 8:1:1</span></span><br><span class="line">-XX:&lt;option&gt;=&lt;string&gt;  <span class="comment"># 设置option字符值，例如 -XX:HeapDumpPath=/usr/local/cl.hprof 设置堆Dump快照放在此地址</span></span><br></pre></td></tr></table></div></figure>
<p>其中，<strong>重点需要记忆的参数有</strong>：</p>
<ul>
<li><code>-XX:+PrintFlagsFinal</code>：打印所有-XX选项的实际值</li>
<li><code>-XX:NewRatio=2</code>：设置老年代与年轻代的比例，默认为2</li>
<li><code>-XX:SurvivorRatio=8</code>：设置Eden区与Survivor区的比值，默认为8（虽然默认是8，但是因为默认开启了 <code>-XX:+UseAdaptiveSizePolicy</code> 自动调整策略，导致实际的新生代内比例可能不是8）</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：设置堆空间大小比例自适应，默认开启</li>
</ul>

        <h4 id="打印设置的-xx选项及值"   >
          <a href="#打印设置的-xx选项及值" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#打印设置的-xx选项及值"></a> 打印设置的-XX选项及值</h4>
      
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags  <span class="comment"># 程序运行时JVM默认设置或用户手动设置的XX选项</span></span><br><span class="line">-XX:+PrintFlagsInitial      <span class="comment"># 打印所有XX选项的默认值</span></span><br><span class="line">-XX:+PrintFlagsFinal        <span class="comment"># 打印所有XX选项的实际值</span></span><br><span class="line">-XX:+PrintVMOptions         <span class="comment"># 打印JVM的参数</span></span><br></pre></td></tr></table></div></figure>
<p><code>-XX:+PrintCommandLineFlags</code> ：打印<strong>命令行启动时添加</strong>的-XX选项或JVM自动设置的-XX选项</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521233837255.png" alt="img" /></p>
<p><code>-XX:+PrintFlagsInitinal</code> ：打印出所有-XX选项<strong>默认值</strong></p>
<p><img src="https://gitee.com/tcl192243051/studyJVM/raw/master/4_%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%AF%87/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0.assets/image-20210521234011514.png" alt="image-20210521234011514" /></p>
<p><code>-XX:+PrintFlagsFinal</code> ：打印出-XX选项<strong>最终</strong>在程序运行时的值（使用 <code>jinfo -flag 修改参数 pid</code> 进行修改）</p>
<p><img src="https://gitee.com/tcl192243051/studyJVM/raw/master/4_%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%AF%87/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0.assets/image-20210521234301291.png" alt="image-20210521234301291" /></p>
<ul>
<li>
<p>``-XX:+PrintVMOption` 打印JVM参数</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20210521234626600.png" alt="image-20210521234626600" /></p>
</li>
</ul>

        <h4 id="堆-栈-方法区等内存大小设置"   >
          <a href="#堆-栈-方法区等内存大小设置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#堆-栈-方法区等内存大小设置"></a> 堆、栈、方法区等内存大小设置</h4>
      
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 栈</span></span><br><span class="line">-Xss128k &lt;==&gt; -XX:ThreadStackSize=128k       <span class="comment"># 设置线程栈的大小为128K</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆</span></span><br><span class="line">-Xms2048m &lt;==&gt; -XX:InitialHeapSize=2048m     <span class="comment"># 设置JVM初始堆内存为2048M</span></span><br><span class="line">-Xmx2048m &lt;==&gt; -XX:MaxHeapSize=2048m         <span class="comment"># 设置JVM最大堆内存为2048M</span></span><br><span class="line">-Xmn2g &lt;==&gt; -XX:NewSize=2g -XX:MaxNewSize=2g <span class="comment"># 设置年轻代大小为2G</span></span><br><span class="line">-XX:SurvivorRatio=8                          <span class="comment"># 设置Eden区与Survivor区的比值，默认为8</span></span><br><span class="line">-XX:NewRatio=2                               <span class="comment"># 设置老年代与年轻代的比例，默认为2</span></span><br><span class="line">-XX:+UseAdaptiveSizePolicy                   <span class="comment"># 设置大小比例自适应，默认开启</span></span><br><span class="line">-XX:PretenureSizeThreadshold=1024            <span class="comment"># 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效</span></span><br><span class="line">-XX:MaxTenuringThreshold=15                  <span class="comment"># 设置新生代晋升老年代的年龄限制，默认为15</span></span><br><span class="line">-XX:TargetSurvivorRatio                      <span class="comment"># 设置MinorGC结束后Survivor区占用空间的期望比例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法区</span></span><br><span class="line">-XX:MetaspaceSize / -XX:PermSize=256m        <span class="comment"># 设置元空间/永久代初始值为256M</span></span><br><span class="line">-XX:MaxMetaspaceSize / -XX:MaxPermSize=256m  <span class="comment"># 设置元空间/永久代最大值为256M</span></span><br><span class="line">-XX:+UseCompressedOops                       <span class="comment"># 使用压缩对象</span></span><br><span class="line">-XX:+UseCompressedClassPointers              <span class="comment"># 使用压缩类指针</span></span><br><span class="line">-XX:CompressedClassSpaceSize                 <span class="comment"># 设置Klass Metaspace的大小，默认1G</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接内存</span></span><br><span class="line">-XX:MaxDirectMemorySize                      <span class="comment"># 指定DirectMemory容量，默认等于Java堆最大值</span></span><br></pre></td></tr></table></div></figure>

        <h4 id="outofmemory-相关的选项"   >
          <a href="#outofmemory-相关的选项" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#outofmemory-相关的选项"></a> OutOfMemory 相关的选项</h4>
      
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutMemoryError    <span class="comment"># 内存出现OOM时生成Heap转储文件，两者互斥</span></span><br><span class="line">-XX:+HeapDumpBeforeFullGC        <span class="comment"># 出现FullGC时生成Heap转储文件，两者互斥</span></span><br><span class="line">-XX:HeapDumpPath=&lt;path&gt;          <span class="comment"># 指定heap转储文件的存储路径，默认当前目录</span></span><br><span class="line">-XX:OnOutOfMemoryError=&lt;path&gt;    <span class="comment"># 指定可行性程序或脚本的路径，当发生OOM时执行脚本</span></span><br></pre></td></tr></table></div></figure>

        <h4 id="垃圾收集器相关选项"   >
          <a href="#垃圾收集器相关选项" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#垃圾收集器相关选项"></a> 垃圾收集器相关选项</h4>
      
<p>首先需了解垃圾收集器之间的搭配使用关系：</p>
<ul>
<li>红色虚线表示在jdk8时被Deprecate，jdk9时被删除</li>
<li>绿色虚线表示在jdk14时被Deprecate</li>
<li>绿色虚框表示在jdk9时被Deprecate，jdk14时被删除</li>
</ul>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200713094745366.png" alt="image-20200713094745366" /></p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Serial回收器 </span></span><br><span class="line">-XX:+UseSerialGC           <span class="comment"># 年轻代使用Serial GC，老年代使用Serial Old GC</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ParNew回收器</span></span><br><span class="line">-XX:+UseParNewGC            <span class="comment"># 年轻代使用ParNew GC</span></span><br><span class="line">-XX:ParallelGCThreads       <span class="comment"># 设置年轻代并行收集器的线程数。</span></span><br><span class="line">                            <span class="comment"># 一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</span></span><br><span class="line">                       </span><br><span class="line"><span class="comment"># Parallel回收器 </span></span><br><span class="line">-XX:+UseParallelGC          <span class="comment"># 年轻代使用 Parallel Scavenge GC，互相激活</span></span><br><span class="line">-XX:+UseParallelOldGC       <span class="comment"># 老年代使用 Parallel Old GC，互相激活</span></span><br><span class="line">-XX:ParallelGCThreads</span><br><span class="line">-XX:MaxGCPauseMillis        <span class="comment"># 设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。</span></span><br><span class="line">                            <span class="comment"># 为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</span></span><br><span class="line">                            <span class="comment"># 对于用户来讲，停顿时间越短体验越好；但是服务器端注重高并发，整体的吞吐量。</span></span><br><span class="line">                            <span class="comment"># 所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</span></span><br><span class="line"></span><br><span class="line">-XX:GCTimeRatio             <span class="comment"># 垃圾收集时间占总时间的比例（1 / (N＋1)），用于衡量吞吐量的大小</span></span><br><span class="line">                            <span class="comment"># 取值范围（0,100），默认值99，也就是垃圾回收时间不超过1％。</span></span><br><span class="line">                            <span class="comment"># 与前一个-XX：MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</span></span><br><span class="line"></span><br><span class="line">-XX:+UseAdaptiveSizePolicy  <span class="comment"># 设置Parallel Scavenge收集器具有自适应调节策略。</span></span><br><span class="line">                            <span class="comment"># 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</span></span><br><span class="line">                            <span class="comment"># 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），</span></span><br><span class="line">                            <span class="comment"># 让虚拟机自己完成调优工作。</span></span><br></pre></td></tr></table></div></figure>
<p>其中，并行GC线程的线程数的经验公式：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211020104915344.png" alt="image-20211020104915344" /></p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMS回收器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC             <span class="comment"># 年轻代使用CMS GC。开启该参数后会自动将-XX：＋UseParNewGC打开。</span></span><br><span class="line">                                    <span class="comment"># 即：ParNew（Young区）+ CMS（Old区）+ Serial Old的组合</span></span><br><span class="line">-XX:CMSInitiatingOccupanyFraction   <span class="comment"># 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68，DK6及以上版本默认值为92％。</span></span><br><span class="line">                                    <span class="comment"># 如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。</span></span><br><span class="line">                                    <span class="comment"># 反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。</span></span><br><span class="line">                                    <span class="comment"># 因此通过该选项便可以有效降低Fu1l GC的执行次数。</span></span><br><span class="line"></span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly  <span class="comment"># 是否动态可调，使CMS一直按CMSInitiatingOccupancyFraction设定的值启动</span></span><br><span class="line"></span><br><span class="line">-XX:+UseCMSCompactAtFullCollection  <span class="comment"># 用于指定在执行完Full GC后对内存空间进行压缩整理以此避免内存碎片的产生。</span></span><br><span class="line">                                    <span class="comment"># 不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</span></span><br><span class="line"></span><br><span class="line">-XX:CMSFullGCsBeforeCompaction      <span class="comment"># 设置在执行多少次Full GC后对内存空间进行压缩整理。</span></span><br><span class="line"></span><br><span class="line">-XX:ParallelCMSThreads              <span class="comment"># 设置CMS的线程数量。CMS 默认启动的线程数是(ParallelGCThreads＋3)/4，</span></span><br><span class="line">                                    <span class="comment"># ParallelGCThreads 是年轻代并行收集器的线程数。</span></span><br><span class="line">                                    <span class="comment"># 当 CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</span></span><br><span class="line"></span><br><span class="line">-XX:ConcGCThreads                   <span class="comment"># 设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的</span></span><br><span class="line">-XX:+CMSScavengeBeforeRemark        <span class="comment"># 强制hotspot在cms remark阶段之前做一次minor gc，用于提高remark阶段的速度</span></span><br><span class="line">-XX:+CMSClassUnloadingEnable        <span class="comment"># 如果有的话，启用回收Perm 区（JDK8之前）</span></span><br><span class="line">-XX:+CMSParallelInitialEnabled      <span class="comment"># 用于开启CMS initial-mark阶段采用多线程的方式进行标记</span></span><br><span class="line">                                    <span class="comment"># 用于提高标记速度，在Java8开始已经默认开启</span></span><br><span class="line">-XX:+CMSParallelRemarkEnabled       <span class="comment"># 用户开启CMS remark阶段采用多线程的方式进行重新标记，默认开启</span></span><br><span class="line">-XX:+ExplicitGCInvokesConcurrent    <span class="comment"># 这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期</span></span><br><span class="line">-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses </span><br><span class="line">                                    </span><br><span class="line">-XX:+CMSPrecleaningEnabled          <span class="comment"># 指定CMS是否需要进行Pre cleaning阶段</span></span><br></pre></td></tr></table></div></figure>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># G1回收器</span></span><br><span class="line">-XX:+UseG1GC                        <span class="comment"># 手动指定使用G1收集器执行内存回收任务。</span></span><br><span class="line">-XX:G1HeapRegionSize                <span class="comment"># 设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，</span></span><br><span class="line">                                    <span class="comment"># 目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</span></span><br><span class="line">-XX:MaxGCPauseMillis                <span class="comment"># 设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</span></span><br><span class="line">-XX:ParallelGCThread                <span class="comment"># 设置STW时GC线程数的值。最多设置为8</span></span><br><span class="line">-XX:ConcGCThreads                   <span class="comment"># 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。</span></span><br><span class="line">-XX:InitiatingHeapOccupancyPercent  <span class="comment"># 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</span></span><br><span class="line">-XX:G1NewSizePercent                <span class="comment"># 新生代占用整个堆内存的最小百分比（默认5％）</span></span><br><span class="line">-XX:G1MaxNewSizePercent             <span class="comment"># 新生代占用整个堆内存的最大百分比（默认60％）</span></span><br><span class="line">-XX:G1ReservePercent=10             <span class="comment"># 保留内存区域，防止 to space（Survivor中的to区）溢出</span></span><br></pre></td></tr></table></div></figure>
<p><strong>注意</strong>：使用分代收集器G1时最好不要使用<code>-XX:NewRatio</code> ， <code>-Xmn</code>这种指定年轻代内存大小的参数，而是应该交给G1自动计算年轻代所占的内存大小以满足其<strong>低延迟的暂停时间</strong>，否则G1里的 <code>-XX:MaxGCPauseMillis</code> 可能无法实现。</p>
<p>怎么选择垃圾回收器？</p>
<ul>
<li>优先让JVM自适应，调整堆的大小</li>
<li>串行收集器：内存小于100M；单核、单机程序，并且没有停顿时间的要求</li>
<li>并行收集器：多CPU、高吞吐量、允许停顿时间超过1秒</li>
<li>并发收集器：多CPU、追求低停顿时间、快速响应（比如延迟不能超过1秒，如互联网应用）</li>
<li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1</li>
</ul>

        <h3 id="gc-日志相关选项"   >
          <a href="#gc-日志相关选项" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#gc-日志相关选项"></a> GC 日志相关选项</h3>
      
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC &lt;==&gt; -verbose:gc          <span class="comment"># 打印简要日志信息</span></span><br><span class="line">-XX:+PrintGCDetails                    <span class="comment"># 打印详细日志信息</span></span><br><span class="line">-XX:+PrintGCTimeStamps                 <span class="comment"># 打印程序启动到GC发生的时间，搭配-XX:+PrintGCDetails使用</span></span><br><span class="line">-XX:+PrintGCDateStamps                 <span class="comment"># 打印GC发生时的时间戳，搭配-XX:+PrintGCDetails使用</span></span><br><span class="line">-XX:+PrintHeapAtGC                     <span class="comment"># 打印GC前后的堆信息，如下图</span></span><br><span class="line">-Xloggc:&lt;file&gt;                         <span class="comment"># 输出GC导指定路径下的文件中</span></span><br><span class="line">-XX:+TraceClassLoading                 <span class="comment"># 监控类的加载</span></span><br><span class="line">-XX:+PrintGCApplicationStoppedTime     <span class="comment"># 打印GC时线程的停顿时间</span></span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime  <span class="comment"># 打印垃圾收集之前应用未中断的执行时间</span></span><br><span class="line">-XX:+PrintReferenceGC                  <span class="comment"># 打印回收了多少种不同引用类型的引用</span></span><br><span class="line">-XX:+PrintTenuringDistribution         <span class="comment"># 打印JVM在每次MinorGC后当前使用的Survivor中对象的年龄分布</span></span><br><span class="line">-XX:+UseGCLogFileRotation              <span class="comment"># 启用GC日志文件的自动转储</span></span><br><span class="line">-XX:NumberOfGCLogFiles=1               <span class="comment"># 设置GC日志文件的循环数目</span></span><br><span class="line">-XX:GCLogFileSize=1M                   <span class="comment"># 设置GC日志文件的大小</span></span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20211020105935721.png" alt="image-20211020105935721" /></p>

        <h3 id="其他参数"   >
          <a href="#其他参数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#其他参数"></a> 其他参数</h3>
      
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DisableExplicitGC     <span class="comment"># 禁用hotspot执行System.gc()，默认禁用</span></span><br><span class="line">-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]、-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]  <span class="comment"># 指定代码缓存的大小</span></span><br><span class="line">-XX:+UseCodeCacheFlushing  <span class="comment"># 放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</span></span><br><span class="line">-XX:+DoEscapeAnalysis      <span class="comment"># 开启逃逸分析</span></span><br><span class="line">-XX:+UseBiasedLocking      <span class="comment"># 开启偏向锁</span></span><br><span class="line">-XX:+UseLargePages         <span class="comment"># 开启使用大页面</span></span><br><span class="line">-XX:+PrintTLAB             <span class="comment"># 打印TLAB的使用情况</span></span><br><span class="line">-XX:TLABSize               <span class="comment"># 设置TLAB大小</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="通过-java-代码获取-jvm-参数"   >
          <a href="#通过-java-代码获取-jvm-参数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#通过-java-代码获取-jvm-参数"></a> 通过 Java 代码获取 JVM 参数</h3>
      
<p>Java提供了<code>java.lang.management</code>包用于监视和管理Java虚拟机和Java运行时中的其他组件，它允许本地或远程监控和管理运行的Java虚拟机。其中<code>ManagementFactory</code>类较为常用，另外<code>Runtime</code>类可获取内存、CPU核数等相关的数据。通过使用这些api，可以监控应用服务器的堆内存使用情况，设置一些阈值进行报警等处理。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryMonitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MemoryMXBean memorymbean = ManagementFactory.getMemoryMXBean();</span><br><span class="line">        MemoryUsage usage = memorymbean.getHeapMemoryUsage();</span><br><span class="line">        System.out.println(<span class="string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\nFull Information:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Heap Memory Usage: &quot;</span> + memorymbean.getHeapMemoryUsage());</span><br><span class="line">        System.out.println(<span class="string">&quot;Non-Heap Memory Usage: &quot;</span> + memorymbean.getNonHeapMemoryUsage());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================通过java来获取相关系统状态============================ &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前堆内存大小totalMemory &quot;</span> + (<span class="keyword">int</span>) Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 当前堆内存大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;空闲堆内存大小freeMemory &quot;</span> + (<span class="keyword">int</span>) Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 空闲堆内存大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最大可用总堆内存maxMemory &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 最大可用总堆内存大小</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="gc-日志分析"   >
          <a href="#gc-日志分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#gc-日志分析"></a> GC 日志分析</h2>
      

        <h3 id="gc-分类"   >
          <a href="#gc-分类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#gc-分类"></a> GC 分类</h3>
      
<p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p>
<ul>
<li>部分收集（Partial GC）：不是完整收集整个Java堆的垃圾收集。其中又分为：
<ul>
<li>新生代收集（Minor GC / Young GC）：只是新生代（Eden / S0, S1）的垃圾收集</li>
<li>老年代收集（Major GC / Old GC）：只是老年代的垃圾收集。目前，只有CMS GC会有单独收集老年代的行为。注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li>
<li>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</li>
</ul>

        <h3 id="参数解析"   >
          <a href="#参数解析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数解析"></a> 参数解析</h3>
      
<p><strong>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</strong></p>
<p>内存分配与垃圾回收的参数列表</p>
<ul>
<li><code>-XX:+PrintGC</code>：输出GC日志。类似：<code>-verbose:gc</code></li>
<li><code>-XX:+PrintGCDetails</code>：输出GC的详细日志</li>
<li><code>-XX:+PrintGCTimestamps</code> ：输出GC的时间戳（以基准时间的形式）</li>
<li><code>-XX:+PrintGCDatestamps</code> ：输出GC的时间戳（以日期的形式，如2013-05-04T21: 53: 59.234 +0800）</li>
<li><code>-XX:+PrintHeapAtGC</code> ：在进行GC的前后打印出堆的信息</li>
<li><code>-Xloggc:…/logs/gc.log</code> ：日志文件的输出路径</li>
</ul>
<blockquote>
<p><strong>verbose:gc</strong></p>
</blockquote>
<p>打开GC日志的 JVM 参数：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc</span><br></pre></td></tr></table></div></figure>
<p>这个只会显示总的GC堆的变化，如下：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714081610474.png" alt="image-20200714081610474" /></p>
<p>参数解析：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714081622526.png" alt="image-20200714081622526" /></p>
<blockquote>
<p><strong>PrintGCDetails</strong></p>
</blockquote>
<p>打开GC日志</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></div></figure>
<p>输入信息如下：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714081909309.png" alt="image-20200714081909309" /></p>
<p>参数解析：</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714081925767.png" alt="image-20200714081925767" /></p>
<blockquote>
<p><strong>PrintGCTimestamps 和 PrintGCDatestamps</strong></p>
</blockquote>
<p>加上这两个参数后，打印的GC日志就会带上日期时间信息。</p>

        <h3 id="gc-日志补充说明"   >
          <a href="#gc-日志补充说明" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#gc-日志补充说明"></a> GC 日志补充说明</h3>
      
<ul>
<li>“[GC”和”[Full GC”说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World”</li>
<li>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</li>
<li>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</li>
<li>使用Parallel scavenge收集器在新生代的名字是”[PSYoungGen”</li>
<li>老年代的收集和新生代道理一样，名字也是收集器决定的</li>
<li>使用G1收集器的话，会显示为”garbage-first heap”</li>
<li>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</li>
<li>[ PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt;704K (9216K)
<ul>
<li>中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）</li>
<li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li>
</ul>
</li>
<li>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核线程切换的原因，时间总和可能会超过real时间</li>
</ul>

        <h3 id="young-gc"   >
          <a href="#young-gc" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#young-gc"></a> Young GC</h3>
      
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714082555688.png" alt="image-20200714082555688" /></p>

        <h3 id="full-gc"   >
          <a href="#full-gc" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#full-gc"></a> Full GC</h3>
      
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714082714690.png" alt="image-20200714082714690" /></p>

        <h3 id="gc-日志结构剖析"   >
          <a href="#gc-日志结构剖析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#gc-日志结构剖析"></a> GC 日志结构剖析</h3>
      
<p><strong>透过日志看垃圾收集器</strong></p>
<ul>
<li>Serial收集器：新生代显示 “[DefNew”，即 Default New Generation</li>
<li>ParNew收集器：新生代显示 “[ParNew”，即 Parallel New Generation</li>
<li>Parallel Scavenge收集器：新生代显示&quot;[PSYoungGen&quot;，JDK1.7使用的即PSYoungGen</li>
<li>Parallel Old收集器：老年代显示&quot;[ParoldGen&quot;</li>
<li>G1收集器：显示”garbage-first heap“</li>
</ul>
<p><strong>透过日志看 GC 原因</strong></p>
<ul>
<li>Allocation Failure：表明本次引起GC的原因是因为新生代中没有足够的区域存放需要分配的数据</li>
<li>Metadata GC Threshold：Metaspace区不够用了</li>
<li>FErgonomics：JVM自适应调整导致的GC</li>
<li>System：调用了System.gc()方法</li>
</ul>
<p><strong>透过日志看 GC 前后情况</strong></p>
<p>通过图示，我们可以发现GC日志格式的规律一般都是：GC前内存占用-＞GC后内存占用（该区域内存总大小）</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PSYoungGen: 5986K-&gt;696K (8704K) ] 5986K-&gt;704K (9216K)</span><br></pre></td></tr></table></div></figure>
<ul>
<li>中括号内：GC回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</li>
<li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li>
</ul>
<p><strong>注意</strong>：Minor GC堆内存总容量 = <strong>9/10</strong> 年轻代 + 老年代。原因是Survivor区只计算from部分，而JVM默认年轻代中Eden区和Survivor区的比例关系，Eden:S0:S1=8:1:1。</p>
<blockquote>
<p>面试题：为什么GC日志里显示的堆内存总容量比 <code>-Xms</code> 设置的要小？</p>
<p>因为GC日志里只显示了 <strong>9/10</strong> 年轻代 + 老年代，自然比设置的值要小。补充：这里的 9/10 要根据实际情况来定，可能开了自适应调整策略会导致该值变化。</p>
</blockquote>
<p><strong>透过日志看 GC 时间</strong></p>
<p>GC日志中有三个时间：user，sys和real</p>
<ul>
<li>user：进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际CPU 时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示GC线程执行所使用的 CPU 总时间。</li>
<li>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的CPU 时间</li>
<li>real：程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成）。对于并行gc，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数。</li>
</ul>
<p>由于多核的原因，一般的GC事件中，real time是小于sys time＋user time的，因为一般是多个线程并发的去做GC，所以real time是要小于sys＋user time的。如果real＞sys＋user的话，则你的应用可能存在下列问题：IO负载非常重或CPU不够用。</p>

        <h3 id="gc-回收举例"   >
          <a href="#gc-回收举例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#gc-回收举例"></a> GC 回收举例</h3>
      
<p>我们编写一个程序，用来说明GC收集的过程</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCUseTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> [] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> *_1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> *_1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> *_1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> *_1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>我们设置JVM启动参数</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></div></figure>
<p>首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714083332238.png" alt="image-20200714083332238" /></p>
<p>然后我们将4M对象存入到Eden区中</p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714083526790.png" alt="image-20200714083526790" /></p>

        <h3 id="常用日志分析工具"   >
          <a href="#常用日志分析工具" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#常用日志分析工具"></a> 常用日志分析工具</h3>
      
<p><strong>保存日志文件</strong></p>
<p><strong>JVM参数</strong>：<code>-XLoggc:./logs/gc.log</code>， ./ 表示当前目录，在 IDEA中程序运行的当前目录是工程的根目录，而不是模块的根目录</p>
<p>可以用一些工具去分析这些GC日志 gc.log。常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等</p>
<p><strong>推荐：GCeasy</strong></p>
<p>在线分析网址：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://gceasy.io" >gceasy.io</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714084726824.png" alt="image-20200714084726824" /></p>
<p><strong>GCViewer</strong></p>
<p><img src="/images/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/image-20200714084921184.png" alt="image-20200714084921184" /></p>

        <h2 id="补充oql"   >
          <a href="#补充oql" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#补充oql"></a> 补充：OQL</h2>
      
<p>Visual VM 和 MAT 都支持一种类似于SQL的查询语言OQL（Object Query Language）。OQL使用类SQL语法，可以在堆中进行对象的查找和筛选。</p>

        <h3 id="select-子句"   >
          <a href="#select-子句" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#select-子句"></a> SELECT 子句</h3>
      
<p>在MAT中，Select子句的格式与SQL基本一致，用于指定要显示的列。Select子句中可以使用“＊”，查看结果对象的引用实例（相当于outgoing references）。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.util.Vector v</span><br></pre></td></tr></table></div></figure>
<p>使用“</p>
<p>OBJECTS”关键字，可以将返回结果集中的项以对象的形式显示。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> objects v.elementData <span class="keyword">FROM</span> java.util.Vector v</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> OBJECTS s.value <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></div></figure>
<p>在Select子句中，使用“AS RETAINED SET”关键字可以得到所得对象的保留集。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AS</span> RETAINED <span class="keyword">SET</span> <span class="operator">*</span><span class="keyword">FROM</span> com.zhao.mat.Student</span><br></pre></td></tr></table></div></figure>
<p>“DISTINCT”关键字用于在结果集中去除重复对象。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> OBJECTS classof(s) <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></div></figure>

        <h3 id="from-子句"   >
          <a href="#from-子句" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#from-子句"></a> FROM 子句</h3>
      
<p>From子句用于指定查询范围，它可以指定类名、正则表达式或者对象地址。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></div></figure>
<p>使用正则表达式，限定搜索范围，输出所有com.zhao包下所有类的实例</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> &quot;com\.zhao\..*&quot;</span><br></pre></td></tr></table></div></figure>
<p>使用类的地址进行搜索。使用类的地址的好处是可以区分被不同ClassLoader加载的同一种类型。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="number">0x37a0b4d</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="where-子句"   >
          <a href="#where-子句" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#where-子句"></a> WHERE 子句</h3>
      
<p>Where子句用于指定OQL的查询条件。OQL查询将只返回满足Where子句指定条件的对象。Where子句的格式与传统SQL极为相似。</p>
<p>返回长度大于10的char数组。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> Ichar[] s <span class="keyword">WHERE</span> s.<span class="variable">@length</span><span class="operator">&gt;</span><span class="number">10</span></span><br></pre></td></tr></table></div></figure>
<p>返回包含“java”子字符串的所有字符串，使用“LIKE”操作符，“LIKE”操作符的操作参数为正则表达式。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s <span class="keyword">WHERE</span> toString(s) <span class="keyword">LIKE</span> &quot;.*java.*&quot;</span><br></pre></td></tr></table></div></figure>
<p>返回所有value域不为null的字符串，使用“＝”操作符。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s <span class="keyword">where</span> s.value<span class="operator">!=</span><span class="keyword">null</span></span><br></pre></td></tr></table></div></figure>
<p>返回数组长度大于15，并且深堆大于1000字节的所有Vector对象。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.util.Vector v <span class="keyword">WHERE</span> v.elementData.<span class="variable">@length</span><span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">AND</span> v.<span class="variable">@retainedHeapSize</span><span class="operator">&gt;</span><span class="number">1000</span></span><br></pre></td></tr></table></div></figure>
<p>Where子句用于指定OQL的查询条件。OQL查询将只返回满足Where子句指定条件的对象。Where子句的格式与传统SQL极为相似。</p>
<p>返回长度大于10的char数组。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> Ichar[] s <span class="keyword">WHERE</span> s.<span class="variable">@length</span><span class="operator">&gt;</span><span class="number">10</span></span><br></pre></td></tr></table></div></figure>
<p>返回包含“java”子字符串的所有字符串，使用“LIKE”操作符，“LIKE”操作符的操作参数为正则表达式。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s <span class="keyword">WHERE</span> toString(s) <span class="keyword">LIKE</span> &quot;.*java.*&quot;</span><br></pre></td></tr></table></div></figure>
<p>返回所有value域不为null的字符串，使用“＝”操作符。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s <span class="keyword">where</span> s.value<span class="operator">!=</span><span class="keyword">null</span></span><br></pre></td></tr></table></div></figure>
<p>返回数组长度大于15，并且深堆大于1000字节的所有Vector对象。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.util.Vector v <span class="keyword">WHERE</span> v.elementData.<span class="variable">@length</span><span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">AND</span> v.<span class="variable">@retainedHeapSize</span><span class="operator">&gt;</span><span class="number">1000</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="相关面试题"   >
          <a href="#相关面试题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#相关面试题"></a> 相关面试题</h2>
      
<p>支付宝：</p>
<ul>
<li>三面：JVM性能调优都做了什么？</li>
</ul>
<p>小米：</p>
<ul>
<li>有做过JVM内存优化吗？从SQL、JVM、架构、数据库四个方面讲讲优化思路</li>
</ul>
<p>蚂蚁金服：</p>
<ul>
<li>JVM的编译优化</li>
<li>JVM性能调优都做了什么</li>
<li>JVM诊断调优工具用过哪些？</li>
<li>二面：jvm怎样调优，堆内存、栈空间设置多少合适</li>
<li>三面：JVM相关的分析工具使用过的有哪些？具体的性能调优步骤如何</li>
</ul>
<p>阿里：</p>
<ul>
<li>如何进行JVM调优？有哪些方法？</li>
<li>如何理解内存泄漏问题？有哪些情况会导致内存泄漏？如何解决？</li>
</ul>
<p>字节跳动：</p>
<ul>
<li>三面：JVM如何调优、参数怎么调？</li>
</ul>
<p>拼多多：</p>
<ul>
<li>从SQL、JVM、架构、数据库四个方面讲讲优化思路</li>
</ul>
<p>京东：</p>
<ul>
<li>JVM诊断调优工具用过哪些？</li>
<li>每秒几十万并发的秒杀系统为什么会频繁发生GC？</li>
<li>日均百万级交易系统如何优化JVM？</li>
<li>线上生产系统OOM如何监控及定位与解决？</li>
<li>高并发系统如何基于G1垃圾回收器优化性能？</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://yuyun-zhao.github.io">yuyun zhao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://yuyun-zhao.github.io/2021/10/18/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/">http://yuyun-zhao.github.io/2021/10/18/%E3%80%90JVM%E3%80%91JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.github.io/tags/JVM/">JVM</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/10/19/%E3%80%90JVM%E3%80%91JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">【JVM】JVM 调优实战案例</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/10/17/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/"><span class="paginator-prev__text">【数据结构】图</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm-%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0"><span class="toc-text">
           JVM 调优概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">
           生产环境中的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B0%83%E4%BC%98"><span class="toc-text">
           为什么要调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0"><span class="toc-text">
           调优概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">
           性能优化的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%E6%B5%8B%E8%AF%95%E6%8C%87%E6%A0%87"><span class="toc-text">
           性能评价&#x2F;测试指标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E5%A0%86%E6%B7%B1%E5%A0%86"><span class="toc-text">
           浅堆深堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E5%A0%86shallow-heap"><span class="toc-text">
           浅堆（Shallow Heap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E7%95%99%E9%9B%86retained-set"><span class="toc-text">
           保留集（Retained Set）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%A0%86retained-heap"><span class="toc-text">
           深堆（Retained Heap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E9%99%85%E5%A4%A7%E5%B0%8F"><span class="toc-text">
           对象的实际大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E9%85%8D%E6%A0%91dominator-tree"><span class="toc-text">
           支配树（Dominator Tree）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">
           命令行工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">
           概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jps%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84-java-%E8%BF%9B%E7%A8%8B"><span class="toc-text">
           jps：查看正在运行的 Java 进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstat%E6%9F%A5%E7%9C%8B-jvm-%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-text">
           jstat：查看 JVM 统计信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jinfo%E5%AE%9E%E6%97%B6%E6%9F%A5%E7%9C%8B%E5%92%8C%E4%BF%AE%E6%94%B9-jvm-%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">
           jinfo：实时查看和修改 JVM 配置参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jmap%E5%AF%BC%E5%87%BA%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6%E5%92%8C%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-text">
           jmap：导出内存映像文件和内存使用情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jhatjdk%E8%87%AA%E5%B8%A6%E5%A0%86%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">
           jhat：JDK自带堆分析工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstack%E6%89%93%E5%8D%B0-jvm-%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%85%A7"><span class="toc-text">
           jstack：打印 JVM 中线程快照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jcmd%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="toc-text">
           jcmd：多功能命令行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstatd%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86"><span class="toc-text">
           jstatd：远程主机信息收集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gui-%E5%B7%A5%E5%85%B7"><span class="toc-text">
           GUI 工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jconsole"><span class="toc-text">
           JConsole</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-text">
           启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-text">
           连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%BF%A1%E6%81%AF"><span class="toc-text">
           查看信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#visual-vm"><span class="toc-text">
           Visual VM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%A0%86dump%E6%96%87%E4%BB%B6"><span class="toc-text">
           查看堆dump文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8Bdump%E6%96%87%E4%BB%B6"><span class="toc-text">
           查看线程dump文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bcpu%E5%86%85%E5%AD%98%E6%8A%BD%E6%A0%B7"><span class="toc-text">
           查看CPU，内存抽样</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eclipse-mat"><span class="toc-text">
           Eclipse MAT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jprofiler"><span class="toc-text">
           JProfiler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%87%E6%9D%86%E6%A3%80%E6%B5%8B-telemetries"><span class="toc-text">
           摇杆检测 Telemetries</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE%E5%88%86%E6%9E%90-live-memory"><span class="toc-text">
           内存视图分析 Live memory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E9%81%8D%E5%8E%86-heap-walker"><span class="toc-text">
           堆遍历 Heap Walker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu-%E8%A7%86%E5%9B%BE-cpu-views"><span class="toc-text">
           CPU 视图 CPU views</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%A7%86%E5%9B%BE-threads"><span class="toc-text">
           线程视图 Threads</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E8%A7%86%E5%99%A8%E5%92%8C%E9%94%81-monitors-locks"><span class="toc-text">
           监视器和锁 Monitors &amp; Locks</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arthas"><span class="toc-text">
           Arthas</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">
           下载与使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-text">
           基础命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jvm-%E7%9B%B8%E5%85%B3"><span class="toc-text">
           JVM 相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#classclassloader-%E7%9B%B8%E5%85%B3"><span class="toc-text">
           class&#x2F;classloader 相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#monitorwatchtrace-%E7%9B%B8%E5%85%B3"><span class="toc-text">
           monitor&#x2F;watch&#x2F;trace 相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-misssion-control"><span class="toc-text">
           Java Misssion Control</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-flight-recorder"><span class="toc-text">
           Java Flight Recorder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flame-graphs%E7%81%AB%E7%84%B0%E5%9B%BE"><span class="toc-text">
           Flame Graphs（火焰图）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tprofiler"><span class="toc-text">
           Tprofiler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#btrace"><span class="toc-text">
           Btrace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0"><span class="toc-text">
           JVM 运行时参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-jvm-%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-text">
           添加 JVM 参数选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%80%E6%A0%87%E5%87%86%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-text">
           类型一：标准参数选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BA%8C-x%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-text">
           类型二：-X参数选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%89-xx%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-text">
           类型三：-XX:参数选项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E8%AE%BE%E7%BD%AE%E7%9A%84-xx%E9%80%89%E9%A1%B9%E5%8F%8A%E5%80%BC"><span class="toc-text">
           打印设置的-XX选项及值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86-%E6%A0%88-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%AD%89%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE"><span class="toc-text">
           堆、栈、方法区等内存大小设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#outofmemory-%E7%9B%B8%E5%85%B3%E7%9A%84%E9%80%89%E9%A1%B9"><span class="toc-text">
           OutOfMemory 相关的选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9B%B8%E5%85%B3%E9%80%89%E9%A1%B9"><span class="toc-text">
           垃圾收集器相关选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3%E9%80%89%E9%A1%B9"><span class="toc-text">
           GC 日志相关选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0"><span class="toc-text">
           其他参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-java-%E4%BB%A3%E7%A0%81%E8%8E%B7%E5%8F%96-jvm-%E5%8F%82%E6%95%B0"><span class="toc-text">
           通过 Java 代码获取 JVM 参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-text">
           GC 日志分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-%E5%88%86%E7%B1%BB"><span class="toc-text">
           GC 分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-text">
           参数解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-%E6%97%A5%E5%BF%97%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-text">
           GC 日志补充说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#young-gc"><span class="toc-text">
           Young GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#full-gc"><span class="toc-text">
           Full GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90"><span class="toc-text">
           GC 日志结构剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-%E5%9B%9E%E6%94%B6%E4%B8%BE%E4%BE%8B"><span class="toc-text">
           GC 回收举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">
           常用日志分析工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85oql"><span class="toc-text">
           补充：OQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select-%E5%AD%90%E5%8F%A5"><span class="toc-text">
           SELECT 子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#from-%E5%AD%90%E5%8F%A5"><span class="toc-text">
           FROM 子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#where-%E5%AD%90%E5%8F%A5"><span class="toc-text">
           WHERE 子句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">
           相关面试题</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/author.png" alt="avatar"></div><p class="sidebar-ov-author__text">no code no life</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YUYUN-ZHAO" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="zyy1024462136" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1024462136" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:im.yuyunzhao@gmail.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gmail</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">120</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">35</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">35</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>yuyun zhao</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.xml"></script></body></html>