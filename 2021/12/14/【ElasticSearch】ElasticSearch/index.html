<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="简介        The Elastic Stack，包括 Elasticsearch、 Kibana、 Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化。 Elaticsearch，简称为 ES， 是一个开源的高扩展的分布式全文搜索引擎， 是整个 Ela">
<meta property="og:type" content="article">
<meta property="og:title" content="【ElasticSearch】ElasticSearch">
<meta property="og:url" content="http://yuyun-zhao.github.io/2021/12/14/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/index.html">
<meta property="og:site_name" content="yuyun zhao&#39;s blog">
<meta property="og:description" content="简介        The Elastic Stack，包括 Elasticsearch、 Kibana、 Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化。 Elaticsearch，简称为 ES， 是一个开源的高扩展的分布式全文搜索引擎， 是整个 Ela">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/image-20211214223034124.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/20201124224044.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/image-20220104162038740.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/20201124234946.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/20201203002017.png">
<meta property="og:image" content="http://yuyun-zhao.github.io/images/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/20201203150628.png">
<meta property="article:published_time" content="2021-12-14T14:28:13.000Z">
<meta property="article:modified_time" content="2022-01-05T11:09:53.713Z">
<meta property="article:author" content="yuyun zhao">
<meta property="article:tag" content="ElasticSearch">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yuyun-zhao.github.io/images/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/image-20211214223034124.png"><title>【ElasticSearch】ElasticSearch | yuyun zhao's blog</title><link ref="canonical" href="http://yuyun-zhao.github.io/2021/12/14/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">文章</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">yuyun zhao's blog</div><div class="header-banner-info__subtitle">no code no life</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">【ElasticSearch】ElasticSearch</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-12-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-01-05</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">6.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">38分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><img src="/images/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/image-20211214223034124.png" alt="image-20211214223034124" style="zoom: 25%;" />

        <h2 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
      
<p>The Elastic Stack，包括 Elasticsearch、 Kibana、 Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化。</p>
<p>Elaticsearch，简称为 ES， 是一个<strong>开源的高扩展的分布式全文搜索引擎</strong>， 是整个 ElasticStack 技术栈的核心，是一个可以用于<strong>检索</strong>、<strong>存储</strong>和<strong>分析</strong>的引擎。它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理 PB 级别的数据。</p>

        <h3 id="全文搜索引擎"   >
          <a href="#全文搜索引擎" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#全文搜索引擎"></a> 全文搜索引擎</h3>
      
<p>Google，百度类的网站搜索，它们都是根据网页中的关键字生成索引，我们在搜索的时候输入关键字，它们会将该关键字即索引匹配到的所有网页返回；还有常见的项目中应用日志的搜索等等。对于这些非结构化的数据文本，关系型数据库搜索不是能很好的支持。</p>
<p>一般传统数据库，全文检索都实现的很鸡肋，因为一般也没人用数据库存文本字段。进行全文检索需要扫描整个表，如果数据量大的话即使对 SQL 的语法优化，也收效甚微。建立了索引，但是维护起来也很麻烦，对于 insert 和 update 操作都会重新构建索引。</p>
<p>基于以上原因可以分析得出，在一些生产环境中，使用常规的搜索方式，性能是非常差的：</p>
<ul>
<li>搜索的数据对象是大量的非结构化的文本数据</li>
<li>文件记录量达到数十万或数百万个甚至更多。</li>
<li>支持大量基于交互式文本的查询</li>
<li>需求非常灵活的全文搜索查询</li>
<li>对高度相关的搜索结果的有特殊需求，但是没有可用的关系数据库可以满足</li>
<li>对不同记录类型、非文本数据操作或安全事务处理的需求相对较少的情况。为了解决结构化数据搜索和非结构化数据搜索性能问题，我们就需要专业，健壮，强大的全文搜索引擎</li>
</ul>
<p>这里说到的<strong>全文搜索引擎</strong>指的是目前广泛应用的主流搜索引擎。它的工作原理是计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程（倒排索引）。</p>

        <h3 id="elk"   >
          <a href="#elk" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#elk"></a> ELK</h3>
      
<p>ELK 是 Elasticsearch、Logstash、 Kibana 三大开源框架首字母大写简称。市面上也被称为 Elastic Stack。</p>
<ul>
<li>其中 Elasticsearch 是一个基于 Lucene、分布式、通过 Restful 方式进行交互的<strong>近实时搜索平台框架</strong>。像百度、谷歌这种大数据全文搜索引擎的场景都可以使用 Elasticsearch 作为底层支持框架，可见 Elasticsearch 提供的搜索能力确实强大，市面上很多时候我们简称 Elasticsearch 为ES。</li>
<li>Logstash 是 ELK 的<strong>中央数据流引擎</strong>，用于从不同目标（文件/数据存储/MQ）收集的不同格式数据，经过过滤后支持输出到不同目的地（文件/MQ/redis/elasticsearch/kafka等）。</li>
<li>Kibana 可以将 ElasticSearch 的数据通过友好的页面展示出来，提供实时分析的功能。</li>
</ul>
<p>市面上很多开发只要提到 ELK 能够一致说出它是一个日志分析架构技术栈总称，但实际上 ELK 不仅仅适用于日志分析，它还可以支持其它任何数据分析和收集的场景，日志分析和收集只是更具有代表性，并非唯一性。</p>
<p>收集清洗数据（Logstash） ==&gt; 搜索、存储（ElasticSearch） ==&gt; 展示（Kibana）</p>
<p><img src="/images/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/20201124224044.png" alt="img" /></p>

        <h3 id="elasticsearch-应用案例"   >
          <a href="#elasticsearch-应用案例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#elasticsearch-应用案例"></a> Elasticsearch 应用案例</h3>
      
<ul>
<li>GitHub：2013 年初，抛弃了 Solr，采取 Elasticsearch 来做 PB 级的搜索。 “GitHub 使用Elasticsearch 搜索 20TB 的数据，包括 13 亿文件和 1300 亿行代码”。</li>
<li>维基百科：启动以 Elasticsearch 为基础的核心搜索架构</li>
<li>百度：目前广泛使用 Elasticsearch 作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部 20 多个业务线（包括云分析、网盟、预测、文库、直达号、钱包、 风控等），单集群最大 100 台机器， 200 个 ES 节点，每天导入 30TB+数据。</li>
<li>新浪：使用 Elasticsearch 分析处理 32 亿条实时日志。</li>
<li>阿里：使用 Elasticsearch 构建日志采集和分析体系。</li>
<li>Stack Overflow：解决 Bug 问题的网站，全英文，编程人员交流的网站。</li>
</ul>

        <h3 id="lucene"   >
          <a href="#lucene" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#lucene"></a> Lucene</h3>
      
<ul>
<li>是 <strong>apache软件基金会</strong> 4 jakarta 项目组的一个子项目</li>
<li>是一个开放源代码的<strong>全文检索引擎工具包</strong></li>
<li><strong>不是一个完整的全文检索引擎，而是一个全文检索引擎的架构</strong>，提供了完整的查询引擎和索引引擎，部分<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/11046544" >文本分析</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>引擎（英文与德文两种西方语言）</li>
<li>当前以及最近几年最受欢迎的<strong>免费 Java 信息检索程序库</strong>。</li>
</ul>
<p>Lucene 和 ElasticSearch 的关系：<strong>ElasticSearch 基于 Lucene 做了封装和增强</strong>。ES 使用 Java 开发并使用 Lucene 作为其核心来实现所有索引和搜索的功能，但是它的<strong>目的</strong>是通过简单的 <strong>RESTful API</strong> 来隐藏 Lucene 的复杂性，从而让全文搜索变得简单。</p>

        <h3 id="solr-简介"   >
          <a href="#solr-简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#solr-简介"></a> Solr 简介</h3>
      
<ul>
<li>Solr 是 Apache 下的一个顶级开源项目，采用 Java 开发，它是<strong>基于Lucene的全文搜索服务器</strong>。Solr 提供了比 Lucene 更为<strong>丰富的查询语言</strong>，同时实现了<strong>可配置</strong>、<strong>可扩展</strong>，并<strong>对索引、搜索性能进行了优化</strong></li>
<li>Solr 可以<strong>独立运行</strong>，运行在 letty，Tomcat 等这些 Selrvlet 容器中，Solr 索引的实现方法很简单，用 POST 方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据 XML 文档<strong>添加、删除、更新</strong>索引。Solr 搜索只需要发送HTTP GET请求，然后对 Solr 返回 XML、JSON 等格式的查询结果进行解析，组织页面布局</li>
<li>Solr 不提供构建 UI 的功能，<strong>Solr提供了一个管理界面，通过管理界面可以查询 Solr 的配置和运行情况</strong></li>
<li>Solr 是基于 Lucene 开发企业级搜索服务器，实际上就是封装了lucene.</li>
<li>Solr 是一个独立的企业级搜索应用服务器，它<strong>对外提供类似于 Web-service 的 API 接口</strong>。用户可以通过 HTTP 请求，向搜索引擎服务器提交指定格式的文件，生成索引。也可以通过提出查找请求，并得到返回结果</li>
</ul>

        <h3 id="es-和-solr"   >
          <a href="#es-和-solr" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#es-和-solr"></a> ES 和 Solr</h3>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.kuangstudy.com/bbs/1354069127022583809" >https://www.kuangstudy.com/bbs/1354069127022583809</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<ul>
<li>ElasticSearch 是一个<strong>实时分布式搜索和分析引擎</strong>，它让你以前所未有的速度处理大数据成为可能。</li>
<li>它用于<mark><strong>全文搜索、结构化搜索、分析</strong></mark>以及将这三者混合使用：
<ul>
<li>维基百科使用 ElasticSearch 提供<strong>全文搜索</strong>并<strong>高亮关键字</strong>，以及输入<strong>实时搜索</strong>（search-asyou-type）和<strong>搜索纠错</strong>（did-you-mean）等搜索建议功能。</li>
<li>英国卫报使用 ElasticSearch 结合用户日志和社交网络数据提供给他们的编辑以实时的反馈，以便及时了解公众对新发表的文章的回应。</li>
<li>StackOverflow 结合全文搜索与地理位置查询，以及 more-like-this 功能来找到相关的问题和答案。</li>
<li>Github 使用 ElasticSearch 检索 1300 亿行的代码。</li>
</ul>
</li>
<li>ElasticSearch 是一个基于 Apache Lucene 的开源搜索引擎。无论在开源还是专有领域，Lucene可被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。但是，<strong>Lucene 只是一个库</strong>。 想要使用它，你必须使用 Java 来作为开发语言并将其直接集成到你的应用中。更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</li>
<li>ElasticSearch 也使用 Java 开发并使用 Lucene 作为其核心来实现所有引和搜索的功能，但是它的<strong>目的</strong>是通过简单的 <strong>RESTful API</strong> 来隐藏 Lucene 的复杂性，从而让全文搜索变得简单。</li>
</ul>
<p>ElasticSearch 与 Solr 比较：</p>
<ul>
<li>当单纯的对已有数据进行搜索时，Solr 更快</li>
<li>当实时建立索引时，Solr 会产生 io 阻塞，查询性能较差，ElasticSearch 具有明显的优势</li>
<li>随着数据量的增加，Solr 的搜索效率会变得更低，而 ElasticSearch 却没有明显的变化</li>
</ul>

        <h4 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
      
<ul>
<li>Solr 利用 Zookeeper 进行分布式管理，而 ElasticSearch 自身带有分布式协调管理功能</li>
<li>Solr 支持更多格式的数据,比如JSON/XML/CSV，而 Elasticsearch 仅支持 JSON 文件格式</li>
<li>Solr 官方提供的功能更多,而Elasticsearch本身更注重于核心功能，高级功能多有第三方插件提供，例如图形化界面需要 kibana 友好支撑</li>
<li><strong>Solr 查询快，但更新索引时慢（即插入删除慢）</strong> ，用于电商等查询多的应用。**ES 建立索引快（实时性查询快），用于 facebook，新浪等搜索。</li>
<li>Solr是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。</li>
<li>Solr 比较成熟，有一个更大，更成熟的用户、开发和贡献者社区，而Elasticsearch相对开发维护者较少，更新太快，学习使用成本较高。</li>
</ul>
<span id="more"></span>

        <h2 id="环境搭建"   >
          <a href="#环境搭建" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建</h2>
      
<p>在 Docker 下快速安装 ElasticSearch 7.4.2：</p>
<ol>
<li>下载镜像文件</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull elasticsearch:7.4.2</span><br><span class="line"></span><br><span class="line">$ docker pull kibana:7.4.2</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>配置</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /mydata/elasticsearch/config  <span class="comment"># 存放配置文件</span></span><br><span class="line">$ mkdir -p /mydata/elasticsearch/data    <span class="comment"># 存放数据</span></span><br><span class="line">$ mkdir -p /mydata/elasticsearch/plugins <span class="comment"># 存放插件</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;http.host: 0.0.0.0&quot;</span> &gt;/mydata/elasticsearch/config/elasticsearch.yml <span class="comment"># 允许任何机器访问</span></span><br><span class="line">$ chmod -R 777 /mydata/elasticsearch/ <span class="comment">## 设置elasticsearch文件可读写权限，否则将无法启动</span></span><br></pre></td></tr></table></div></figure>
<ol start="3">
<li>启动（9300 端口为 Elasticsearch 集群间组件的通信端口， 9200 端口为浏览器访问的 HTTP 请求端口）</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e  <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line">-e ES_JAVA_OPTS=<span class="string">&quot;-Xms64m -Xmx512m&quot;</span> \</span><br><span class="line">-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v  /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.4.2 </span><br></pre></td></tr></table></div></figure>
<ol start="4">
<li>设置开启启动</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker update elasticsearch --restart=always</span><br></pre></td></tr></table></div></figure>
<ol start="5">
<li>启动 Kibana</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name kibana -e ELASTICSEARCH_HOSTS=http://yuyunzhao.cn:9200 -p 5601:5601 -d kibana:7.4.2</span><br><span class="line"><span class="comment"># http://xxx:9200 改成自己 Elasticsearch 的地址</span></span><br></pre></td></tr></table></div></figure>
<p>在浏览器访问 5601 端口即可进入到界面</p>

        <h2 id="核心概念"   >
          <a href="#核心概念" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#核心概念"></a> 核心概念</h2>
      
<p>Elasticsearch 是<strong>面向文档型数据库</strong>，一条数据在这里就是一个文档。将 Elasticsearch 里存储文档数据和关系型数据库 MySQL 存储数据的概念进行一个类比：</p>
<p><img src="/images/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/image-20220104162038740.png" alt="image-20220104162038740" /></p>
<p>ES 里的 Index 可以看做一个库，而 Types 相当于表， Documents 则相当于表的行。这里 Types 的概念已经被逐渐弱化， Elasticsearch 6.X 中，一个 index 下已经只能包含一个type， Elasticsearch 7.X 的一些版本中，Type 的概念已经被删除了。</p>

        <h3 id="物理设计"   >
          <a href="#物理设计" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#物理设计"></a> 物理设计</h3>
      
<p>ElasticSearch 在后台把<strong>每个索引划分成多个分片</strong>，每分分片可以在集群中的不同服务器间迁移。一个人就是一个集群，即<strong>启动的 ElasticSearch 服务，默认就是一个集群，且默认集群名为ElasticSearch</strong>。</p>

        <h3 id="逻辑设计"   >
          <a href="#逻辑设计" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#逻辑设计"></a> 逻辑设计</h3>
      
<p>一个索引类型中，包含多个文档，比如说文档1，文档2。当我们索引一篇文档时，可以通过这样的顺序找到它：索引 =&gt; 类型 =&gt; 文档ID ，通过这个组合我们就能索引到某个具体的文档。 注意：ID不必是整数，实际上它是个字符串。</p>
<blockquote>
<p>文档（“行”）</p>
</blockquote>
<p>之前说 ElasticSearch 是面向文档的，那么就意味着<strong>索引和搜索数据的最小单位是文档</strong>，ElasticSearch中，文档有几个重要属性:</p>
<ul>
<li>自我包含，一篇文档同时包含字段和对应的值，也就是同时包含<code>key:value</code></li>
<li>可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的</li>
<li>灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在 ElasticSearch 中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。</li>
</ul>
<p>尽管我们可以随意新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符串也可以是整型。因为 ElasticSearch 会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在 ElasticSearch 中，类型有时候也称为映射类型。</p>
<blockquote>
<p>类型（“表”）</p>
</blockquote>
<p>类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。类型中对于字段的定义称为映射，比如 name 映射为字符串类型。我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么 ElasticSearch 是怎么做的呢？</p>
<p>ElasticSearch 会自动将新字段加入映射，但是这个字段的不确定它是什么类型，ElasticSearch 就开始猜，如果这个值是18，那么 EasticSearch 会认为它是整型。但是 ElasticSearch 也可能猜不对，所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用。</p>
<blockquote>
<p>索引（“库”）</p>
</blockquote>
<p>索引是映射类型的容器， ElasticSearch 中的索引是一个非常大的文档集合。 索引存储了映射类型的字段和其他设置。然后它们被存储到了各个分片上了。</p>

        <h3 id="分片"   >
          <a href="#分片" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#分片"></a> 分片</h3>
      
<p>一个集群至少有一个节点，而一个节点就是一个 ElasticSearch 进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个 5 个分片（primary shard，又称主分片）构成的，每一个主分片会有一个副本（replica shard，又称复制分片）</p>
<p><img src="/images/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/20201124234946.png" alt="img" /></p>
<p>上图是一个有3个节点的集群，可以看到主分片和对应的复制分片都不会在同一个节点内，这样有利于某个节点挂掉了，数据也不至于失。实际上，<strong>一个分片是一个Lucene索引（<mark>一个ElasticSearch索引包含多个Lucene索引</mark>）</strong> ，<strong>一个包含倒排索引的文件目录，倒排索引的结构使得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字</strong>。不过，等等，倒排索引是什么鬼?</p>

        <h3 id="倒排索引"   >
          <a href="#倒排索引" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#倒排索引"></a> 倒排索引</h3>
      
<p>正排索引（传统）：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>id</th>
<th>content</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>my name is zhang san</td>
</tr>
<tr>
<td>1002</td>
<td>my name is li si</td>
</tr>
</tbody>
</table></div>
<p>倒排索引（将一条语句按照关键字进行分词拆分，保存每个关键字的 id）：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>keyword</th>
<th>id</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>1001, 1002</td>
</tr>
<tr>
<td>zhang</td>
<td>1001</td>
</tr>
</tbody>
</table></div>

        <h2 id="基础增删改查"   >
          <a href="#基础增删改查" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#基础增删改查"></a> 基础增删改查</h2>
      
<p>对比关系型数据库，创建索引就等同于创建数据库。四种类型的 RESTful 请求概览：</p>
<div class="table-container"><table>
<thead>
<tr>
<th style="text-align:center">method</th>
<th style="text-align:center">URL</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PUT（创建，修改）</td>
<td style="text-align:center">localhost:9200/索引名称/类型名称/文档id</td>
<td style="text-align:center">创建文档（指定文档id）</td>
</tr>
<tr>
<td style="text-align:center">POST（创建）</td>
<td style="text-align:center">localhost:9200/索引名称/类型名称</td>
<td style="text-align:center">创建文档（随机文档id）</td>
</tr>
<tr>
<td style="text-align:center">POST（修改）</td>
<td style="text-align:center">localhost:9200/索引名称/类型名称/文档id</td>
<td style="text-align:center">修改文档</td>
</tr>
<tr>
<td style="text-align:center">POST（修改）</td>
<td style="text-align:center">localhost:9200/索引名称/类型名称/文档id/<strong>_update</strong></td>
<td style="text-align:center">修改文档（会进行数据对比）</td>
</tr>
<tr>
<td style="text-align:center">DELETE（删除）</td>
<td style="text-align:center">localhost:9200/索引名称/类型名称/文档id</td>
<td style="text-align:center">删除文档</td>
</tr>
<tr>
<td style="text-align:center">GET（查询）</td>
<td style="text-align:center">localhost:9200/索引名称/类型名称/文档id</td>
<td style="text-align:center">通过文档ID查询</td>
</tr>
<tr>
<td style="text-align:center">GET（查询）</td>
<td style="text-align:center">localhost:9200/索引名称/类型名称/<strong>_search</strong></td>
<td style="text-align:center">条件查询</td>
</tr>
</tbody>
</table></div>

        <h3 id="创建文档"   >
          <a href="#创建文档" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#创建文档"></a> 创建文档</h3>
      
<p>创建文档有两种方式：</p>
<ul>
<li><strong>PUT 请求</strong>：<strong>幂等性</strong>操作。必须指定文档 id（必须明确知道要操作的对象）；如果该文档不存在，就创建该文档；如果文档已经存在，就直接<strong>整个替换文档内容</strong>（此时为修改请求）。</li>
<li><strong>POST 请求</strong>：<strong>非幂等性</strong>操作。可以不指定文档 id（也可以指定）；如果不指定 id，则新增数据时服务<strong>器自动为该文档创建</strong>一个 id；如果指定 id，则以该 id 创建文档（如果文档已存在，则 POST 修改请求会修改目标对象的<strong>部分内容</strong>）</li>
</ul>
<hr />
<p><strong>PUT 和 POST 幂等性的讨论</strong>：</p>
<ul>
<li>PUT：幂等性操作。因为想发出 PUT 请求时必须指定文档 id（必须明确要操作的对象），那么无论发出多少次请求，始终都是在操作该对象，对其内容进行修改，并不会导致创建重复的该对象。</li>
<li>POST：非幂等性操作。因为 POST 请求可以不指定文档 id，这样在发出多次相同的 POST 请求时，如果不指定 id，服务器会创建多个重复的对象（内容相同，但 id 都是服务器随机生成的）</li>
</ul>
<hr />
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/39873" >https://cloud.tencent.com/developer/news/39873</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>总结：使用 PUT 时，必须明确知道要操作的对象，如果对象不存在，创建对象；如果对象存在，则<strong>全部替换</strong>目标对象。同样 POST 既可以创建对象，也可以修改对象。但用 POST 创建对象时，之前并不知道要操作的对象，由 HTTP 服务器为新创建的对象生成一个唯一的 URI；使用 POST 修改已存在的对象时，一般<strong>只是修改目标对象的部分内容</strong>。</p>

        <h3 id="查询文档"   >
          <a href="#查询文档" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#查询文档"></a> 查询文档</h3>
      
<p>查询数据通常用 GET 请求，同时可以选择是否指定文档 id：</p>
<ul>
<li>如果指定文档 id，类似于 MySQL 中以指定主键 id 的方式（主键查询）来查询数据，只会查出指定 id 的文档数据。</li>
<li>如果不指定文档 id，则需要在 URL 里添加 <code>_search</code> 字段，表明进行<strong>条件查询</strong>（类似于 MySQL 里的 <code>WHERE</code>）， 同时需要在请求体里添加条件查询的条件。</li>
</ul>
<p>示例：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://localhost:9200/custom/external/1" >http://localhost:9200/custom/external/1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;customer&quot;</span>, <span class="comment">// 在哪个索引</span></span><br><span class="line">    <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;external&quot;</span>,  <span class="comment">// 在哪个类型</span></span><br><span class="line">    <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,           <span class="comment">// 文档 id</span></span><br><span class="line">    <span class="attr">&quot;_version&quot;</span>: <span class="number">1</span>,        <span class="comment">// 版本号，代表该文档被修改了几次</span></span><br><span class="line">    <span class="attr">&quot;_seq_no&quot;</span>: <span class="number">0</span>,         <span class="comment">// 并发控制字段，每次更新就会+1，用来做乐观锁</span></span><br><span class="line">    <span class="attr">&quot;_primary_term&quot;</span>: <span class="number">1</span>,   <span class="comment">//同上，主分片重新分配，如重启，就会变化</span></span><br><span class="line">    <span class="attr">&quot;found&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span> <span class="comment">// 真正的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="修改文档"   >
          <a href="#修改文档" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#修改文档"></a> 修改文档</h3>
      
<p>修改文档有两种方式：</p>
<ul>
<li><strong>PUT 请求</strong>：<strong>全量更新</strong>。必须指定所有字段的值，否则漏写的字段将被覆盖为默认值。并且每次修改后，<code>_version</code> 字段的值都会加一。</li>
<li><strong>POST 请求</strong>：<strong>局部更新</strong>。漏写的字段不会被覆盖。只会更新 POST 请求体里携带的字段，没有指定的字段的值不会被改变。如果 URL 里指定了 <code>_update</code>，则此时的 POST 请求会先进行一次检查，判断原数据的值是否和要更新的值相等：
<ul>
<li>如果相等，则不执行修改操作，<code>_version</code> 字段的值不会增加</li>
<li>如果不相等，才会执行修改操作，<code>_version</code> 字段的值加一</li>
</ul>
</li>
</ul>
<blockquote>
<p>不论是 PUT 请求还是 POST 请求，只要 URL 里不指定 <code>_update</code>，就不会执行重复校验。只有 POST 请求中指定了 <code>_update</code>，才会进行重复校验</p>
</blockquote>

        <h3 id="删除文档"   >
          <a href="#删除文档" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#删除文档"></a> 删除文档</h3>
      
<p>删除文档只能使用 DELETE 请求，并明确指定文档 id。</p>

        <h3 id="bulk-批量操作"   >
          <a href="#bulk-批量操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#bulk-批量操作"></a> bulk 批量操作</h3>
      
<p>在请求中添加 <code>_bulk</code> 关键字可以进行批量操作：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST customer&#x2F;external&#x2F;_bulk</span><br><span class="line"># 两行是一条文档</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;John Doe&quot;&#125;</span><br><span class="line"># 两行是一条文档</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;John Doe&quot;&#125;</span><br></pre></td></tr></table></div></figure>
<p>语法格式</p>
<figure class="highlight"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 两行是一条文档</span><br><span class="line">&#123;action:&#123;metadata&#125;&#125;</span><br><span class="line">&#123;requeestBody&#125;</span><br><span class="line"># 两行是一条文档</span><br><span class="line">&#123;action:&#123;metadata&#125;&#125;</span><br><span class="line">&#123;requesetbod &#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li><code>index</code> 是新建索引，会覆盖文档；</li>
<li><code>create</code> 是新建文档，不会覆盖文档</li>
</ul>
<p>复杂实例：</p>
<figure class="highlight"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;website&quot;,&quot;_type&quot;:&quot;blog&quot;,&quot;_id&quot;:&quot;123&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;create&quot;:&#123;&quot;_index&quot;:&quot;website&quot;,&quot;_type&quot;:&quot;blog&quot;,&quot;_id&quot;:&quot;123&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;my first blog post&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;website&quot;,&quot;_type&quot;:&quot;blog&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;my second blog post&quot;&#125;</span><br><span class="line">&#123;&quot;update&quot;:&#123;&quot;_index&quot;:&quot;website&quot;,&quot;_type&quot;:&quot;blog&quot;,&quot;_id&quot;:&quot;123&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;:&#123;&quot;title&quot;:&quot;my updated blog post&quot;&#125;&#125;</span><br></pre></td></tr></table></div></figure>
<p>bulk API 以此按顺序执行所有的action (动作)。如果某个单个的动作因任何原因而失败，它将继续处理它后面剩余的动作。当 bulkAPI 返回时，它将提供每个动作的状态（与发送的顺序相同），可以借此检查一个指定的动作是否失败了。</p>

        <h3 id="_cat"   >
          <a href="#_cat" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#_cat"></a> _cat</h3>
      
<p>在请求中添加 <code>_cat</code> 字段，可以用于查看 ES 服务器中的一些信息，例如：</p>
<ul>
<li><code>GET /_cat/nodes</code>：查看所有节点</li>
<li><code>GET /_cat/health</code>：查看 es 健康状况</li>
<li><code>GET /_cat/master</code>：查看主节点</li>
<li><code>GET /_cat/incices</code>：查看所有索引 show databases</li>
</ul>
<p>其他表头：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>表头</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>health</td>
<td>当前服务器健康状态： green(集群完整) yellow(单点正常、集群不完整) red(单点不正常)</td>
</tr>
<tr>
<td>status</td>
<td>索引打开、关闭状态</td>
</tr>
<tr>
<td>index</td>
<td>索引名</td>
</tr>
<tr>
<td>uuid</td>
<td>索引统一编号</td>
</tr>
<tr>
<td>pri</td>
<td>主分片数量</td>
</tr>
<tr>
<td>rep</td>
<td>副本数量</td>
</tr>
<tr>
<td>docs.count</td>
<td>可用文档数量</td>
</tr>
<tr>
<td>docs.deleted</td>
<td>文档删除状态（逻辑删除）</td>
</tr>
<tr>
<td>store.size</td>
<td>主分片和副分片整体占空间大小</td>
</tr>
<tr>
<td>pri.store.size</td>
<td>主分片占空间大小</td>
</tr>
</tbody>
</table></div>

        <h2 id="复杂查询"   >
          <a href="#复杂查询" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#复杂查询"></a> 复杂查询</h2>
      
<p>前面介绍到，在请求的 URL 中添加 <code>_search</code> 字段，表明进行<strong>条件查询</strong>（类似于 MySQL 里的 <code>WHERE</code>）， 同时需要在请求体里添加条件查询的条件。</p>
<p>常用参数：</p>
<ul>
<li><code>query</code>：类似于 <code>where</code>，在其内添加各种匹配规则以实现条件查询</li>
<li><code>_source</code>：过滤字段</li>
<li><code>sort</code>：排序</li>
<li><code>form</code>、<code>size</code> 分页</li>
</ul>
<p><img src="/images/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/20201203002017.png" alt="img" /></p>

        <h3 id="匹配"   >
          <a href="#匹配" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#匹配"></a> 匹配</h3>
      
<p>匹配查询分为以下几种：</p>
<ul>
<li><code>match</code>：针对 <strong>text 文本类型</strong>的文档
<ul>
<li>如果字段类型是<strong>数字</strong>类型，则会<strong>精确匹配</strong>，只匹配出等于该值的文档</li>
<li>如果字段类型是<strong>字符串</strong>类型，则会<strong>模糊匹配</strong>，先使用分词器解析分析文档，然后进行查询。分词器会将该字符串拆分成多个单词，从而匹配出包含这些单词中的任何一个的文档，并再按照评分 <code>score</code> （包含这些单词的比例）对匹配到的文档进行排序</li>
<li>如果某个字段上加了 <code>keyword</code>（例如 <code>name.keyword</code>），就代表该字段查询时不进行分词，要精确匹配</li>
</ul>
</li>
<li><code>match_all</code>：查询所有，不做条件匹配</li>
<li><code>match_phrase</code>：将需要匹配的值当成一个整体单词（<strong>不分词</strong>）进行检索</li>
<li><code>multi_match</code>：同时设置多个条件，需要同时满足这些条件才算匹配</li>
<li><code>term</code>：针对<strong>非文本类型</strong>的文档（例如 number/date/keyword），<strong>精确匹配</strong>具体数值，不进行分词，接通过<strong>倒排索引</strong>指定词条查询。</li>
</ul>
<hr />
<p><code>text</code> 和 <code>keyword</code> 的区别：</p>
<ul>
<li><code>text</code>：
<ul>
<li><strong>支持分词</strong>，<strong>全文检索</strong>、支持模糊、精确查询，不支持聚合、排序操作;</li>
<li>text 类型的最大支持的字符长度无限制，适合大字段存储；</li>
</ul>
</li>
<li><code>keyword</code>：
<ul>
<li><strong>不进行分词</strong>，<strong>直接索引</strong>、支持模糊、支持精确匹配，支持聚合、排序操作。</li>
<li><code>keyword</code>类型的最大支持的长度为——32766个UTF-8类型的字符,可以通过设置<code>ignore_above</code> 指定自持字符长度，超过给定长度后的数据将不被索引，<strong>无法通过term精确匹配检索返回结果</strong>。</li>
</ul>
</li>
</ul>
<hr />

        <h3 id="复合查询"   >
          <a href="#复合查询" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#复合查询"></a> 复合查询</h3>
      
<blockquote>
<p>复合语句可以合并任何其他嵌套语句，包括复合语句，了解这一点是很重要的，这就意味着，复合语句之间可以互相嵌套，可以表达式非常复杂的逻辑</p>
</blockquote>
<p><strong>多条件查询</strong>（<code>bool</code>），其都需要写在 <code>query</code> 字段内，都属于条件查询：</p>
<ul>
<li><code>must</code>：必须达到 <code>must</code>列举的所有条件</li>
<li><code>should</code>：应该达到 <code>should</code>列举的条件，<strong>如果达到会增加相关文档的评分</strong>，并<strong>不会改变查询的结果</strong>，如果 query 中只有 should 且只有一种匹配规则，那么 should 的条件就会被作为默认匹配条件而去改变查询结果。should 是<strong>加分项</strong>，不满足也能查出来。只是如果满足，score 会加分</li>
<li><code>must_not</code>：必须不是指定的情况。<code>must_not</code> 不会额外贡献得分，但是其是一个 filter，不满足直接不显示</li>
<li><code>filter</code>：条件过滤。效果和 <code>must</code> 类似，也能检索出目标记录，但是不会记录相关性得分，不满足 <code>filter</code> 的直接过滤，满足的留下。且满足的也不会额外增加相关性得分</li>
</ul>
<p><img src="/images/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/20201203150628.png" alt="img" /></p>
<blockquote>
<p>上图中的相当于 and 不正确</p>
</blockquote>

        <h2 id="其他"   >
          <a href="#其他" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2>
      
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://yuyun-zhao.github.io">yuyun zhao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://yuyun-zhao.github.io/2021/12/14/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/">http://yuyun-zhao.github.io/2021/12/14/%E3%80%90ElasticSearch%E3%80%91ElasticSearch/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.github.io/tags/ElasticSearch/">ElasticSearch</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/12/15/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">【算法】概率问题</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/12/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%A0%86/"><span class="paginator-prev__text">【数据结构】堆</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">
           简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E"><span class="toc-text">
           全文搜索引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#elk"><span class="toc-text">
           ELK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#elasticsearch-%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">
           Elasticsearch 应用案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lucene"><span class="toc-text">
           Lucene</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solr-%E7%AE%80%E4%BB%8B"><span class="toc-text">
           Solr 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es-%E5%92%8C-solr"><span class="toc-text">
           ES 和 Solr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">
           总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">
           环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">
           核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E8%AE%BE%E8%AE%A1"><span class="toc-text">
           物理设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1"><span class="toc-text">
           逻辑设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%89%87"><span class="toc-text">
           分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="toc-text">
           倒排索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-text">
           基础增删改查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3"><span class="toc-text">
           创建文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3"><span class="toc-text">
           查询文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E6%A1%A3"><span class="toc-text">
           修改文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E6%A1%A3"><span class="toc-text">
           删除文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bulk-%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="toc-text">
           bulk 批量操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#_cat"><span class="toc-text">
           _cat</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2"><span class="toc-text">
           复杂查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D"><span class="toc-text">
           匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-text">
           复合查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">
           其他</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/author.png" alt="avatar"></div><p class="sidebar-ov-author__text">no code no life</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YUYUN-ZHAO" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="zyy18749810683" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1024462136" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:im.yuyunzhao@gmail.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gmail</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">126</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">37</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">37</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>yuyun zhao</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.xml"></script></body></html>