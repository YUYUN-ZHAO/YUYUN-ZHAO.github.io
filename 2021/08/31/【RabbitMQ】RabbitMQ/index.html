<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="MQ 简介                             什么是 MQ        MQ (message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦 + 物理解耦” 的消">
<meta property="og:type" content="article">
<meta property="og:title" content="【RabbitMQ】RabbitMQ 基础">
<meta property="og:url" content="http://yuyun-zhao.gitee.io/2021/08/31/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/index.html">
<meta property="og:site_name" content="yuyun zhao&#39;s blog">
<meta property="og:description" content="MQ 简介                             什么是 MQ        MQ (message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦 + 物理解耦” 的消">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831143417355.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831215725573.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831215804163.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831220251162.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831220420923.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903203642528.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903205627257.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204201626.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204307310.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204350479.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204919165.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204940385.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903205243652.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903210632247.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903213659559.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903214211735.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903214935805.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903215018034.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903215130608.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903215202328.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903215400615.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903215518080.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903215531918.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904144655029.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904144805663.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904144916833.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904145729754.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904150453631.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904150550667.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904150828988.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904151314950.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904154952551.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904155528622.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904155542060.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904160122676.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904163932459.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904170243555.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904170543180.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904171357566.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904171411419.png">
<meta property="article:published_time" content="2021-08-31T06:30:18.000Z">
<meta property="article:modified_time" content="2021-09-15T10:59:10.015Z">
<meta property="article:author" content="yuyun zhao">
<meta property="article:tag" content="RabbitMQ">
<meta property="article:tag" content="中间件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831143417355.png"><title>【RabbitMQ】RabbitMQ 基础 | yuyun zhao's blog</title><link ref="canonical" href="http://yuyun-zhao.gitee.io/2021/08/31/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">文章</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">yuyun zhao's blog</div><div class="header-banner-info__subtitle">no code no life</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">【RabbitMQ】RabbitMQ 基础</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-08-31</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-15</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">23.7k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">153分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831143417355.png" alt="image-20210831143417355" /></p>

        <h2 id="mq-简介"   >
          <a href="#mq-简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mq-简介"></a> MQ 简介</h2>
      

        <h3 id="什么是-mq"   >
          <a href="#什么是-mq" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#什么是-mq"></a> 什么是 MQ</h3>
      
<p>MQ (message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦 + 物理解耦” 的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务，由MQ将消息发送给下游消费者。</p>

        <h3 id="为什么要用-mq"   >
          <a href="#为什么要用-mq" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#为什么要用-mq"></a> 为什么要用 MQ</h3>
      

        <h4 id="流量消峰"   >
          <a href="#流量消峰" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#流量消峰"></a> 流量消峰</h4>
      
<p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p>

        <h4 id="应用解耦"   >
          <a href="#应用解耦" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#应用解耦"></a> 应用解耦</h4>
      
<p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831215725573.png" alt="image-20210831215725573" /></p>

        <h4 id="异步处理"   >
          <a href="#异步处理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#异步处理"></a> 异步处理</h4>
      
<p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。</p>
<p>以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。</p>
<p>使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作，A 服务还能及时的得到异步处理成功的消息。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831215804163.png" alt="image-20210831215804163" /></p>
<span id="more"></span>

        <h3 id="mq-的分类"   >
          <a href="#mq-的分类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mq-的分类"></a> MQ 的分类</h3>
      

        <h4 id="activemq"   >
          <a href="#activemq" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#activemq"></a> ActiveMQ</h4>
      
<ul>
<li>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，较低的概率丢失数据。</li>
<li>缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</li>
</ul>

        <h4 id="kafka"   >
          <a href="#kafka" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#kafka"></a> Kafka</h4>
      
<p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<strong>大数据</strong>而生的消息中间件，以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p>
<ul>
<li>优点：性能卓越，单机写入 TPS 约在百万条 / 秒，<strong>最大的优点，就是吞吐量高</strong>。时效性 ms 级，可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用，消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次；有优秀的第三方 Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。</li>
<li>缺点：Kafka 单机超过 64 个队列 / 分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，<strong>社区更新较慢</strong>。</li>
</ul>

        <h4 id="rocketmq"   >
          <a href="#rocketmq" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rocketmq"></a> RocketMQ</h4>
      
<p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p>
<ul>
<li>优点：<strong>单机吞吐量十万级</strong>，可用性非常高，分布式架构，消息可以做到 0 丢失，MQ 功能较为完善，还是分布式的，扩展性好，支持 10 亿级别的消息堆积，不会因为堆积导致性能下降。</li>
<li>缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟；社区活跃度一般，没有在 MQ 核心中去实现 JMS 等接口，有些系统要迁移需要修改大量代码。</li>
</ul>

        <h4 id="rabbitmq"   >
          <a href="#rabbitmq" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq"></a> RabbitMQ</h4>
      
<p>2007 年发布，是一个在 AMQP (高级消息队列协议) 基础上完成的，可复用的企业消息系统，<strong>是当前最主流的消息中间件之一</strong>。</p>
<ul>
<li>优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备，健壮、稳定、易用、跨平台、支持多种语言。如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用，社区活跃度高；更新频率相当高。</li>
<li>缺点：商业版需要收费，学习成本较高。</li>
</ul>

        <h3 id="mq-的选择"   >
          <a href="#mq-的选择" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mq-的选择"></a> MQ 的选择</h3>
      

        <h4 id="kafka-2"   >
          <a href="#kafka-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#kafka-2"></a> Kafka</h4>
      
<p>Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能，肯定是首选 kafka 了。</p>

        <h4 id="rocketmq-2"   >
          <a href="#rocketmq-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rocketmq-2"></a> RocketMQ</h4>
      
<p>天生为<strong>金融互联网</strong>领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p>

        <h4 id="rabbitmq-2"   >
          <a href="#rabbitmq-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-2"></a> RabbitMQ</h4>
      
<p>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分方便，如果你的<strong>数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ。</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhangc233.github.io/2021/07/23/RabbitMQ/" >https://zhangc233.github.io/2021/07/23/RabbitMQ/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h2 id="rabbitmq-简介"   >
          <a href="#rabbitmq-简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-简介"></a> RabbitMQ 简介</h2>
      

        <h3 id="rabbitmq-的概念"   >
          <a href="#rabbitmq-的概念" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-的概念"></a> RabbitMQ 的概念</h3>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhangc233.github.io/2021/07/23/RabbitMQ/" >https://zhangc233.github.io/2021/07/23/RabbitMQ/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>RabbitMQ是一个<strong>异步消息</strong>通信中间件，用erlang语言开发，实现了AMQP（Advanced Message Queue ）协议，是一个开源产品，官方网站：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.rabbitmq.com/" >http://www.rabbitmq.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>RabbitMQ 是一个消息中间件，它<strong>接受并转发</strong>消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。</p>
<p>但RabbitMQ 与快递站的主要区别在于，<strong>它不处理快件，而是接收，存储和转发消息数据</strong>。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831220251162.png" alt="image-20210831220251162" /></p>

        <h3 id="四大核心概念"   >
          <a href="#四大核心概念" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#四大核心概念"></a> 四大核心概念</h3>
      
<ul>
<li><strong>生产者</strong>：产生数据发送消息的程序。</li>
<li><strong>交换机</strong>：是 RabbitMQ 非常重要的一个部件，<strong>一方面它接收来自生产者的消息，另一方面它将消息推送到队列中</strong>。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定。</li>
<li><strong>队列</strong>：队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。</li>
<li><strong>消费者</strong>：大多时候是一个等待接收消息的程序。请注意<strong>生产者，消费者和消息中间件很多时候并不在同一机器上</strong>。同一个应用程序既可以是生产者又是可以是消费者。</li>
</ul>
<p><strong>四者关系</strong>：</p>
<ul>
<li><strong>生产者只将消息发给交换机</strong>，至于该交换机将消息发送给了哪个队列其是不知道的（通常将绑定的工作放到 Spring 的 <code>@Configuration</code> 配置类里，从而与生产者解耦，生产者本身并不知道绑定信息）</li>
<li><strong>消费者只从队列获取消息</strong>，至于该消息来自哪个交换机其是不知道的</li>
<li>交换机和队列是有对应的绑定关系的，通常在Spring的<code>@Configuration</code>配置类里进行配置，生产者和消费者对此并不知情，也无需知道，</li>
</ul>

        <h3 id="rabbitmq-工作原理"   >
          <a href="#rabbitmq-工作原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-工作原理"></a> RabbitMQ 工作原理</h3>
      
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831220420923.png" alt="image-20210831220420923" /></p>
<ul>
<li><strong>Broker</strong>：<strong>接收</strong>和<strong>分发</strong>消息的应用，就是 RabbitMQ 服务器。</li>
<li><strong>Virtual host</strong>：出于多用户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等。</li>
<li><strong>Connection</strong>：publisher／consumer 和 broker 之间的 TCP 连接。</li>
<li><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</strong>。</li>
<li><strong>Exchange</strong>：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 <code>routing key</code>，分发消息到 queue 中去。常用的类型有：<code>direct (point-to-point)</code>，<code>topic (publish-subscribe)</code> and <code>fanout (multicast)</code>。</li>
<li><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走。</li>
<li><strong>Binding</strong>：exchange 和 queue 之间的虚拟连接，binding 中可以包含 <code>routing key</code>，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</li>
</ul>
<p>其中，交换机和队列存储在 RabbitMQ 服务器内，生产者和消费者在其他服务器，二者通过声明的方式在 RabbitMQ 服务器内创建相应的交换机和队列。</p>

        <h3 id="工作流程"   >
          <a href="#工作流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h3>
      
<p><strong>生产者工作流程</strong>：</p>
<ol>
<li>生产者建立与 RabbitMQ 服务器的 Connection 连接并创建一个 Channel 与其通讯</li>
<li>生产者声明若干交换机与队列，声明后，RabbitMQ 服务器中将创建这些交换机与队列（<code>queueDeclare()</code>）</li>
<li>生产者绑定交换机与队列，即指定交换机与队列间的<code>routing key</code>与映射类型（<code>queueBind()</code>）</li>
<li>生产者向 RabbitMQ 服务器发送消息（<code>basicPublish()</code>）</li>
<li>生产者可以设置通道为<a href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4">发布确认</a>模式 （<code>confirmSelect()</code>），这样 RabbitMQ 服务器在收到生产者发送的数据后会回调通知生产者，生产者异步地接收这些回调消息，从而得知当前消息是否被 RabbitMQ 服务器的交换机所接收到，若 RabbitMQ 服务器宕机生产者也可以即使得知，避免消息丢失</li>
<li>仅开启发布确认模式只能得知当前消息是否被 RabbitMQ 服务器的交换机所接收到，而不能得知该消息能否成功传递到队列（若生产者发送了错误的 <code>routing key</code> 导致消息无法往下传递， RabbitMQ 服务器会将该消息删除而生产者并不知情），因此需要开启<a href="#%E5%9B%9E%E9%80%80%E6%B6%88%E6%81%AF">回退消息</a>功能，在当消息传递过程中不可达目的地时将消息返回给生产者，通知生产者消息发送失败，考虑重新发送。通常<a href="%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4">发布确认</a>和<a href="#%E5%9B%9E%E9%80%80%E6%B6%88%E6%81%AF">回退消息</a>一起使用，保证生产者发送的消息不能被顺利传递时能够被及时通知。</li>
</ol>
<p><strong>消费者工作流程</strong>：</p>
<ol>
<li>消费者建立与 RabbitMQ 服务器的 Connection 连接并创建一个 Channel 与其通讯</li>
<li>消费者指定监听哪个队列（<code>basicConsume()</code>），并设置接收消息成功/失败的回调方法（<code>Callback</code>）</li>
<li>消费者接收到消息后进行<a href="#%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94">消息应答</a>（<code>basicAck()</code>）：通知 RabbitMQ 服务器该消息已经成功接受，此时才将该消息从队列中删除</li>
<li>消费者可以设置<a href="#%E9%A2%84%E5%8F%96%E5%80%BC%E5%88%86%E5%8F%91">预期值分发</a>（<code>basicQos()</code>），一次性从队列中获取多条消息进行异步消费</li>
</ol>
<p><strong>RabbitMQ 服务器工作流程</strong>：</p>
<ol>
<li>与 RabbitMQ 客户端（生产者与消费者）建立TCP连接</li>
<li>创建生产者与消费者声明的交换机与队列，并根据<code>routing key</code>与映射类型将其进行绑定</li>
<li>当交换机收到生产者发来的消息时，将此消息按照<code>routing key</code>分发到对应的队列中</li>
<li>队列中的消息将逐个转发到对应的消费者。注意，<strong>一个消息只能被消费一次</strong>。这个队列所对应的N个消费者将按照某种规则（例如轮询）消费该消息。例如该队列中共有4条消息，有两个消费者监听该队列，那么这两个消费者将分别消费2条消息</li>
<li>当 RabbitMQ 服务器接收到消费者传来的消息应答后，若消费者确认收到消息（<code>basicAck ()</code>），则将该消息从队列中删除；若消费者拒绝收到消息（<code>basicReject ()</code>），同样将其从队列中删除；若消费者长时间未回复消息应答，则将该<a href="#%E6%B6%88%E6%81%AF%E9%87%8D%E6%96%B0%E5%85%A5%E9%98%9F">消息重新入队</a></li>
<li>若 RabbitMQ 服务器判断得知某条消息成为死信（例如消息被拒绝、消息到期或队列达到最大长度），则将其路由到对应的<a href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97">死信队列</a>，死信队列里的消息将由监听其的消费者消费</li>
<li>发送到<a href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97">延迟队列</a>里面的消息在阻塞一定时间后才会被放到死信队列里被相应的消费者消费（例如取消订单）</li>
</ol>

        <h2 id="安装-rabbitmq"   >
          <a href="#安装-rabbitmq" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#安装-rabbitmq"></a> 安装 RabbitMQ</h2>
      
<blockquote>
<p>Linux上安装过程见<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://yuyun-zhao.github.io/documents/linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.pdf" >Linux 开发环境配置文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h3 id="rabbitmq-端口"   >
          <a href="#rabbitmq-端口" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-端口"></a> RabbitMQ 端口</h3>
      
<ul>
<li><strong>15672：Web图形化管理界面端口</strong></li>
<li><strong>5672：AMQP协议的端口号</strong></li>
</ul>

        <h3 id="常用命令"   >
          <a href="#常用命令" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h3>
      
<figure class="highlight sh"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl status rabbitmq-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> rabbitmq-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></div></figure>

        <h3 id="web-管理界面及授权操作"   >
          <a href="#web-管理界面及授权操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#web-管理界面及授权操作"></a> Web 管理界面及授权操作</h3>
      
<ol>
<li>安装：</li>
</ol>
<figure class="highlight sh"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>安装完毕以后，重启服务：</li>
</ol>
<figure class="highlight sh"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></div></figure>
<ol start="3">
<li>访问 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://xxx.xxx.xxx.xxx:15672" >http://xxx.xxx.xxx.xxx:15672</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ，用默认账号密码 (guest) 登录，出现权限问题，需要添加一个远程登录的用户：</li>
</ol>
<figure class="highlight sh"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建账号和密码</span></span><br><span class="line">rabbitmqctl add_user admin 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置用户角色</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为用户添加资源权限  添加配置、写、读权限</span></span><br><span class="line"><span class="comment"># set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span></span><br><span class="line">rabbitmqctl set_permissions -p <span class="string">&quot;/&quot;</span> admin <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span><br></pre></td></tr></table></div></figure>
<p>用户级别：</p>
<ul>
<li><strong>administrator</strong>：可以登录控制台、查看所有信息、可以对 rabbitmq 进行管理。</li>
<li><strong>monitoring</strong>：监控者 登录控制台，查看所有信息。</li>
<li><strong>policymaker</strong>：策略制定者 登录控制台，指定策略。</li>
<li><strong>managment</strong>：普通管理员 登录控制台。</li>
</ul>

        <h3 id="web-应用相关命令"   >
          <a href="#web-应用相关命令" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#web-应用相关命令"></a> Web 应用相关命令</h3>
      
<ul>
<li>关闭Web应用的命令为：<code>rabbitmqctl stop_app</code></li>
<li>清除的命令为：<code>rabbitmqctl reset</code></li>
<li>重新启动命令为：<code>rabbitmqctl start_app</code></li>
</ul>

        <h2 id="rabbitmq-hello-world"   >
          <a href="#rabbitmq-hello-world" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-hello-world"></a> RabbitMQ Hello World</h2>
      
<p>导入相关Maven依赖：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--rabbitmq 依赖客户端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--操作文件流的一个依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
<p>生产者：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;queue-01&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;exchange-01&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;42.192.149.71&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 获取信道：channel 实现了自动 close 接口，不需要手动关闭</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明一个交换机并指定类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化：是否用完就删除该消息，true：需要持久化</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者进行消费：是否是独家的，false：不是独家的，可以多个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除：最后一个消费者断开连接以后，该队列是否自动删除，true：自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数，例如配置死信交换机key等参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将队列和交换机进行绑定，并指定 routing key 为 &quot;info&quot;，这样发布消息时将根据 &quot;info&quot; 找到对应的队列</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消息</span></span><br><span class="line"><span class="comment">         * 1.发送到那个交换机</span></span><br><span class="line"><span class="comment">         * 2.发送的交换机要路由到队列的routing-key，交换机将使用该值找到对应的队列，若该队列不存在将抛异常</span></span><br><span class="line"><span class="comment">         * 3.其他的参数信息，例如设置消息的优先级或到期时间expiration</span></span><br><span class="line"><span class="comment">         * 4.发送消息的消息体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,  <span class="string">&quot;info&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>生产者声明了交换机和队列并进行绑定（设置<code>routingKey</code>为<code>&quot;info&quot;</code>），二者将由 RabbitMQ 服务器创建并维护。生产者将消息发往指定的交换机后，RabbitMQ 服务器将根据传入的<code>routingKey</code>找到对应的队列，将消息放入其中，等待消费者消费该队列中的消息。</p>
<p>消费者：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;queue-01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;42.192.149.71&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预取值分发，当前消费者能同时异步地消费6条消息</span></span><br><span class="line">        <span class="keyword">int</span> prefetchCount = <span class="number">6</span>;</span><br><span class="line">        channel.basicQos(prefetchCount);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.........&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者成功消费的回调：处理队列中传来的消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取消息内容</span></span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息:&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消息应答：手动回复 RabbitMQ 服务器已收到消息，可以从队列中删除</span></span><br><span class="line">            <span class="comment">// 获取到当前的消息编号Tag，只应答其自己，不批量应答</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者取消消费的回调：如在消费的时候队列被删除掉了</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者消费消息 - 接受消息</span></span><br><span class="line"><span class="comment">         * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">         * 2.消费成功之后是否要自动应答：true代表自动应答，false代表手动应答</span></span><br><span class="line"><span class="comment">         * 3.消费者成功消费的回调</span></span><br><span class="line"><span class="comment">         * 4.消费者取消消费的回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>消费者将根据队列名从 RabbitMQ 服务器找到对应的队列，从中获取消息，设置了预取值分发则会同时异步地消费多条消息。</p>

        <h2 id="预取值分发"   >
          <a href="#预取值分发" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#预取值分发"></a> 预取值分发</h2>
      
<p><strong>一个消息只能被消费一次</strong>。</p>
<p>默认情况下，消费者采用<strong>轮询</strong>的方式进行消费：例如某队列中共有4条消息，有两个消费者监听该队列，那么这两个消费者将进行轮询消费，各自消费2条消息：</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903203642528.png" alt="image-20210903203642528" /></p>
<p>但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮询分发的话，处理速度快的消费者很大一部分时间处于空闲状态（在等待另一个消费者消费完自己才能消费下一个消息），而处理慢的那个消费者一直在干活，此时轮询分配方式就不太好。</p>
<p>为了避免这种情况，在消费者中消费之前，可以为每个消费者设置<strong>预取值分发</strong>，即预先取出一部分数量的消息进行消费。设置方法为：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预取值分发，当前消费者能同时异步地消费6条消息</span></span><br><span class="line"><span class="keyword">int</span> prefetchCount = <span class="number">6</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></div></figure>
<p>通俗来讲，如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，然后 RabbitMQ 就会把该任务分配给没有那么忙的那个空闲消费者。这样就可以根据服务器性能的不同事先设置好<code>prefetchCount</code>的值。</p>
<p>当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。</p>

        <h3 id="带权的消息分发"   >
          <a href="#带权的消息分发" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#带权的消息分发"></a> 带权的消息分发</h3>
      
<p>本身消息的发送就是<strong>异步</strong>发送的，所以在任何时候，channel 上肯定不止只有一个消息，另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过使用 basic.qos 方法设置 “预取计数” 值来完成的。</p>
<p>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。</p>
<p>通常，增加预取值将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>。应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p>
<p>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903205627257.png" alt="image-20210903205627257" /></p>

        <h2 id="消息应答"   >
          <a href="#消息应答" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消息应答"></a> 消息应答</h2>
      
<blockquote>
<p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况？</p>
</blockquote>
<p>假设 RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息以及后续发送给该消费者的消息，因为它无法接收到。</p>
<p>为了保证消息在发送过程中不丢失，引入<strong>消息应答机制：消费者在接收到消息并且处理该消息之后，告诉 RabbitMQ 它已经处理完成了，RabbitMQ 服务器可以从队列中将该消息删除了。</strong></p>

        <h3 id="自动应答"   >
          <a href="#自动应答" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#自动应答"></a> 自动应答</h3>
      
<p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>，因为这种模式如果消息在接收到之前，消费者那边出现连接或者 Channel 关闭，那么消息就丢失了。当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</p>

        <h3 id="手动消息应答"   >
          <a href="#手动消息应答" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#手动消息应答"></a> 手动消息应答</h3>
      
<p>手动应答的好处是可以<strong>批量应答</strong>并且减少网络拥堵 ，其分为以下三类：</p>
<ul>
<li><code>Channel.basicAck</code> (用于肯定确认)：RabbitMQ 已知道该消息成功被处理，可以将其丢弃了。</li>
<li><code>Channel.basicNack</code> (用于否定确认)</li>
<li><code>Channel.basicReject</code> (用于否定确认)：与 <code>Channel.basicNack</code> 相比少一个参数，不处理该消息了，直接拒绝，可以将其丢弃了。</li>
</ul>
<p><strong>Multiple</strong> 的解释：</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204201626.png" alt="image-20210903204201626" /></p>
<ul>
<li>true 代表批量应答 channel 上未应答的消息：比如说 channel 上有传送 tag 的消息 5、6、7、8， 当前 tag 是 8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答。</li>
<li>false 同上面相比只会应答 tag=8 的消息， 5、6、7 这三个消息依然不会被确认收到消息应答。</li>
</ul>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204307310.png" alt="image-20210903204307310" /></p>
<p>消费者设置消息手动应答：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取消息内容</span></span><br><span class="line">    String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息:&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息应答：手动回复 RabbitMQ 服务器已收到消息，可以从队列中删除</span></span><br><span class="line">    <span class="comment">// 获取到当前的消息编号Tag，只应答其自己，不批量应答</span></span><br><span class="line">    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, deliverCallback, cancelCallback);</span><br></pre></td></tr></table></div></figure>

        <h3 id="消息重新入队"   >
          <a href="#消息重新入队" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消息重新入队"></a> 消息重新入队</h3>
      
<p>如果消费者由于某些原因失去连接 (其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204350479.png" alt="image-20210903204350479" /></p>
<p>测试消息重新入队：</p>
<p>正常情况下消息发送方发送两个消息，C1 和 C2 分别接收到消息并进行处理。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204919165.png" alt="image-20210903204919165" /></p>
<p>在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了，此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204940385.png" alt="image-20210903204940385" /></p>

        <h2 id="消息队列持久化"   >
          <a href="#消息队列持久化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消息队列持久化"></a> 消息/队列持久化</h2>
      
<p>当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需要将队列和消息都标记为持久化。</p>

        <h3 id="队列持久化"   >
          <a href="#队列持久化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#队列持久化"></a> 队列持久化</h3>
      
<p>之前创建的队列都是非持久化的，RabbitMQ 如果重启的话，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 <code>durable</code> 参数设置为持久化。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让队列持久化</span></span><br><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 声明队列</span></span><br><span class="line">channel.queueDeclare(QUEUE_NAME, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></div></figure>
<p>注意：如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误。</p>

        <h3 id="消息持久化"   >
          <a href="#消息持久化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消息持久化"></a> 消息持久化</h3>
      
<p>消息实现持久化需要在消息<strong>生产者</strong>修改代码，<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code> 添加这个属性。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903205243652.png" alt="image-20210903205243652" /></p>
<p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候但是还没有存储完，消息还在缓存的一个间隔点。此时并没有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p>

        <h2 id="发布确认"   >
          <a href="#发布确认" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#发布确认"></a> 发布确认</h2>
      
<p><strong>发布确认是为了确保生产者发送的消息能够被 RabbitMQ 服务器接收到，若 RabbitMQ 服务器宕机无法接收消息，则生产者能及时察觉到，从而重新发送消息，防止消息丢失时生产者无法察觉。</strong></p>
<p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID (从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者 (包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p>
<p>confirm 模式最大的好处在于它是<strong>异步</strong>的，<strong>一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息</strong>，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p>
<p>开启发布确认的方法：发布确认默认是没有开启的，如果要开启，需要调用方法 <code>confirmSelect()</code>：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></div></figure>

        <h3 id="单个确认发布策略"   >
          <a href="#单个确认发布策略" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#单个确认发布策略"></a> 单个确认发布策略</h3>
      
<p>这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，<strong>也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布</strong>，<code>waitForConfirmsOrDie(long)</code> 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p>
<p>这种确认方式有一个最大的缺点就是：<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p>
<p>此模式下，生产者将等待服务端返回确认消息程序才会继续执行，若服务端返回 false 或超时时间内未返回，则生产者可以消息重发。生产者端配置方式：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">    String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务端返回 false 或超时时间内未返回，生产者可以消息重发</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = channel.waitForConfirms();</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="批量确认发布策略"   >
          <a href="#批量确认发布策略" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#批量确认发布策略"></a> 批量确认发布策略</h3>
      
<p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">    <span class="comment">//队列声明</span></span><br><span class="line">    String queueName = UUID.randomUUID().toString();</span><br><span class="line">    channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="comment">//批量确认消息大小</span></span><br><span class="line">    <span class="keyword">int</span> batchSize = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//未确认消息个数</span></span><br><span class="line">    <span class="keyword">int</span> outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        outstandingMessageCount++;</span><br><span class="line">        <span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">            channel.waitForConfirms();</span><br><span class="line">            outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为了确保还有剩余没有确认消息 再次确认</span></span><br><span class="line">    <span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        channel.waitForConfirms();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个批量确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="异步确认发布策略"   >
          <a href="#异步确认发布策略" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#异步确认发布策略"></a> 异步确认发布策略</h3>
      
<p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都很高， 它是利用<strong>回调函数</strong>来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903210632247.png" alt="image-20210903210632247" /></p>
<p>如何处理异步未确认消息？最好的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel())</span><br><span class="line">    &#123;</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程安全有序的一个哈希表，适用于高并发的情况</span></span><br><span class="line"><span class="comment">         * 1.轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">         * 2.轻松批量删除条目 只要给到序列号</span></span><br><span class="line"><span class="comment">         * 3.支持并发访问</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class="keyword">new</span></span><br><span class="line">            ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 确认收到消息的一个回调</span></span><br><span class="line"><span class="comment">         * 1.sequenceNumber：消息序列号</span></span><br><span class="line"><span class="comment">         * 2.multiple：批量消息应答，true 可以确认小于等于当前序列号的消息，false 确认当前序列号消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConfirmCallback ackCallback = (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                <span class="comment">// 返回的是小于等于当前序列号的未确认消息 是一个 Map，其是原 Map 的一个浅拷贝，修改其即可修改原 Map</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; confirmed =</span><br><span class="line">                    outstandingConfirms.headMap(sequenceNumber, <span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// 清除该部分未确认消息</span></span><br><span class="line">                confirmed.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//只清除当前序列号的消息</span></span><br><span class="line">                outstandingConfirms.remove(sequenceNumber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        ConfirmCallback nackCallback = (sequenceNumber, multiple) -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            String message = outstandingConfirms.get(sequenceNumber);</span><br><span class="line">            System.out.println(<span class="string">&quot;发布的消息&quot;</span>+message+<span class="string">&quot;未被确认，序列号&quot;</span>+sequenceNumber);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加一个异步确认的监听器</span></span><br><span class="line"><span class="comment">         * 1.确认收到消息的回调</span></span><br><span class="line"><span class="comment">         * 2.未收到消息的回调 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.addConfirmListener(ackCallback, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 发布多条消息，将这些消息的信息同样保存到outstandingConfirms中，其可以在其他线程安全访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            String message = <span class="string">&quot;消息&quot;</span> + i;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">        	* channel.getNextPublishSeqNo()获取下一个消息的序列号</span></span><br><span class="line"><span class="comment">        	* 通过序列号与消息体进行一个关联</span></span><br><span class="line"><span class="comment">        	* 全部都是未确认的消息体</span></span><br><span class="line"><span class="comment">         	*/</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cb4y1o7zz?p=77" >https://www.bilibili.com/video/BV1cb4y1o7zz?p=77</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>以上 3 种发布策略确认速度对比：</p>
<ul>
<li><strong>单独发布消息</strong>：同步等待确认，简单，但吞吐量非常有限</li>
<li><strong>批量发布消息</strong>：批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是哪条消息出现了问题</li>
<li><strong>异步处理</strong>：最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</li>
</ul>

        <h2 id="交换机-exchanges"   >
          <a href="#交换机-exchanges" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#交换机-exchanges"></a> 交换机 Exchanges</h2>
      
<p>RabbitMQ 消息传递模型的核心思想是：生产者生产的消息从不会直接发送到队列。实际上，<strong>通常生产者甚至都不知道这些消息传递传递到了哪些队列中</strong>。</p>
<ul>
<li>生产者只将消息发给交换机，至于该交换机将消息发送给了哪个队列其是不知道的（通常将绑定的工作放到Spring的<code>@Configuration</code>配置类里，从而与生产者解耦，生产者本身并不知道绑定信息）</li>
<li>消费者只从队列获取消息，至于该消息来自哪个交换机其是不知道的</li>
</ul>
<p>相反，<strong>生产者只能将消息发送到交换机 (exchange)</strong> ，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息，是应该把这些消息放到特定队列还是说把他们放到许多队列中还是说应该丢弃它们。这就由交换机的类型来决定。</p>
<p>Exchanges 的类型：</p>
<ul>
<li><strong>直接 (direct)</strong>：消息只去到它绑定的 <code>routingKey</code> 队列中去（该消息要发往的<code>routingKey</code> 由生产者发送消息时指定）</li>
<li><strong>主题 (topic)</strong>：发送到类型是 topic 交换机的消息的 <code>routingKey</code> 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词，比如说：<code>&quot;stock.usd.nyse&quot;</code>。</li>
<li><strong>标题 (headers)</strong>：</li>
<li><strong>扇出 (fanout)</strong>：将接收到的所有消息<strong>广播</strong>到它知道的所有队列中</li>
</ul>

        <h3 id="主题-topic-类型"   >
          <a href="#主题-topic-类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#主题-topic-类型"></a> 主题 Topic 类型</h3>
      
<p>发送到类型是 topic 交换机的消息的 <code>routingKey</code> 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词，比如说：<code>&quot;stock.usd.nyse&quot;</code>。</p>
<p>在这个规则列表中，其中有两个替换符是需要注意的：</p>
<ul>
<li>*(星号) 可以代替一个单词</li>
<li>#(井号) 可以替代零个或多个单词</li>
</ul>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903213659559.png" alt="image-20210903213659559" /></p>
<p>上图对应关系：</p>
<ul>
<li>Q1–&gt; 绑定的是：
<ul>
<li>中间带 <code>orange</code> 带 3 个单词的字符串 (<code>*.orange.*</code>)</li>
</ul>
</li>
<li>Q2–&gt; 绑定的是：
<ul>
<li>最后一个单词是 <code>rabbit</code> 的 3 个单词 (<code>*.*.rabbit</code>)</li>
<li>第一个单词是 <code>lazy</code> 的多个单词 (<code>lazy.#</code>)</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>当一个队列绑定键是 #，那么这个队列将接收所有数据，就有点像 fanout 了</li>
<li>如果队列绑定键当中没有 #和 * 出现，那么该队列绑定类型就是 direct 了</li>
</ul>

        <h2 id="死信队列"   >
          <a href="#死信队列" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#死信队列"></a> 死信队列</h2>
      

        <h3 id="死信的概念"   >
          <a href="#死信的概念" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#死信的概念"></a> 死信的概念</h3>
      
<p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p>
<p>应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。</p>

        <h3 id="死信的来源"   >
          <a href="#死信的来源" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#死信的来源"></a> 死信的来源</h3>
      
<ul>
<li><strong>消息 TTL 过期</strong>：TTL 是 Time To Live 的缩写，也就是生存时间（<code>expiration</code>），当生存时间到了该消息还未被消费，则成为死信。</li>
<li><strong>队列达到最大长度</strong>：若队列满了，无法再添加数据到队列中，那些无法加进去的消息成为死信。</li>
<li><strong>消息被拒绝</strong>：当消息被消费者拒绝(<code>basicReject()</code> 或 <code>basicNack</code>) 并且 <code>requeue=false</code>时成为死信。</li>
</ul>

        <h3 id="死信实战"   >
          <a href="#死信实战" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#死信实战"></a> 死信实战</h3>
      
<p>情景：普通交换机 <code>normal_exchange</code>，使用 <code>routingKey=&quot;zhangsan&quot;</code> 路由到普通队列 <code>normal-queue</code>，消费者 <code>C1</code> 将获取该队列里的消息。若某个消息成为了死信，则其将被路由到死信交换机 <code>dead_exchange</code>，该死信交换机将使用 <code>routingKey=&quot;lisi&quot;</code> 路由到死信队列 <code>dead-queue</code>，消费者 C2 将获取死信队列里的消息进行处理。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903214211735.png" alt="image-20210903214211735" /></p>
<p>分别分析三种死信情况下的代码：</p>

        <h3 id="死信之-消息-ttl-过期-情况"   >
          <a href="#死信之-消息-ttl-过期-情况" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#死信之-消息-ttl-过期-情况"></a> 死信之 “消息 TTL 过期” 情况</h3>
      
<p>消费者 C1 代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列 - 消费者C1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        String deadQueue = <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//死信队列绑定：队列、交换机、路由键（routingKey）</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常队列</span></span><br><span class="line">        String normalQueue = <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息........... &quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(normalQueue, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>生产者代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//设置消息的 TTL 时间 10s，即超过 10s 该消息将成为死信</span></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">        <span class="comment">//该信息是用作演示队列个数限制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>启动 C1 ，之后关闭消费者，模拟其接收不到消息（这样消息就会过期），再启动生产者：</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903214935805.png" alt="image-20210903214935805" /></p>
<p>消费者 C2 代码：以上步骤完成后，启动 C2 消费者，它消费死信队列里面的消息：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer02</span> </span>&#123;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        String deadQueue = <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收死信消息........... &quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer02 接收到消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(deadQueue, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903215018034.png" alt="image-20210903215018034" /></p>

        <h3 id="死信之-队列达到最大长度-情况"   >
          <a href="#死信之-队列达到最大长度-情况" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#死信之-队列达到最大长度-情况"></a> 死信之 “队列达到最大长度” 情况</h3>
      
<p>消息生产者代码去掉 TTL 属性：</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903215130608.png" alt="image-20210903215130608" /></p>
<p>C1 消费者修改以下代码 （启动之后关闭该消费者，模拟其接收不到消息）:</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903215202328.png" alt="image-20210903215202328" /></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置正常队列的长度限制为6，例如发10个消息，4个则为死信</span></span><br><span class="line">params.put(<span class="string">&quot;x-max-length&quot;</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></div></figure>
<p><strong>注意此时需要把原先队列删除，因为参数改变了。</strong></p>
<p>C2 消费者代码不变 (启动 C2 消费者)：</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903215400615.png" alt="image-20210903215400615" /></p>

        <h3 id="死信之-消息被拒-情况"   >
          <a href="#死信之-消息被拒-情况" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#死信之-消息被拒-情况"></a> 死信之 “消息被拒” 情况</h3>
      
<p>消息生产者代码同上生产者一致。</p>
<p>C1 消费者代码 (启动之后关闭该消费者 模拟其接收不到消息) 拒收消息 “info5” ：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        String deadQueue = <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//死信队列绑定：队列、交换机、路由键（routingKey）</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//        //设置正常队列的长度限制，例如发10个，4个则为死信</span></span><br><span class="line">        <span class="comment">//        params.put(&quot;x-max-length&quot;,6);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常队列</span></span><br><span class="line">        String normalQueue = <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息........... &quot;</span>);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (message.equals(<span class="string">&quot;info5&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message + <span class="string">&quot;并拒绝签收该消息&quot;</span>);</span><br><span class="line">                <span class="comment">//requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span></span><br><span class="line">                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message);</span><br><span class="line">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//开启手动应答</span></span><br><span class="line">        channel.basicConsume(normalQueue, <span class="keyword">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903215518080.png" alt="image-20210903215518080" /></p>
<p>C2 消费者代码不变：启动消费者 1 然后再启动消费者 2：</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903215531918.png" alt="image-20210903215531918" /></p>

        <h2 id="延迟队列"   >
          <a href="#延迟队列" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#延迟队列"></a> 延迟队列</h2>
      

        <h3 id="延迟队列概念"   >
          <a href="#延迟队列概念" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#延迟队列概念"></a> 延迟队列概念</h3>
      
<p>延时队列内部是<strong>有序的</strong>，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</p>
<p><strong>使用延迟队列时，将需要延迟的消息放到延迟队列中（该队列设置到期时间），同时不指定任何消费者监听该队列，这样该队列内的消息在到达到期时间后就会进入死信队列。此时再指定相应的消费者监听死信队列，从中获取延迟的消息进行消费（例如取消订单等）</strong></p>
<p>延迟队列使用场景：</p>
<ul>
<li>订单在十分钟之内未支付则自动取消；</li>
<li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒；</li>
<li>用户注册成功后，如果三天内没有登陆则进行短信提醒；</li>
<li>用户发起退款，如果三天内没有得到处理则通知相关运营人员；</li>
<li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议。</li>
</ul>
<p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭。那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？</p>
<p>如果数据量比较少，确实可以这样做，比如：对于 “如果账单一周内未支付则进行自动结算” 这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。</p>
<p>但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭 “，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904144655029.png" alt="image-20210904144655029" /></p>

        <h3 id="rabbitmq-中的-ttl"   >
          <a href="#rabbitmq-中的-ttl" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-中的-ttl"></a> RabbitMQ 中的 TTL</h3>
      
<p>TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。</p>
<p>换句话说，<strong>如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为“死信”</strong>。如果同时配置了队列的 TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p>
<ul>
<li><strong>队列设置 TTL</strong>：在创建队列的时候设置队列的 <code>“x-message-ttl”</code> 属性</li>
</ul>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904144805663.png" alt="image-20210904144805663" /></p>
<ul>
<li><strong>消息设置 TTL</strong>：是针对每条消息设置 TTL</li>
</ul>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904144916833.png" alt="image-20210904144916833" /></p>
<p><strong>两者的区别</strong>：</p>
<ul>
<li>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃 （如果配置了死信队列被丢到死信队列中），而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间。</li>
<li>另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</li>
</ul>
<p>下面介绍在 Spring Boot 中使用延迟队列的示例</p>

        <h3 id="spring-boot-整合-rabbitmq"   >
          <a href="#spring-boot-整合-rabbitmq" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#spring-boot-整合-rabbitmq"></a> Spring Boot 整合 RabbitMQ</h3>
      
<ol>
<li>导入依赖</li>
</ol>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ 依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ 测试依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>配置文件：</li>
</ol>
<figure class="highlight properties"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">42.192.149.71</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></div></figure>
<ol start="3">
<li>添加 Swagger 配置类：</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhao.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">webApiConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">            .apiInfo(webApiInfo())</span><br><span class="line">            .select()</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">webApiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">            .title(<span class="string">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class="line">            .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">            .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;zhiyuan&quot;</span>, <span class="string">&quot;http://oddfar.com&quot;</span>, <span class="string">&quot;test@qq.com&quot;</span>))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h3 id="延迟队列场景"   >
          <a href="#延迟队列场景" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#延迟队列场景"></a> 延迟队列场景</h3>
      
<p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交换机 Y，它们的类型都是 <code>direct</code>，创建一个死信队列 QD，它们的绑定关系如下：</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904145729754.png" alt="image-20210904145729754" /></p>
<ol start="4">
<li>创建 <code>@Configuration</code> 配置类，在其内声明队列和交换机并进行绑定：</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhao.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TtlQueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_EXCHANGE = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_A = <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_B = <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUE = <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 xExchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">xExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(X_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 死信队列交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">yExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 A 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueaBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 B ttl 为 40s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// 声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 B 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queuebBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列 QD</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DEAD_LETTER_QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列 QD 绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">deadLetterBindingQAD</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="5">
<li>消息生产者代码：</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhao.contorller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ttl&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条信息给两个 TTL 队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自 ttl 为 10S 的队列: &quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自 ttl 为 40S 的队列: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="6">
<li>消息消费者代码：</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oddfar.contorller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterQueueConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到死信队列信息&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="7">
<li>测试：发起一个请求 <code>http://localhost:8080/ttl/sendMsg/嘻嘻嘻</code></li>
</ol>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904150453631.png" alt="image-20210904150453631" /></p>
<p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。</p>
<p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p>

        <h3 id="延时队列-ttl-优化"   >
          <a href="#延时队列-ttl-优化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#延时队列-ttl-优化"></a> 延时队列 TTL 优化</h3>
      
<p>在这里新增了一个队列 QC，绑定关系如下，该队列不设置 TTL 时间</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904150550667.png" alt="image-20210904150550667" /></p>
<p>配置文件类代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgTtlQueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_C = <span class="string">&quot;QC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 C 死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// 声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">// 没有声明 TTL 属性</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 B 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queuecBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>生产者代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延时队列优化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ttlTime 延时的毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> String ttlTime)</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, message, correlationData -&gt; &#123;</span><br><span class="line">        correlationData.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">        <span class="keyword">return</span> correlationData;</span><br><span class="line">    &#125;);</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), ttlTime, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>发起请求：</p>
<ul>
<li><code>http://localhost:8080/ttl/sendExpirationMsg/你好1/20000</code></li>
<li><code>http://localhost:8080/ttl/sendExpirationMsg/你好2/2000</code></li>
</ul>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904150828988.png" alt="image-20210904150828988" /></p>
<p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时 “死亡”。</p>
<p><strong>因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。这也就是为什么第二个延时 2 秒，却后执行。</strong></p>
<p>为解决该问题，需要安装 RabbitMQ 的一个插件 <code>rabbitmq_delayed_message_exchange</code></p>

        <h3 id="rabbitmq-插件实现延迟队列"   >
          <a href="#rabbitmq-插件实现延迟队列" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-插件实现延迟队列"></a> RabbitMQ 插件实现延迟队列</h3>
      
<p>从<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html" >官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>下载 <code>rabbitmq_delayed_message_exchange</code> 插件，然后解压放置到 RabbitMQ 的插件目录。 进入 RabbitMQ 的安装目录下的 plugins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ <code>/usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></div></figure>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904151314950.png" alt="image-20210904151314950" /></p>
<p>此时即可创建 <code>x-delayed-message</code> 类型的交换机，可创建自定义的交换机类型 <code>CustomExchange</code> ，并指定该交换机的转发类型为  <code>x-delayed-message</code>。</p>
<ol>
<li>修改配置类：</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedQueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME = <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义交换机 我们在这里定义的是一个延迟交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomExchange <span class="title">delayedExchange</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 自定义交换机的类型</span></span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDelayedQueue</span><span class="params">(<span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>消息生产者，在发送消息时需要给消息带上属性<code>setDelay(delayTime)</code></li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line"><span class="meta">@GetMapping(&quot;sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> Integer delayTime)</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message, correlationData -&gt; &#123;</span><br><span class="line">        correlationData.getMessageProperties().setDelay(delayTime);</span><br><span class="line">        <span class="keyword">return</span> correlationData </span><br><span class="line">    &#125;);</span><br><span class="line">    log.info(<span class="string">&quot; 当 前 时 间 ： &#123;&#125;, 发 送 一 条 延 迟 &#123;&#125; 毫秒的信息给队列 delayed.queue:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), delayTime, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="3">
<li>消息消费者</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME = <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line"><span class="meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveDelayedQueue</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="4">
<li>发起请求：
<ul>
<li><code>http://localhost:8080/ttl/sendDelayMsg/come on baby1/20000</code></li>
<li><code>http://localhost:8080/ttl/sendDelayMsg/come on baby2/2000</code></li>
</ul>
</li>
</ol>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904154952551.png" alt="image-20210904154952551" /></p>
<p>第二个消息被先消费掉了，符合预期</p>

        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
      
<p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正 确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。</p>
<p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景</p>

        <h2 id="发布确认高级"   >
          <a href="#发布确认高级" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#发布确认高级"></a> 发布确认高级</h2>
      
<p>在生产环境中由于一些不明原因，导致 RabbitMQ 重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？</p>
<p>确认机制方案：</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904155528622.png" alt="image-20210904155528622" /></p>
<p>代码架构图：</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904155542060.png" alt="image-20210904155542060" /></p>
<p>在配置文件当中需要添加：</p>
<figure class="highlight properties"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启发布确认功能</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启消息退回功能，见后文分析</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br></pre></td></tr></table></div></figure>
<ul>
<li><code>NONE</code> 值是禁用发布确认模式，是默认值。</li>
<li><code>CORRELATED</code> 值是发布消息成功到交换器后会触发回调方法。</li>
<li><code>SIMPLE</code> 值经测试有两种效果，其一效果和 <code>CORRELATED</code> 值一样会触发回调方法，其二在发布消息成功后使用 <code>rabbitTemplate</code> 调用 <code>waitForConfirms</code> 或 <code>waitForConfirmsOrDie</code> 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 <code>waitForConfirmsOrDie</code> 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker。</li>
</ul>
<ol>
<li>添加配置类：</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE_NAME = <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_NAME = <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明业务 Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">confirmExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明确认队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明确认队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>消息生产者的回调接口</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机是否收到消息的一个回调方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 消息相关数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack             交换机是否收到消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause           为收到消息的原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        String id = correlationData != <span class="keyword">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息，原因:&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="3">
<li>消息生产者</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE_NAME = <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyCallBack myCallBack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖注入 rabbitTemplate 之后再设置它的回调对象</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(myCallBack);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息回调和退回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息 id 为 1</span></span><br><span class="line">        CorrelationData correlationData1 = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        String routingKey = <span class="string">&quot;key1&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData1);</span><br><span class="line">        log.info(routingKey + <span class="string">&quot;发送消息内容:&#123;&#125;&quot;</span>, message + routingKey);</span><br><span class="line"></span><br><span class="line">        CorrelationData correlationData2 = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        routingKey = <span class="string">&quot;key2&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData2);</span><br><span class="line">        log.info(routingKey + <span class="string">&quot;发送消息内容:&#123;&#125;&quot;</span>, message + routingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="4">
<li>消息消费者</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_NAME = <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = CONFIRM_QUEUE_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接受到队列 confirm.queue 消息:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>结果分析：</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904160122676.png" alt="image-20210904160122676" /></p>
<p>可以看到，发送了两条消息，第一条消息的 <code>RoutingKey</code> 为 <code>“key1”</code>，第二条消息的 <code>RoutingKey</code> 为 <code>“key2”</code>，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 <code>RoutingKey</code> 与队列的 <code>BindingKey</code> 不一致，也没有其它队列能接收这个消息，所以第二条消息被直接丢弃了。丢弃的消息生产者是不知道的，需要解决告诉生产者消息传送失败。</p>

        <h3 id="回退消息"   >
          <a href="#回退消息" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#回退消息"></a> 回退消息</h3>
      
<p>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，<strong>如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的</strong>。</p>
<p>那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 <code>mandatory</code> 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者，通知生产者消息发送失败，考虑重新发送。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * true：交换机无法将消息进行路由时，会将该消息返回给生产者</span></span><br><span class="line"><span class="comment"> * false：如果发现消息无法进行路由，则直接丢弃</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br></pre></td></tr></table></div></figure>
<p>同时需要在配置文件中开启消息回退功能：</p>
<figure class="highlight properties"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启消息退回功能</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br></pre></td></tr></table></div></figure>
<p>生产者代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProducer</span> <span class="keyword">implements</span> <span class="title">RabbitTeplate</span>.<span class="title">ConfirmCallback</span>, <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">//rabbitTemplate 注入之后就设置该值</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * true：交换机无法将消息进行路由时，会将该消息返回给生产者</span></span><br><span class="line"><span class="comment">         * false：如果发现消息无法进行路由，则直接丢弃</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 设置回退消息交给谁处理</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sendMessage&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//让消息绑定一个 id 值</span></span><br><span class="line">        CorrelationData correlationData1 = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;confirm.exchange&quot;</span>,<span class="string">&quot;key1&quot;</span>,message+<span class="string">&quot;key1&quot;</span>,correlationData1);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;</span>,correlationData1.getId(),message+<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        CorrelationData correlationData2 = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;confirm.exchange&quot;</span>,<span class="string">&quot;key2&quot;</span>,message+<span class="string">&quot;key2&quot;</span>,correlationData2);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;</span>,correlationData2.getId(),message+<span class="string">&quot;key2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        String id = correlationData != <span class="keyword">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机收到消息确认成功, id:&#123;&#125;&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息 id:&#123;&#125;未成功投递到交换机,原因是:&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;消息:&#123;&#125;被服务器退回，退回原因:&#123;&#125;, 交换机是:&#123;&#125;, 路由 key:&#123;&#125;&quot;</span>,</span><br><span class="line">                 <span class="keyword">new</span> String(message.getBody()),replyText, exchange, routingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>回调接口</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>,<span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机是否收到消息的一个回调方法</span></span><br><span class="line"><span class="comment">     * CorrelationData：消息相关数据</span></span><br><span class="line"><span class="comment">     * ack：交换机是否收到消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        String id=correlationData!=<span class="keyword">null</span>?correlationData.getId():<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>,id);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>,id,cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当消息无法路由时的回调方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot; 消 息 &#123;&#125;, 被 交 换 机 &#123;&#125; 退 回 ， 退 回 原 因 :&#123;&#125;, 路 由 key:&#123;&#125;&quot;</span>,<span class="keyword">new</span> String(message.getBody()),exchange,replyText,routingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>此时若交换机无法分发生产者发送的消息，则会调用 <code>returnedMessage()</code> 方法回退消息。</p>

        <h3 id="备份交换机"   >
          <a href="#备份交换机" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#备份交换机"></a> 备份交换机</h3>
      
<p>有了 <code>mandatory</code> 参数和回退消息，我们获得了对无法投递消息的感知能力，在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 <code>mandatory</code> 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？</p>
<p>前面在设置死信队列的章节中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种<strong>备份交换机</strong>的机制存在，可以很好的应对这个问题。</p>
<p>备份交换机可以理解为 RabbitMQ 中交换机的 “备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，<strong>当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理</strong>，通常备份交换机的类型为 <code>Fanout</code> ，这样就能把所有消息都投递到与其绑定的队列中，<strong>然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进入这个队列了。我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</strong></p>
<p>架构图：</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904163932459.png" alt="image-20210904163932459" /></p>
<p>在配置类中添加绑定备份交换机：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE_NAME = <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_NAME = <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACKUP_EXCHANGE_NAME = <span class="string">&quot;backup.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACKUP_QUEUE_NAME = <span class="string">&quot;backup.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WARNING_QUEUE_NAME = <span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明确认队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明确认队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明备份 Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">backupExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(BACKUP_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明确认 Exchange 交换机的备份交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange</span><br><span class="line">        confirmExchange() &#123;</span><br><span class="line">        ExchangeBuilder exchangeBuilder =</span><br><span class="line">            ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)</span><br><span class="line">            .durable(<span class="keyword">true</span>)</span><br><span class="line">            <span class="comment">//设置该交换机的备份交换机</span></span><br><span class="line">            .withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME);</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange)exchangeBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明警告队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">warningQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明报警队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">warningBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange</span></span></span><br><span class="line"><span class="function"><span class="params">                                  backupExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明备份队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;backQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">backQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明备份队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">backupBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;backQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>报警消费者：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarningConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WARNING_QUEUE_NAME = <span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = WARNING_QUEUE_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveWarningMsg</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.error(<span class="string">&quot;报警发现不可路由消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>此时当交换机发现有无法处理的消息时就会转发给备份交换机，由其将消息转发给备份队列，令报警消费者监听该队列。</p>
<p><strong>注意</strong>：当<code>mandatory</code> 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，答案是<strong>备份交换机优先级高</strong>。</p>

        <h2 id="幂等性"   >
          <a href="#幂等性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#幂等性"></a> 幂等性</h2>
      

        <h3 id="概念"   >
          <a href="#概念" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3>
      
<p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等.</p>

        <h3 id="消息重复消费"   >
          <a href="#消息重复消费" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消息重复消费"></a> 消息重复消费</h3>
      
<p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p>

        <h3 id="解决思路"   >
          <a href="#解决思路" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#解决思路"></a> 解决思路</h3>
      
<p>MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识，比如时间戳或者 UUID ，订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过。</p>

        <h3 id="消费端的幂等性保障"   >
          <a href="#消费端的幂等性保障" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消费端的幂等性保障"></a> 消费端的幂等性保障</h3>
      
<p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。</p>
<p>业界主流的幂等性有两种操作:</p>
<ul>
<li>唯一 ID + 指纹码机制，用数据库主键去重；</li>
<li>利用 redis 的原子性去实现。</li>
</ul>

        <h3 id="唯一-id-指纹码机制"   >
          <a href="#唯一-id-指纹码机制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#唯一-id-指纹码机制"></a> 唯一 ID + 指纹码机制</h3>
      
<p>指纹码：我们的一些规则或者时间戳加别的服务给到的唯一信息码，它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p>

        <h3 id="note-redis-原子性"   >
          <a href="#note-redis-原子性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#note-redis-原子性"></a> note Redis 原子性</h3>
      
<p>利用 redis 执行 setnx 命令，天然具有幂等性，从而实现不重复消费</p>

        <h2 id="优先级队列"   >
          <a href="#优先级队列" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优先级队列"></a> 优先级队列</h2>
      

        <h3 id="使用场景"   >
          <a href="#使用场景" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3>
      
<p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧。</p>
<p>但是，天猫商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果、小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。</p>

        <h3 id="实现方式"   >
          <a href="#实现方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#实现方式"></a> 实现方式</h3>
      
<ol>
<li>控制台页面添加一个队列，给该队列设置最大优先级：</li>
</ol>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904170243555.png" alt="image-20210904170243555" /></p>
<ol start="2">
<li>队列中代码添加优先级</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap();</span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br></pre></td></tr></table></div></figure>
<ol start="3">
<li>消息中代码添加优先级</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().priority(<span class="number">10</span>).build();</span><br></pre></td></tr></table></div></figure>
<p><strong>注意事项</strong>：要让队列实现优先级需要做的事情有：</p>
<ul>
<li>队列需要设置为优先级队列</li>
<li>消息需要设置消息的优先级</li>
<li>消费者需要等待消息已经发送到队列中才去消费，因为这样才有机会对消息进行排序。</li>
</ul>
<ol start="4">
<li>生产者：</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给消息赋予一个 priority 属性</span></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().priority(<span class="number">10</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息完成:&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="5">
<li>消费者：</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap();</span><br><span class="line">        params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 推送的消息如何进行消费的接口回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="6">
<li>测试：</li>
</ol>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904170543180.png" alt="image-20210904170543180" /></p>

        <h2 id="惰性队列"   >
          <a href="#惰性队列" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#惰性队列"></a> 惰性队列</h2>
      

        <h3 id="使用场景-2"   >
          <a href="#使用场景-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#使用场景-2"></a> 使用场景</h3>
      
<p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因 (比如消费者下线、宕机亦或者是由于维护而关闭等) 而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p>
<p>默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在<strong>内存</strong>之中， 这样可以更加快速的将消息发送给消费者。<strong>即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份</strong>。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。</p>
<p><strong>惰性队列会将消息存储到硬盘中，只在内存中保存每条消息在硬盘中的索引，这样就不会消耗大量的内存资源。队列的持久化是指消息数据既保存在硬盘里又保存在内存中。</strong></p>

        <h3 id="两种模式"   >
          <a href="#两种模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#两种模式"></a> 两种模式</h3>
      
<p>队列具备两种模式：<code>default</code> 和 <code>lazy</code>。默认的为 <code>default</code> 模式，在 3.6.0 之前的版本无需做任何变更。<code>lazy</code> 模式即为惰性队列的模式，可以通过调用 <code>channel.queueDeclare</code> 方法的时候在参数中设置，也可以通过 <code>Policy</code> 的方式设置，<strong>如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级</strong>。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p>
<p>在队列声明的时候可以通过 <code>“x-queue-mode”</code> 参数来设置队列的模式，取值为 <code>“default”</code> 和 <code>“lazy”</code>。下面示例中演示了一个惰性队列的声明细节：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></div></figure>
<p>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅占用 1.5MB。</p>

        <h2 id="rabbitmq-集群部署"   >
          <a href="#rabbitmq-集群部署" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-集群部署"></a> RabbitMQ 集群部署</h2>
      
<p>集群部署详细配置见<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://yuyun-zhao.github.io/documents/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ" >RabbitMQ文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="federation-exchange"   >
          <a href="#federation-exchange" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#federation-exchange"></a> Federation Exchange</h2>
      
<p>Federation Exchange 见<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://yuyun-zhao.github.io/documents/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ" >RabbitMQ文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="shovel"   >
          <a href="#shovel" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#shovel"></a> Shovel</h2>
      
<p>Federation 具备的数据转发功能类似，Shovel 够可靠、持续地从一个 Broker 中的队列(作为源端，即 source)拉取数据并转发至另一个 Broker 中的交换器(作为目的端，即 destination)。作为源端的队列和作为 目的端的交换器可以同时位于同一个 Broker，也可以位于不同的 Broker 上。Shovel 可以翻译为&quot;铲子&quot;，是 一种比较形象的比喻，这个&quot;铲子&quot;可以将消息从一方&quot;铲子&quot;另一方。Shovel 行为就像优秀的客户端应用程 序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。</p>

        <h3 id="搭建步骤"   >
          <a href="#搭建步骤" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#搭建步骤"></a> 搭建步骤</h3>
      
<ol>
<li>开启插件(需要的机器都开启)</li>
</ol>
<ul>
<li><code>rabbitmq-plugins enable rabbitmq_shovel</code></li>
<li><code>rabbitmq-plugins enable rabbitmq_shovel_management</code></li>
</ul>
<ol start="2">
<li>原理图(在源头发送的消息直接回进入到目的地队列)</li>
</ol>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904171357566.png" alt="image-20210904171357566" /></p>
<ol start="3">
<li>添加 shovel 源和目的地</li>
</ol>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210904171411419.png" alt="image-20210904171411419" /></p>

        <h2 id="rabbitmq-面试题"   >
          <a href="#rabbitmq-面试题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-面试题"></a> RabbitMQ 面试题</h2>
      

        <h3 id="rabbitmq-是什么"   >
          <a href="#rabbitmq-是什么" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-是什么"></a> RabbitMQ 是什么？</h3>
      
<p>RabbitMQ 是实现了 <strong>高级消息队列协议（AMQP）</strong> 的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ 服务器是用 Erlang 语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。</p>
<p>PS: 也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件。</p>

        <h3 id="rabbitmq-特点"   >
          <a href="#rabbitmq-特点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-特点"></a> RabbitMQ 特点？</h3>
      
<ul>
<li>可靠性：RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</li>
<li>灵活的路由：在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。</li>
<li>扩展性：多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。</li>
<li>高可用性：队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li>
<li>多种协议：RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息中间件协议。</li>
<li>多语言客户端：RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</li>
<li>管理界面：RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。</li>
<li>插件机制：RabbitMQ 提供了许多插件， 以实现从多方面进行扩展，当然也可以编写自己的插件。</li>
</ul>

        <h3 id="amqp-是什么"   >
          <a href="#amqp-是什么" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#amqp-是什么"></a> AMQP 是什么？</h3>
      
<p>RabbitMQ 就是 AMQP 协议的 Erlang 的实现（当然 RabbitMQ 还支持 STOMP2、 MQTT3 等协议 ）。 AMQP 的模型架构和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定。</p>
<p>RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。</p>

        <h3 id="amqp-协议-3-层"   >
          <a href="#amqp-协议-3-层" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#amqp-协议-3-层"></a> AMQP 协议 3 层？</h3>
      
<ul>
<li><strong>Module Layer</strong>：协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。</li>
<li><strong>Session Layer</strong>：中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。</li>
<li><strong>Transport Layer</strong>：最底层，主要传输二进制数据流，提供帧的处理、信道复用、错误检测和数据表示等。</li>
</ul>

        <h3 id="amqp-模型的几大组件"   >
          <a href="#amqp-模型的几大组件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#amqp-模型的几大组件"></a> AMQP 模型的几大组件？</h3>
      
<ul>
<li><strong>交换器（Exchange）</strong>：消息代理服务器中用于把消息路由到队列的组件。</li>
<li><strong>队列（Queue）</strong>：用来存储消息的数据结构，位于硬盘或内存中。</li>
<li><strong>绑定（Binding）</strong>：一套规则，告知交换器消息应该将消息投递给哪个队列。</li>
</ul>

        <h3 id="说说生产者-producer-和消费者-consumer"   >
          <a href="#说说生产者-producer-和消费者-consumer" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#说说生产者-producer-和消费者-consumer"></a> 说说生产者 Producer 和消费者 Consumer?</h3>
      
<p>生产者：</p>
<ul>
<li>消息生产者，就是投递消息的一方。</li>
<li>消息一般包含两个部分：消息体（payload）和标签（Label）。</li>
</ul>
<p>消费者：</p>
<ul>
<li>消费消息，也就是接收消息的一方。</li>
<li>消费者连接到 RabbitMQ 服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。</li>
</ul>

        <h3 id="为什么需要消息队列"   >
          <a href="#为什么需要消息队列" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#为什么需要消息队列"></a> 为什么需要消息队列？</h3>
      
<p>从本质上来说是因为互联网的快速发展，业务不断扩张，促使技术架构需要不断的演进。</p>
<p>从以前的单体架构到现在的微服务架构，成百上千的服务之间相互调用和依赖。从互联网初期一个服务器上有 100 个在线用户已经很了不得，到现在坐拥 10 亿日活的微信。此时，我们需要有一个「工具」来解耦服务之间的关系、控制资源合理合时的使用以及缓冲流量洪峰等等。因此，消息队列就应运而生了。</p>
<p>它常用来实现：<strong>异步处理</strong>、<strong>服务解耦</strong>、<strong>流量控制（削峰）</strong>。</p>

        <h3 id="说说-broker-服务节点-queue-队列-exchange-交换器"   >
          <a href="#说说-broker-服务节点-queue-队列-exchange-交换器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#说说-broker-服务节点-queue-队列-exchange-交换器"></a> 说说 Broker 服务节点、Queue 队列、Exchange 交换器？</h3>
      
<ul>
<li><strong>Broker</strong>：可以看做 RabbitMQ 的服务节点。一般请下一个 Broker 可以看做一个 RabbitMQ 服务器。</li>
<li><strong>Queue</strong>：RabbitMQ 的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。</li>
<li><strong>Exchange</strong>：生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。</li>
</ul>

        <h3 id="消息队列有什么优缺点"   >
          <a href="#消息队列有什么优缺点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消息队列有什么优缺点"></a> 消息队列有什么优缺点</h3>
      
<p>优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰。缺点有以下几个：</p>
<ul>
<li>系统可用性降低系统引入的外部依赖越多，越容易挂掉。万一 MQ 挂了，MQ 一挂，整套系统崩溃</li>
<li>系统复杂度提高，硬生生加个 MQ 进来，怎么保证消息没有重复消费？怎么处理消息丢失的情况？</li>
<li>怎么保证消息传递的顺序性？</li>
<li>一致性问题， A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致 了。</li>
</ul>

        <h3 id="如何保证消息的可靠性"   >
          <a href="#如何保证消息的可靠性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#如何保证消息的可靠性"></a> 如何保证消息的可靠性？</h3>
      
<p>消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。</p>
<ul>
<li><strong>生产者到 RabbitMQ</strong>：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。</li>
<li><strong>RabbitMQ 自身</strong>：持久化、集群、普通模式、镜像模式。</li>
<li><strong>RabbitMQ 到消费者</strong>：basicAck 机制、死信队列、消息补偿机制。</li>
</ul>

        <h3 id="什么是-routingkey-路由键"   >
          <a href="#什么是-routingkey-路由键" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#什么是-routingkey-路由键"></a> 什么是 RoutingKey 路由键？</h3>
      
<p>生产者将消息发送给交换器的时候，会指定一个 <code>RoutingKey</code>, 用来指定这个消息的路由规则，这个 <code>RoutingKey</code> 需要与交换器类型和绑定键 （<code>BindingKey</code>） 联合使用才能最终生效。</p>

        <h3 id="binding-绑定"   >
          <a href="#binding-绑定" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#binding-绑定"></a> Binding 绑定？</h3>
      
<p>通过绑定将交换器和队列关联起来，一般会指定一个 <code>BindingKey</code>, 这样 RabbitMQ 就知道如何正确路由消息到队列了。</p>

        <h3 id="交换器-4-种类型"   >
          <a href="#交换器-4-种类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#交换器-4-种类型"></a> 交换器 4 种类型？</h3>
      
<ul>
<li><strong>fanout</strong>：把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</li>
<li><strong>direct</strong>：把消息路由到 <code>BindingKey</code> 和 <code>RoutingKey</code> 完全匹配的队列中。</li>
<li><strong>headers</strong>：不依赖路由键匹配规则路由消息。是根据发送消息内容中的 headers 属性进行匹配。性能差，基本用不到。</li>
<li><strong>topic</strong>：按照匹配规则分发。* 匹配一个单词，# 匹配多个或者 0 个</li>
</ul>

        <h3 id="生产者消息运转"   >
          <a href="#生产者消息运转" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#生产者消息运转"></a> 生产者消息运转？</h3>
      
<ul>
<li>Producer 先连接到 Broker, 建立连接 Connection, 开启一个信道 （Channel）。</li>
<li>Producer 声明一个交换器并设置好相关属性。</li>
<li>Producer 声明一个队列并设置好相关属性。</li>
<li>Producer 通过路由键将交换器和队列绑定起来。</li>
<li>Producer 发送消息到 Broker，其中包含路由键、交换器等信息。</li>
<li>相应的交换器根据接收到的路由键查找匹配的队列。</li>
<li>如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。</li>
<li>关闭信道。</li>
<li>关闭连接。</li>
</ul>

        <h3 id="消费者接收消息过程"   >
          <a href="#消费者接收消息过程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消费者接收消息过程"></a> 消费者接收消息过程？</h3>
      
<ul>
<li>Producer 先连接到 Broker, 建立连接 Connection, 开启一个信道 （Channel）。</li>
<li>向 Broker 请求消费响应的队列中消息，可能会设置响应的回调函数。</li>
<li>等待 Broker 回应并投递相应队列中的消息，接收消息。</li>
<li>消费者确认收到的消息，ack。</li>
<li>RabbitMQ 从队列中删除已经确定的消息。</li>
<li>关闭信道。</li>
<li>关闭连接。</li>
</ul>

        <h3 id="交换器无法根据自身类型和路由键找到符合条件队列时有哪些处理"   >
          <a href="#交换器无法根据自身类型和路由键找到符合条件队列时有哪些处理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#交换器无法根据自身类型和路由键找到符合条件队列时有哪些处理"></a> 交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？</h3>
      
<ul>
<li><code>mandatory: true</code> 返回消息给生产者。</li>
<li><code>mandatory: false</code> 直接丢弃。</li>
</ul>
<p>对应<a href="#%E5%9B%9E%E9%80%80%E6%B6%88%E6%81%AF">回退消息</a>章节</p>

        <h3 id="死信队列-2"   >
          <a href="#死信队列-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#死信队列-2"></a> 死信队列？</h3>
      
<p>DLX，全称为 Dead-Letter-Exchange，死信交换器，死信邮箱。当消息在一个队列中变成死信 （dead message） 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。</p>

        <h3 id="导致的死信的几种原因"   >
          <a href="#导致的死信的几种原因" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#导致的死信的几种原因"></a> 导致的死信的几种原因？</h3>
      
<ul>
<li>消息被拒（<code>Basic.Reject /Basic.Nack</code>）且 <code>requeue = false</code>。</li>
<li>消息 TTL 过期。</li>
<li>队列满了，无法再添加。</li>
</ul>

        <h3 id="延迟队列-2"   >
          <a href="#延迟队列-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#延迟队列-2"></a> 延迟队列？</h3>
      
<p>存储对应的延迟消息，指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</p>

        <h3 id="优先级队列-2"   >
          <a href="#优先级队列-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优先级队列-2"></a> 优先级队列？</h3>
      
<ul>
<li>优先级高的队列会先被消费。</li>
<li>可以通过 <code>x-max-priority</code> 参数来实现。</li>
<li>当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义</li>
</ul>

        <h3 id="事务机制"   >
          <a href="#事务机制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#事务机制"></a> 事务机制？</h3>
      
<p>RabbitMQ 客户端中与事务机制相关的方法有三个：</p>
<ul>
<li><code>channel.txSelect</code> 用于将当前的信道设置成事务模式。</li>
<li><code>channel.txCommit</code> 用于提交事务。</li>
<li><code>channel.txRollback</code> 用于事务回滚，如果在事务提交执行之前由于 RabbitMQ 异常崩溃或者其他原因抛出异常，通过 <code>txRollback</code> 来回滚。</li>
</ul>

        <h3 id="发送确认机制"   >
          <a href="#发送确认机制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#发送确认机制"></a> 发送确认机制？</h3>
      
<p>生产者把信道设置为 confirm 确认模式，设置后，所有再改信道发布的消息都会被指定一个唯一的 ID，一旦消息被投递到所有匹配的队列之后，RabbitMQ 就会发送一个确认（<code>Basic.Ack</code>） 给生产者（包含消息的唯一 ID），这样生产者就知道消息到达对应的目的地了。</p>

        <h3 id="消费者获取消息的方式"   >
          <a href="#消费者获取消息的方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消费者获取消息的方式"></a> 消费者获取消息的方式？</h3>
      
<ul>
<li>推</li>
<li>拉</li>
</ul>

        <h3 id="消费者某些原因无法处理当前接受的消息如何来拒绝"   >
          <a href="#消费者某些原因无法处理当前接受的消息如何来拒绝" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消费者某些原因无法处理当前接受的消息如何来拒绝"></a> 消费者某些原因无法处理当前接受的消息如何来拒绝？</h3>
      
<ul>
<li><code>channel.basicNack</code></li>
<li><code>channel.basicReject</code></li>
</ul>

        <h3 id="消息传输保证层级"   >
          <a href="#消息传输保证层级" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消息传输保证层级"></a> 消息传输保证层级？</h3>
      
<ul>
<li><code>At most once</code>：最多一次。消息可能会丢失，但不会重复传输。</li>
<li><code>At least once</code>：最少一次。消息绝不会丢失，但可能会重复传输。</li>
<li><code>Exactly once</code>：恰好一次，每条消息肯定仅传输一次。</li>
</ul>

        <h3 id="了解-virtual-host-吗"   >
          <a href="#了解-virtual-host-吗" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#了解-virtual-host-吗"></a> 了解 Virtual Host 吗？</h3>
      
<p>每一个 RabbitMQ 服务器都能创建虚拟的消息服务器，也叫虚拟主机 （virtual host），简称 vhost。默认为 <code>“/”</code>。</p>

        <h3 id="集群中的节点类型"   >
          <a href="#集群中的节点类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#集群中的节点类型"></a> 集群中的节点类型？</h3>
      
<ul>
<li><strong>内存节点</strong>：ram, 将变更写入内存。</li>
<li><strong>磁盘节点</strong>：disc, 磁盘写入操作。</li>
</ul>
<p>RabbitMQ 要求最少有一个磁盘节点。</p>

        <h3 id="队列结构"   >
          <a href="#队列结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#队列结构"></a> 队列结构？</h3>
      
<p>通常由以下两部分组成：</p>
<ul>
<li><code>rabbit_amqqueue_process</code>: 负责协议相关的消息处理，即接收生产者发布的消息、向消费者交付消息、处理消息的确认 （包括生产端的 confirm 和消费端的 ack） 等。</li>
<li><code>backing_queue</code>: 是消息存储的具体形式和引擎，并向 <code>rabbit amqqueue process</code>提供相关的接口以供调用。</li>
</ul>

        <h3 id="rabbitmq-中消息可能有的几种状态"   >
          <a href="#rabbitmq-中消息可能有的几种状态" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-中消息可能有的几种状态"></a> RabbitMQ 中消息可能有的几种状态？</h3>
      
<ul>
<li><code>alpha</code>: 消息内容 （包括消息体、属性和 headers） 和消息索引都存储在内存中 。</li>
<li><code>beta</code>: 消息内容保存在磁盘中，消息索引保存在内存中。</li>
<li><code>gamma</code>: 消息内容保存在磁盘中，消息索引在磁盘和内存中都有 。</li>
<li><code>delta</code>: 消息内容和索引都在磁盘中 。</li>
</ul>

        <h3 id="在何种场景下使用了消息中间件"   >
          <a href="#在何种场景下使用了消息中间件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#在何种场景下使用了消息中间件"></a> 在何种场景下使用了消息中间件？</h3>
      
<ul>
<li>接口之间耦合比较严重，中间加一层消息中间件解耦</li>
<li>面对大流量并发时，容易被冲垮</li>
<li>存在性能问题</li>
</ul>

        <h3 id="生产者如何将消息可靠投递到-mq"   >
          <a href="#生产者如何将消息可靠投递到-mq" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#生产者如何将消息可靠投递到-mq"></a> 生产者如何将消息可靠投递到 MQ？</h3>
      
<ul>
<li>Client 发送消息给 MQ；</li>
<li>MQ 将消息持久化后，发送 Ack 消息给 Client，此处有可能因为网络问题导致 Ack 消息无法发送到 Client，那么 Client 在<strong>等待超时</strong>后，会重传消息；</li>
<li>Client 收到 Ack 消息后，认为消息已经投递成功。</li>
</ul>

        <h3 id="mq-如何将消息可靠投递到消费者"   >
          <a href="#mq-如何将消息可靠投递到消费者" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mq-如何将消息可靠投递到消费者"></a> MQ 如何将消息可靠投递到消费者？</h3>
      
<ul>
<li>MQ 将消息 push 给 Client（或 Client 来 pull 消息）</li>
<li>Client 得到消息并做完业务逻辑</li>
<li>Client 发送 Ack 消息给 MQ，通知 MQ 删除该消息，此处有可能因为网络问题导致 Ack 失败，那么 Client 会重复消费，这里就引出消费幂等的问题；</li>
<li>MQ 将已消费的消息删除</li>
</ul>

        <h3 id="如何保证-rabbitmq-消息队列的高可用"   >
          <a href="#如何保证-rabbitmq-消息队列的高可用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#如何保证-rabbitmq-消息队列的高可用"></a> 如何保证 RabbitMQ 消息队列的高可用？</h3>
      
<p>RabbitMQ 有三种模式：<strong>单机模式</strong>，<strong>普通集群模式</strong>，<strong>镜像集群模式</strong>。</p>
<ul>
<li><strong>单机模式</strong>：就是 demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</li>
<li><strong>普通集群模式</strong>：意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。</li>
<li><strong>镜像集群模式</strong>：这种模式，才是所谓的 RabbitMQ 的高可用模式，跟普通集群模式不一样的是，你创建的 queue，无论元数据 （元数据指 RabbitMQ 的配置数据） 还是 queue 里的消息都会存在于多个实例上，然后每次你写消息到 queue 的时候，都会自动把消息到多个实例的 queue 里进行消息同步。</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://yuyun-zhao.gitee.io">yuyun zhao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://yuyun-zhao.gitee.io/2021/08/31/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/">http://yuyun-zhao.gitee.io/2021/08/31/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.gitee.io/tags/RabbitMQ/">RabbitMQ</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.gitee.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/09/04/%E3%80%90SpringCloud%E3%80%91Config/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">【Spring Cloud】Spring Cloud Config &amp; Bus</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/08/30/%E3%80%90SpringCloud%E3%80%91Gateway/"><span class="paginator-prev__text">【Spring Cloud】Spring Cloud Gateway</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#mq-%E7%AE%80%E4%BB%8B"><span class="toc-text">
           MQ 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-mq"><span class="toc-text">
           什么是 MQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-mq"><span class="toc-text">
           为什么要用 MQ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%B6%88%E5%B3%B0"><span class="toc-text">
           流量消峰</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6"><span class="toc-text">
           应用解耦</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="toc-text">
           异步处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mq-%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">
           MQ 的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#activemq"><span class="toc-text">
           ActiveMQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kafka"><span class="toc-text">
           Kafka</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rocketmq"><span class="toc-text">
           RocketMQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rabbitmq"><span class="toc-text">
           RabbitMQ</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mq-%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">
           MQ 的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kafka-2"><span class="toc-text">
           Kafka</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rocketmq-2"><span class="toc-text">
           RocketMQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rabbitmq-2"><span class="toc-text">
           RabbitMQ</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rabbitmq-%E7%AE%80%E4%BB%8B"><span class="toc-text">
           RabbitMQ 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rabbitmq-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">
           RabbitMQ 的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">
           四大核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rabbitmq-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">
           RabbitMQ 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">
           工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-rabbitmq"><span class="toc-text">
           安装 RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rabbitmq-%E7%AB%AF%E5%8F%A3"><span class="toc-text">
           RabbitMQ 端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">
           常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%8F%8A%E6%8E%88%E6%9D%83%E6%93%8D%E4%BD%9C"><span class="toc-text">
           Web 管理界面及授权操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-%E5%BA%94%E7%94%A8%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">
           Web 应用相关命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rabbitmq-hello-world"><span class="toc-text">
           RabbitMQ Hello World</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%8F%96%E5%80%BC%E5%88%86%E5%8F%91"><span class="toc-text">
           预取值分发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E7%9A%84%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91"><span class="toc-text">
           带权的消息分发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94"><span class="toc-text">
           消息应答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94"><span class="toc-text">
           自动应答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94"><span class="toc-text">
           手动消息应答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%87%8D%E6%96%B0%E5%85%A5%E9%98%9F"><span class="toc-text">
           消息重新入队</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">
           消息&#x2F;队列持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">
           队列持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">
           消息持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4"><span class="toc-text">
           发布确认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83%E7%AD%96%E7%95%A5"><span class="toc-text">
           单个确认发布策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83%E7%AD%96%E7%95%A5"><span class="toc-text">
           批量确认发布策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83%E7%AD%96%E7%95%A5"><span class="toc-text">
           异步确认发布策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA-exchanges"><span class="toc-text">
           交换机 Exchanges</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%A2%98-topic-%E7%B1%BB%E5%9E%8B"><span class="toc-text">
           主题 Topic 类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-text">
           死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">
           死信的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="toc-text">
           死信的来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E5%AE%9E%E6%88%98"><span class="toc-text">
           死信实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E4%B9%8B-%E6%B6%88%E6%81%AF-ttl-%E8%BF%87%E6%9C%9F-%E6%83%85%E5%86%B5"><span class="toc-text">
           死信之 “消息 TTL 过期” 情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E4%B9%8B-%E9%98%9F%E5%88%97%E8%BE%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6-%E6%83%85%E5%86%B5"><span class="toc-text">
           死信之 “队列达到最大长度” 情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E4%B9%8B-%E6%B6%88%E6%81%AF%E8%A2%AB%E6%8B%92-%E6%83%85%E5%86%B5"><span class="toc-text">
           死信之 “消息被拒” 情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-text">
           延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%A6%82%E5%BF%B5"><span class="toc-text">
           延迟队列概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rabbitmq-%E4%B8%AD%E7%9A%84-ttl"><span class="toc-text">
           RabbitMQ 中的 TTL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-boot-%E6%95%B4%E5%90%88-rabbitmq"><span class="toc-text">
           Spring Boot 整合 RabbitMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E5%9C%BA%E6%99%AF"><span class="toc-text">
           延迟队列场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97-ttl-%E4%BC%98%E5%8C%96"><span class="toc-text">
           延时队列 TTL 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rabbitmq-%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-text">
           RabbitMQ 插件实现延迟队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">
           总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E9%AB%98%E7%BA%A7"><span class="toc-text">
           发布确认高级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%80%80%E6%B6%88%E6%81%AF"><span class="toc-text">
           回退消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-text">
           备份交换机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-text">
           幂等性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">
           概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-text">
           消息重复消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-text">
           解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E4%BF%9D%E9%9A%9C"><span class="toc-text">
           消费端的幂等性保障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80-id-%E6%8C%87%E7%BA%B9%E7%A0%81%E6%9C%BA%E5%88%B6"><span class="toc-text">
           唯一 ID + 指纹码机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#note-redis-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">
           note Redis 原子性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-text">
           优先级队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">
           使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">
           实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-text">
           惰性队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-text">
           使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-text">
           两种模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rabbitmq-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2"><span class="toc-text">
           RabbitMQ 集群部署</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#federation-exchange"><span class="toc-text">
           Federation Exchange</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shovel"><span class="toc-text">
           Shovel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-text">
           搭建步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rabbitmq-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">
           RabbitMQ 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rabbitmq-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">
           RabbitMQ 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rabbitmq-%E7%89%B9%E7%82%B9"><span class="toc-text">
           RabbitMQ 特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amqp-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">
           AMQP 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amqp-%E5%8D%8F%E8%AE%AE-3-%E5%B1%82"><span class="toc-text">
           AMQP 协议 3 层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amqp-%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%87%A0%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">
           AMQP 模型的几大组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%94%9F%E4%BA%A7%E8%80%85-producer-%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85-consumer"><span class="toc-text">
           说说生产者 Producer 和消费者 Consumer?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">
           为什么需要消息队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-broker-%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9-queue-%E9%98%9F%E5%88%97-exchange-%E4%BA%A4%E6%8D%A2%E5%99%A8"><span class="toc-text">
           说说 Broker 服务节点、Queue 队列、Exchange 交换器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">
           消息队列有什么优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">
           如何保证消息的可靠性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-routingkey-%E8%B7%AF%E7%94%B1%E9%94%AE"><span class="toc-text">
           什么是 RoutingKey 路由键？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binding-%E7%BB%91%E5%AE%9A"><span class="toc-text">
           Binding 绑定？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%99%A8-4-%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-text">
           交换器 4 种类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E8%BF%90%E8%BD%AC"><span class="toc-text">
           生产者消息运转？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%E8%BF%87%E7%A8%8B"><span class="toc-text">
           消费者接收消息过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%99%A8%E6%97%A0%E6%B3%95%E6%A0%B9%E6%8D%AE%E8%87%AA%E8%BA%AB%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%B7%AF%E7%94%B1%E9%94%AE%E6%89%BE%E5%88%B0%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%84%E7%90%86"><span class="toc-text">
           交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97-2"><span class="toc-text">
           死信队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8E%9F%E5%9B%A0"><span class="toc-text">
           导致的死信的几种原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97-2"><span class="toc-text">
           延迟队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-2"><span class="toc-text">
           优先级队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6"><span class="toc-text">
           事务机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">
           发送确认机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E8%8E%B7%E5%8F%96%E6%B6%88%E6%81%AF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">
           消费者获取消息的方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%9F%90%E4%BA%9B%E5%8E%9F%E5%9B%A0%E6%97%A0%E6%B3%95%E5%A4%84%E7%90%86%E5%BD%93%E5%89%8D%E6%8E%A5%E5%8F%97%E7%9A%84%E6%B6%88%E6%81%AF%E5%A6%82%E4%BD%95%E6%9D%A5%E6%8B%92%E7%BB%9D"><span class="toc-text">
           消费者某些原因无法处理当前接受的消息如何来拒绝？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E8%BE%93%E4%BF%9D%E8%AF%81%E5%B1%82%E7%BA%A7"><span class="toc-text">
           消息传输保证层级？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3-virtual-host-%E5%90%97"><span class="toc-text">
           了解 Virtual Host 吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-text">
           集群中的节点类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84"><span class="toc-text">
           队列结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rabbitmq-%E4%B8%AD%E6%B6%88%E6%81%AF%E5%8F%AF%E8%83%BD%E6%9C%89%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-text">
           RabbitMQ 中消息可能有的几种状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BD%95%E7%A7%8D%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%E4%BA%86%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">
           在何种场景下使用了消息中间件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%A6%82%E4%BD%95%E5%B0%86%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%8A%95%E9%80%92%E5%88%B0-mq"><span class="toc-text">
           生产者如何将消息可靠投递到 MQ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mq-%E5%A6%82%E4%BD%95%E5%B0%86%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%8A%95%E9%80%92%E5%88%B0%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">
           MQ 如何将消息可靠投递到消费者？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-rabbitmq-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-text">
           如何保证 RabbitMQ 消息队列的高可用？</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/author.png" alt="avatar"></div><p class="sidebar-ov-author__text">no code no life</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YUYUN-ZHAO" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="zyy1024462136" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1024462136" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:im.yuyunzhao@gmail.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gmail</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">92</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">33</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">33</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>yuyun zhao</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.xml"></script></body></html>