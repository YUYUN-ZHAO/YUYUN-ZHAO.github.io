<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/Q%E7%89%88%E5%A4%B4%E5%83%8F32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="MQ 简介                             什么是 MQ        MQ (message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦 + 物理解耦” 的消">
<meta property="og:type" content="article">
<meta property="og:title" content="【RabbitMQ】RabbitMQ">
<meta property="og:url" content="http://yuyun-zhao.gitee.io/2021/08/31/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/index.html">
<meta property="og:site_name" content="yuyun zhao&#39;s blog">
<meta property="og:description" content="MQ 简介                             什么是 MQ        MQ (message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦 + 物理解耦” 的消">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831143417355.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831215725573.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831215804163.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831220251162.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831220420923.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903203642528.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903205627257.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204201626.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204307310.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204350479.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204919165.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204940385.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903205243652.png">
<meta property="og:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903210632247.png">
<meta property="article:published_time" content="2021-08-31T06:30:18.000Z">
<meta property="article:modified_time" content="2021-09-03T13:30:24.248Z">
<meta property="article:author" content="yuyun zhao">
<meta property="article:tag" content="RabbitMQ">
<meta property="article:tag" content="中间件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yuyun-zhao.gitee.io/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831143417355.png"><title>【RabbitMQ】RabbitMQ | yuyun zhao's blog</title><link ref="canonical" href="http://yuyun-zhao.gitee.io/2021/08/31/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">文章</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">yuyun zhao's blog</div><div class="header-banner-info__subtitle">no code no life</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">【RabbitMQ】RabbitMQ</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-08-31</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-03</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">9.5k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">56分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831143417355.png" alt="image-20210831143417355" /></p>

        <h2 id="mq-简介"   >
          <a href="#mq-简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mq-简介"></a> MQ 简介</h2>
      

        <h3 id="什么是-mq"   >
          <a href="#什么是-mq" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#什么是-mq"></a> 什么是 MQ</h3>
      
<p>MQ (message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦 + 物理解耦” 的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务，由MQ将消息发送给下游消费者。</p>

        <h3 id="为什么要用-mq"   >
          <a href="#为什么要用-mq" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#为什么要用-mq"></a> 为什么要用 MQ</h3>
      

        <h4 id="流量消峰"   >
          <a href="#流量消峰" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#流量消峰"></a> 流量消峰</h4>
      
<p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p>

        <h4 id="应用解耦"   >
          <a href="#应用解耦" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#应用解耦"></a> 应用解耦</h4>
      
<p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831215725573.png" alt="image-20210831215725573" /></p>

        <h4 id="异步处理"   >
          <a href="#异步处理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#异步处理"></a> 异步处理</h4>
      
<p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。</p>
<p>以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。</p>
<p>使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作，A 服务还能及时的得到异步处理成功的消息。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831215804163.png" alt="image-20210831215804163" /></p>
<span id="more"></span>

        <h3 id="mq-的分类"   >
          <a href="#mq-的分类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mq-的分类"></a> MQ 的分类</h3>
      

        <h4 id="activemq"   >
          <a href="#activemq" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#activemq"></a> ActiveMQ</h4>
      
<ul>
<li>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，较低的概率丢失数据。</li>
<li>缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</li>
</ul>

        <h4 id="kafka"   >
          <a href="#kafka" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#kafka"></a> Kafka</h4>
      
<p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<strong>大数据</strong>而生的消息中间件，以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p>
<ul>
<li>优点：性能卓越，单机写入 TPS 约在百万条 / 秒，<strong>最大的优点，就是吞吐量高</strong>。时效性 ms 级，可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用，消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次；有优秀的第三方 Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。</li>
<li>缺点：Kafka 单机超过 64 个队列 / 分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，<strong>社区更新较慢</strong>。</li>
</ul>

        <h4 id="rocketmq"   >
          <a href="#rocketmq" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rocketmq"></a> RocketMQ</h4>
      
<p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p>
<ul>
<li>优点：<strong>单机吞吐量十万级</strong>，可用性非常高，分布式架构，消息可以做到 0 丢失，MQ 功能较为完善，还是分布式的，扩展性好，支持 10 亿级别的消息堆积，不会因为堆积导致性能下降。</li>
<li>缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟；社区活跃度一般，没有在 MQ 核心中去实现 JMS 等接口，有些系统要迁移需要修改大量代码。</li>
</ul>

        <h4 id="rabbitmq"   >
          <a href="#rabbitmq" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq"></a> RabbitMQ</h4>
      
<p>2007 年发布，是一个在 AMQP (高级消息队列协议) 基础上完成的，可复用的企业消息系统，<strong>是当前最主流的消息中间件之一</strong>。</p>
<ul>
<li>优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备，健壮、稳定、易用、跨平台、支持多种语言。如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用，社区活跃度高；更新频率相当高。</li>
<li>缺点：商业版需要收费，学习成本较高。</li>
</ul>

        <h3 id="mq-的选择"   >
          <a href="#mq-的选择" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mq-的选择"></a> MQ 的选择</h3>
      

        <h4 id="kafka-2"   >
          <a href="#kafka-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#kafka-2"></a> Kafka</h4>
      
<p>Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能，肯定是首选 kafka 了。</p>

        <h4 id="rocketmq-2"   >
          <a href="#rocketmq-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rocketmq-2"></a> RocketMQ</h4>
      
<p>天生为<strong>金融互联网</strong>领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p>

        <h4 id="rabbitmq-2"   >
          <a href="#rabbitmq-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-2"></a> RabbitMQ</h4>
      
<p>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分方便，如果你的<strong>数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ。</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhangc233.github.io/2021/07/23/RabbitMQ/" >https://zhangc233.github.io/2021/07/23/RabbitMQ/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h2 id="rabbitmq-简介"   >
          <a href="#rabbitmq-简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-简介"></a> RabbitMQ 简介</h2>
      

        <h3 id="rabbitmq-的概念"   >
          <a href="#rabbitmq-的概念" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-的概念"></a> RabbitMQ 的概念</h3>
      
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhangc233.github.io/2021/07/23/RabbitMQ/" >https://zhangc233.github.io/2021/07/23/RabbitMQ/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>RabbitMQ是一个<strong>异步消息</strong>通信中间件，用erlang语言开发，实现了AMQP（Advanced Message Queue ）协议，是一个开源产品，官方网站：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.rabbitmq.com/" >http://www.rabbitmq.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>RabbitMQ 是一个消息中间件，它<strong>接受并转发</strong>消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。</p>
<p>但RabbitMQ 与快递站的主要区别在于，<strong>它不处理快件，而是接收，存储和转发消息数据</strong>。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831220251162.png" alt="image-20210831220251162" /></p>

        <h3 id="四大核心概念"   >
          <a href="#四大核心概念" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#四大核心概念"></a> 四大核心概念</h3>
      
<ul>
<li><strong>生产者</strong>：产生数据发送消息的程序。</li>
<li><strong>交换机</strong>：是 RabbitMQ 非常重要的一个部件，<strong>一方面它接收来自生产者的消息，另一方面它将消息推送到队列中</strong>。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定。</li>
<li><strong>队列</strong>：队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。</li>
<li><strong>消费者</strong>：大多时候是一个等待接收消息的程序。请注意<strong>生产者，消费者和消息中间件很多时候并不在同一机器上</strong>。同一个应用程序既可以是生产者又是可以是消费者。</li>
</ul>
<p><strong>四者关系</strong>：</p>
<ul>
<li><strong>生产者只将消息发给交换机</strong>，至于该交换机将消息发送给了哪个队列其是不知道的（通常将绑定的工作放到Spring的<code>@Configuration</code>配置类里，从而与生产者解耦，生产者本身并不知道绑定信息）</li>
<li><strong>消费者只从队列获取消息</strong>，至于该消息来自哪个交换机其是不知道的</li>
<li>交换机和队列是有对应的绑定关系的，通常在Spring的<code>@Configuration</code>配置类里进行配置，生产者和消费者对此并不知情，也无需知道，</li>
</ul>

        <h3 id="rabbitmq-工作原理"   >
          <a href="#rabbitmq-工作原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-工作原理"></a> RabbitMQ 工作原理</h3>
      
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210831220420923.png" alt="image-20210831220420923" /></p>
<ul>
<li><strong>Broker</strong>：<strong>接收</strong>和<strong>分发</strong>消息的应用，就是 RabbitMQ 服务器。</li>
<li><strong>Virtual host</strong>：出于多用户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等。</li>
<li><strong>Connection</strong>：publisher／consumer 和 broker 之间的 TCP 连接。</li>
<li><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</strong>。</li>
<li><strong>Exchange</strong>：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 <code>routing key</code>，分发消息到 queue 中去。常用的类型有：<code>direct (point-to-point)</code>，<code>topic (publish-subscribe)</code> and <code>fanout (multicast)</code>。</li>
<li><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走。</li>
<li><strong>Binding</strong>：exchange 和 queue 之间的虚拟连接，binding 中可以包含 <code>routing key</code>，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</li>
</ul>
<p>其中，交换机和队列存储在 RabbitMQ 服务器内，生产者和消费者在其他服务器，二者通过声明的方式在 RabbitMQ 服务器内创建相应的交换机和队列。</p>

        <h3 id="工作流程"   >
          <a href="#工作流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h3>
      
<p><strong>生产者工作流程</strong>：</p>
<ol>
<li>生产者建立与 RabbitMQ 服务器的 Connection 连接并创建一个 Channel 与其通讯</li>
<li>生产者声明若干交换机与队列，声明后，RabbitMQ 服务器中将创建这些交换机与队列（<code>queueDeclare()</code>）</li>
<li>生产者绑定交换机与队列，即指定交换机与队列间的<code>routing key</code>与映射类型（<code>queueBind()</code>）</li>
<li>生产者向 RabbitMQ 服务器发送消息（<code>basicPublish()</code>）</li>
<li>生产者可以设置通道为<a href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4">发布确认</a>模式 （<code>confirmSelect()</code>），这样 RabbitMQ 服务器在收到生产者发送的数据后会回调通知生产者，生产者异步地接收这些回调消息，从而得知当前消息是否被成功发布，若 RabbitMQ 服务器宕机生产者也可以即使得知，避免消息丢失</li>
</ol>
<p><strong>消费者工作流程</strong>：</p>
<ol>
<li>消费者建立与 RabbitMQ 服务器的 Connection 连接并创建一个 Channel 与其通讯</li>
<li>消费者指定监听哪个队列（<code>basicConsume()</code>），并设置接收消息成功/失败的回调方法（<code>Callback</code>）</li>
<li>消费者接收到消息后进行<a href="#%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94">消息应答</a>（<code>basicAck()</code>）：通知 RabbitMQ 服务器该消息已经成功接受，此时才将该消息从队列中删除</li>
<li>消费者可以设置<a href="#%E9%A2%84%E5%8F%96%E5%80%BC%E5%88%86%E5%8F%91">预期值分发</a>（<code>basicQos()</code>），一次性从队列中获取多条消息进行异步消费</li>
</ol>
<p><strong>RabbitMQ 服务器工作流程</strong>：</p>
<p><strong>RabbitMQ 服务器工作流程</strong>：</p>
<ol>
<li>与 RabbitMQ 客户端（生产者与消费者）建立TCP连接</li>
<li>创建生产者与消费者声明的交换机与队列，并根据<code>routing key</code>与映射类型将其进行绑定</li>
<li>当交换机收到生产者发来的消息时，将此消息按照<code>routing key</code>分发到对应的队列中</li>
<li>队列中的消息将逐个转发到对应的消费者。注意，<strong>一个消息只能被消费一次</strong>。这个队列所对应的N个消费者将按照某种规则（例如轮询）消费该消息。例如该队列中共有4条消息，有两个消费者监听该队列，那么这两个消费者将分别消费2条消息</li>
<li>当 RabbitMQ 服务器接收到消费者传来的消息应答后，若消费者确认收到消息（<code>basicAck ()</code>），则将该消息从队列中删除；若消费者拒绝收到消息（<code>basicReject ()</code>），同样将其从队列中删除；若消费者长时间未回复消息应答，则将该<a href="#%E6%B6%88%E6%81%AF%E9%87%8D%E6%96%B0%E5%85%A5%E9%98%9F">消息重新入队</a></li>
<li>若 RabbitMQ 服务器判断得知某条消息成为死信（例如消息被拒绝、消息到期或队列达到最大长度），则将其路由到对应的<a href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97">死信队列</a>，死信队列里的消息将由监听其的消费者消费</li>
<li>发送到<a href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97">延迟队列</a>里面的消息在阻塞一定时间后才会被放到死信队列里被消费者执行</li>
</ol>

        <h2 id="安装-rabbitmq"   >
          <a href="#安装-rabbitmq" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#安装-rabbitmq"></a> 安装 RabbitMQ</h2>
      
<blockquote>
<p>Linux上安装过程见<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://yuyun-zhao.github.io/documents/linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.pdf" >Linux 开发环境配置文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h3 id="常用命令"   >
          <a href="#常用命令" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h3>
      
<figure class="highlight sh"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl status rabbitmq-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> rabbitmq-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></div></figure>

        <h3 id="web-管理界面及授权操作"   >
          <a href="#web-管理界面及授权操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#web-管理界面及授权操作"></a> Web 管理界面及授权操作</h3>
      
<ol>
<li>安装：</li>
</ol>
<figure class="highlight sh"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>安装完毕以后，重启服务：</li>
</ol>
<figure class="highlight sh"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></div></figure>
<ol start="3">
<li>访问 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://xxx.xxx.xxx.xxx:15672" >http://xxx.xxx.xxx.xxx:15672</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ，用默认账号密码 (guest) 登录，出现权限问题，需要添加一个远程登录的用户：</li>
</ol>
<figure class="highlight sh"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建账号和密码</span></span><br><span class="line">rabbitmqctl add_user admin 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置用户角色</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为用户添加资源权限  添加配置、写、读权限</span></span><br><span class="line"><span class="comment"># set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span></span><br><span class="line">rabbitmqctl set_permissions -p <span class="string">&quot;/&quot;</span> admin <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span><br></pre></td></tr></table></div></figure>
<p>用户级别：</p>
<ul>
<li><strong>administrator</strong>：可以登录控制台、查看所有信息、可以对 rabbitmq 进行管理。</li>
<li><strong>monitoring</strong>：监控者 登录控制台，查看所有信息。</li>
<li><strong>policymaker</strong>：策略制定者 登录控制台，指定策略。</li>
<li><strong>managment</strong>：普通管理员 登录控制台。</li>
</ul>

        <h3 id="web-应用相关命令"   >
          <a href="#web-应用相关命令" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#web-应用相关命令"></a> Web 应用相关命令</h3>
      
<ul>
<li>关闭Web应用的命令为：<code>rabbitmqctl stop_app</code></li>
<li>清除的命令为：<code>rabbitmqctl reset</code></li>
<li>重新启动命令为：<code>rabbitmqctl start_app</code></li>
</ul>

        <h2 id="rabbitmq-hello-world"   >
          <a href="#rabbitmq-hello-world" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rabbitmq-hello-world"></a> RabbitMQ Hello World</h2>
      
<p>导入相关Maven依赖：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--rabbitmq 依赖客户端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--操作文件流的一个依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
<p>生产者：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;queue-01&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;exchange-01&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;42.192.149.71&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 获取信道：channel 实现了自动 close 接口，不需要手动关闭</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明一个交换机并指定类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化：是否用完就删除该消息，true：需要持久化</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者进行消费：是否是独家的，false：不是独家的，可以多个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除：最后一个消费者断开连接以后，该队列是否自动删除，true：自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数，例如配置死信交换机key等参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将队列和交换机进行绑定，并指定 routing key 为 &quot;info&quot;，这样发布消息时将根据 &quot;info&quot; 找到对应的队列</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消息</span></span><br><span class="line"><span class="comment">         * 1.发送到那个交换机</span></span><br><span class="line"><span class="comment">         * 2.发送的交换机要路由到队列的routing-key，交换机将使用该值找到对应的队列，若该队列不存在将抛异常</span></span><br><span class="line"><span class="comment">         * 3.其他的参数信息，例如设置消息的优先级或到期时间expiration</span></span><br><span class="line"><span class="comment">         * 4.发送消息的消息体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,  <span class="string">&quot;info&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>生产者声明了交换机和队列并进行绑定（设置<code>routingKey</code>为<code>&quot;info&quot;</code>），二者将由 RabbitMQ 服务器创建并维护。生产者将消息发往指定的交换机后，RabbitMQ 服务器将根据传入的<code>routingKey</code>找到对应的队列，将消息放入其中，等待消费者消费该队列中的消息。</p>
<p>消费者：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;queue-01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;42.192.149.71&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预取值分发，当前消费者能同时异步地消费6条消息</span></span><br><span class="line">        <span class="keyword">int</span> prefetchCount = <span class="number">6</span>;</span><br><span class="line">        channel.basicQos(prefetchCount);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.........&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者成功消费的回调：处理队列中传来的消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取消息内容</span></span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息:&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消息应答：手动回复 RabbitMQ 服务器已收到消息，可以从队列中删除</span></span><br><span class="line">            <span class="comment">// 获取到当前的消息编号Tag，只应答其自己，不批量应答</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者取消消费的回调：如在消费的时候队列被删除掉了</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者消费消息 - 接受消息</span></span><br><span class="line"><span class="comment">         * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">         * 2.消费成功之后是否要自动应答：true代表自动应答，false代表手动应答</span></span><br><span class="line"><span class="comment">         * 3.消费者成功消费的回调</span></span><br><span class="line"><span class="comment">         * 4.消费者取消消费的回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>消费者将根据队列名从 RabbitMQ 服务器找到对应的队列，从中获取消息，设置了预取值分发则会同时异步地消费多条消息。</p>

        <h2 id="预取值分发"   >
          <a href="#预取值分发" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#预取值分发"></a> 预取值分发</h2>
      
<p><strong>一个消息只能被消费一次</strong>。</p>
<p>默认情况下，消费者采用<strong>轮询</strong>的方式进行消费：例如某队列中共有4条消息，有两个消费者监听该队列，那么这两个消费者将进行轮询消费，各自消费2条消息：</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903203642528.png" alt="image-20210903203642528" /></p>
<p>但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮询分发的话，处理速度快的消费者很大一部分时间处于空闲状态（在等待另一个消费者消费完自己才能消费下一个消息），而处理慢的那个消费者一直在干活，此时轮询分配方式就不太好。</p>
<p>为了避免这种情况，在消费者中消费之前，可以为每个消费者设置<strong>预取值分发</strong>，即预先取出一部分数量的消息进行消费。设置方法为：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预取值分发，当前消费者能同时异步地消费6条消息</span></span><br><span class="line"><span class="keyword">int</span> prefetchCount = <span class="number">6</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></div></figure>
<p>通俗来讲，如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，然后 RabbitMQ 就会把该任务分配给没有那么忙的那个空闲消费者。这样就可以根据服务器性能的不同事先设置好<code>prefetchCount</code>的值。</p>
<p>当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。</p>

        <h3 id="带权的消息分发"   >
          <a href="#带权的消息分发" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#带权的消息分发"></a> 带权的消息分发</h3>
      
<p>本身消息的发送就是<strong>异步</strong>发送的，所以在任何时候，channel 上肯定不止只有一个消息，另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过使用 basic.qos 方法设 置 “预取计数” 值来完成的。</p>
<p>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。</p>
<p>通常，增加预取值将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>。应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p>
<p>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903205627257.png" alt="image-20210903205627257" /></p>

        <h2 id="消息应答"   >
          <a href="#消息应答" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消息应答"></a> 消息应答</h2>
      
<blockquote>
<p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况？</p>
</blockquote>
<p>假设 RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息以及后续发送给该消费者的消息，因为它无法接收到。</p>
<p>为了保证消息在发送过程中不丢失，引入<strong>消息应答机制：消费者在接收到消息并且处理该消息之后，告诉 RabbitMQ 它已经处理完成了，RabbitMQ 服务器可以从队列中将该消息删除了。</strong></p>

        <h3 id="自动应答"   >
          <a href="#自动应答" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#自动应答"></a> 自动应答</h3>
      
<p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>，因为这种模式如果消息在接收到之前，消费者那边出现连接或者 Channel 关闭，那么消息就丢失了。当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</p>

        <h3 id="手动消息应答"   >
          <a href="#手动消息应答" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#手动消息应答"></a> 手动消息应答</h3>
      
<p>手动应答的好处是可以<strong>批量应答</strong>并且减少网络拥堵 ，其分为以下三类：</p>
<ul>
<li><code>Channel.basicAck</code> (用于肯定确认)：RabbitMQ 已知道该消息成功被处理，可以将其丢弃了。</li>
<li><code>Channel.basicNack</code> (用于否定确认)</li>
<li><code>Channel.basicReject</code> (用于否定确认)：与 <code>Channel.basicNack</code> 相比少一个参数，不处理该消息了，直接拒绝，可以将其丢弃了。</li>
</ul>
<p><strong>Multiple</strong> 的解释：</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204201626.png" alt="image-20210903204201626" /></p>
<ul>
<li>true 代表批量应答 channel 上未应答的消息：比如说 channel 上有传送 tag 的消息 5、6、7、8， 当前 tag 是 8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答。</li>
<li>false 同上面相比只会应答 tag=8 的消息， 5、6、7 这三个消息依然不会被确认收到消息应答。</li>
</ul>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204307310.png" alt="image-20210903204307310" /></p>
<p>消费者设置消息手动应答：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取消息内容</span></span><br><span class="line">    String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息:&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息应答：手动回复 RabbitMQ 服务器已收到消息，可以从队列中删除</span></span><br><span class="line">    <span class="comment">// 获取到当前的消息编号Tag，只应答其自己，不批量应答</span></span><br><span class="line">    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, deliverCallback, cancelCallback);</span><br></pre></td></tr></table></div></figure>

        <h3 id="消息重新入队"   >
          <a href="#消息重新入队" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消息重新入队"></a> 消息重新入队</h3>
      
<p>如果消费者由于某些原因失去连接 (其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204350479.png" alt="image-20210903204350479" /></p>
<p>测试消息重新入队：</p>
<p>正常情况下消息发送方发送两个消息，C1 和 C2 分别接收到消息并进行处理。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204919165.png" alt="image-20210903204919165" /></p>
<p>在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了，此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903204940385.png" alt="image-20210903204940385" /></p>

        <h2 id="消息队列持久化"   >
          <a href="#消息队列持久化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消息队列持久化"></a> 消息/队列持久化</h2>
      
<p>当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需要将队列和消息都标记为持久化。</p>

        <h3 id="队列持久化"   >
          <a href="#队列持久化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#队列持久化"></a> 队列持久化</h3>
      
<p>之前创建的队列都是非持久化的，RabbitMQ 如果重启的话，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 <code>durable</code> 参数设置为持久化。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让队列持久化</span></span><br><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 声明队列</span></span><br><span class="line">channel.queueDeclare(QUEUE_NAME, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></div></figure>
<p>注意：如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误。</p>

        <h3 id="消息持久化"   >
          <a href="#消息持久化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#消息持久化"></a> 消息持久化</h3>
      
<p>消息实现持久化需要在消息<strong>生产者</strong>修改代码，<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code> 添加这个属性。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903205243652.png" alt="image-20210903205243652" /></p>
<p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候但是还没有存储完，消息还在缓存的一个间隔点。此时并没有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p>

        <h2 id="发布确认"   >
          <a href="#发布确认" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#发布确认"></a> 发布确认</h2>
      
<p><strong>发布确认是为了确保生产者发送的消息能够被 RabbitMQ 服务器接收到，若 RabbitMQ 服务器宕机无法接收消息，则生产者能及时察觉到，从而重新发送消息，防止消息丢失时生产者无法察觉。</strong></p>
<p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID (从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者 (包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p>
<p>confirm 模式最大的好处在于它是<strong>异步</strong>的，<strong>一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息</strong>，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p>
<p>开启发布确认的方法：发布确认默认是没有开启的，如果要开启，需要调用方法 <code>confirmSelect()</code>：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></div></figure>

        <h3 id="单个确认发布策略"   >
          <a href="#单个确认发布策略" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#单个确认发布策略"></a> 单个确认发布策略</h3>
      
<p>这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，<strong>也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布</strong>，<code>waitForConfirmsOrDie(long)</code> 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p>
<p>这种确认方式有一个最大的缺点就是：<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p>
<p>此模式下，生产者将等待服务端返回确认消息程序才会继续执行，若服务端返回 false 或超时时间内未返回，则生产者可以消息重发。生产者端配置方式：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">    String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务端返回 false 或超时时间内未返回，生产者可以消息重发</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = channel.waitForConfirms();</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="批量确认发布策略"   >
          <a href="#批量确认发布策略" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#批量确认发布策略"></a> 批量确认发布策略</h3>
      
<p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">    <span class="comment">//队列声明</span></span><br><span class="line">    String queueName = UUID.randomUUID().toString();</span><br><span class="line">    channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="comment">//批量确认消息大小</span></span><br><span class="line">    <span class="keyword">int</span> batchSize = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//未确认消息个数</span></span><br><span class="line">    <span class="keyword">int</span> outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        outstandingMessageCount++;</span><br><span class="line">        <span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">            channel.waitForConfirms();</span><br><span class="line">            outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为了确保还有剩余没有确认消息 再次确认</span></span><br><span class="line">    <span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        channel.waitForConfirms();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个批量确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="异步确认发布策略"   >
          <a href="#异步确认发布策略" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#异步确认发布策略"></a> 异步确认发布策略</h3>
      
<p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都很高， 它是利用<strong>回调函数</strong>来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功。</p>
<p><img src="/images/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/image-20210903210632247.png" alt="image-20210903210632247" /></p>
<p>如何处理异步未确认消息？最好的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel())</span><br><span class="line">    &#123;</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程安全有序的一个哈希表，适用于高并发的情况</span></span><br><span class="line"><span class="comment">         * 1.轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">         * 2.轻松批量删除条目 只要给到序列号</span></span><br><span class="line"><span class="comment">         * 3.支持并发访问</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class="keyword">new</span></span><br><span class="line">            ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 确认收到消息的一个回调</span></span><br><span class="line"><span class="comment">         * 1.sequenceNumber：消息序列号</span></span><br><span class="line"><span class="comment">         * 2.multiple：批量消息应答，true 可以确认小于等于当前序列号的消息，false 确认当前序列号消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConfirmCallback ackCallback = (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                <span class="comment">// 返回的是小于等于当前序列号的未确认消息 是一个 Map，其是原 Map 的一个浅拷贝，修改其即可修改原 Map</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; confirmed =</span><br><span class="line">                    outstandingConfirms.headMap(sequenceNumber, <span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// 清除该部分未确认消息</span></span><br><span class="line">                confirmed.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//只清除当前序列号的消息</span></span><br><span class="line">                outstandingConfirms.remove(sequenceNumber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        ConfirmCallback nackCallback = (sequenceNumber, multiple) -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            String message = outstandingConfirms.get(sequenceNumber);</span><br><span class="line">            System.out.println(<span class="string">&quot;发布的消息&quot;</span>+message+<span class="string">&quot;未被确认，序列号&quot;</span>+sequenceNumber);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加一个异步确认的监听器</span></span><br><span class="line"><span class="comment">         * 1.确认收到消息的回调</span></span><br><span class="line"><span class="comment">         * 2.未收到消息的回调 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.addConfirmListener(ackCallback, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 发布多条消息，将这些消息的信息同样保存到outstandingConfirms中，其可以在其他线程安全访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            String message = <span class="string">&quot;消息&quot;</span> + i;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">        	* channel.getNextPublishSeqNo()获取下一个消息的序列号</span></span><br><span class="line"><span class="comment">        	* 通过序列号与消息体进行一个关联</span></span><br><span class="line"><span class="comment">        	* 全部都是未确认的消息体</span></span><br><span class="line"><span class="comment">         	*/</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cb4y1o7zz?p=77" >https://www.bilibili.com/video/BV1cb4y1o7zz?p=77</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>以上 3 种发布策略确认速度对比：</p>
<ul>
<li><strong>单独发布消息</strong>：同步等待确认，简单，但吞吐量非常有限</li>
<li><strong>批量发布消息</strong>：批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是哪条消息出现了问题</li>
<li><strong>异步处理</strong>：最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</li>
</ul>

        <h2 id="交换机-exchanges"   >
          <a href="#交换机-exchanges" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#交换机-exchanges"></a> 交换机 Exchanges</h2>
      
<p>RabbitMQ 消息传递模型的核心思想是：生产者生产的消息从不会直接发送到队列。实际上，<strong>通常生产者甚至都不知道这些消息传递传递到了哪些队列中</strong>。</p>
<ul>
<li>生产者只将消息发给交换机，至于该交换机将消息发送给了哪个队列其是不知道的（通常将绑定的工作放到Spring的<code>@Configuration</code>配置类里，从而与生产者解耦，生产者本身并不知道绑定信息）</li>
<li>消费者只从队列获取消息，至于该消息来自哪个交换机其是不知道的</li>
</ul>
<p>相反，<strong>生产者只能将消息发送到交换机 (exchange)</strong> ，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息，是应该把这些消息放到特定队列还是说把他们放到许多队列中还是说应该丢弃它们。这就由交换机的类型来决定。</p>
<p>Exchanges 的类型：</p>
<ul>
<li>直接 (direct)</li>
<li>主题 (topic)</li>
<li>标题 (headers)</li>
<li>扇出 (fanout)</li>
</ul>

        <h2 id="死信队列"   >
          <a href="#死信队列" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#死信队列"></a> 死信队列</h2>
      

        <h2 id="延迟队列"   >
          <a href="#延迟队列" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#延迟队列"></a> 延迟队列</h2>
      
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://yuyun-zhao.gitee.io">yuyun zhao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://yuyun-zhao.gitee.io/2021/08/31/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/">http://yuyun-zhao.gitee.io/2021/08/31/%E3%80%90RabbitMQ%E3%80%91RabbitMQ/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.gitee.io/tags/RabbitMQ/">RabbitMQ</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://yuyun-zhao.gitee.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/09/13/%E3%80%90Docker%E3%80%91Docker/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">【Docker】Docker</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/08/30/%E3%80%90SpringCloud%E3%80%91Gateway/"><span class="paginator-prev__text">【Spring Cloud】Gateway</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#mq-%E7%AE%80%E4%BB%8B"><span class="toc-text">
           MQ 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-mq"><span class="toc-text">
           什么是 MQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-mq"><span class="toc-text">
           为什么要用 MQ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%B6%88%E5%B3%B0"><span class="toc-text">
           流量消峰</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6"><span class="toc-text">
           应用解耦</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="toc-text">
           异步处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mq-%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">
           MQ 的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#activemq"><span class="toc-text">
           ActiveMQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kafka"><span class="toc-text">
           Kafka</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rocketmq"><span class="toc-text">
           RocketMQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rabbitmq"><span class="toc-text">
           RabbitMQ</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mq-%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">
           MQ 的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kafka-2"><span class="toc-text">
           Kafka</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rocketmq-2"><span class="toc-text">
           RocketMQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rabbitmq-2"><span class="toc-text">
           RabbitMQ</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rabbitmq-%E7%AE%80%E4%BB%8B"><span class="toc-text">
           RabbitMQ 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rabbitmq-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">
           RabbitMQ 的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">
           四大核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rabbitmq-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">
           RabbitMQ 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">
           工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-rabbitmq"><span class="toc-text">
           安装 RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">
           常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%8F%8A%E6%8E%88%E6%9D%83%E6%93%8D%E4%BD%9C"><span class="toc-text">
           Web 管理界面及授权操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-%E5%BA%94%E7%94%A8%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">
           Web 应用相关命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rabbitmq-hello-world"><span class="toc-text">
           RabbitMQ Hello World</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%8F%96%E5%80%BC%E5%88%86%E5%8F%91"><span class="toc-text">
           预取值分发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E7%9A%84%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91"><span class="toc-text">
           带权的消息分发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94"><span class="toc-text">
           消息应答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94"><span class="toc-text">
           自动应答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94"><span class="toc-text">
           手动消息应答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%87%8D%E6%96%B0%E5%85%A5%E9%98%9F"><span class="toc-text">
           消息重新入队</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">
           消息&#x2F;队列持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">
           队列持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">
           消息持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4"><span class="toc-text">
           发布确认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83%E7%AD%96%E7%95%A5"><span class="toc-text">
           单个确认发布策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83%E7%AD%96%E7%95%A5"><span class="toc-text">
           批量确认发布策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83%E7%AD%96%E7%95%A5"><span class="toc-text">
           异步确认发布策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA-exchanges"><span class="toc-text">
           交换机 Exchanges</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-text">
           死信队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-text">
           延迟队列</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/author.png" alt="avatar"></div><p class="sidebar-ov-author__text">no code no life</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YUYUN-ZHAO" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="zyy1024462136" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1024462136" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:im.yuyunzhao@gmail.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gmail</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">70</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">28</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">28</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>yuyun zhao</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.xml"></script></body></html>